diff --git a/offline_2/xv6-riscv-riscv/.vscode/settings.json b/offline_2/xv6-riscv-riscv/.vscode/settings.json
index bb879da..4c679cf 100644
--- a/offline_2/xv6-riscv-riscv/.vscode/settings.json
+++ b/offline_2/xv6-riscv-riscv/.vscode/settings.json
@@ -55,5 +55,8 @@
   "C_Cpp_Runner.useLeakSanitizer": false,
   "C_Cpp_Runner.showCompilationTime": false,
   "C_Cpp_Runner.useLinkTimeOptimization": false,
-  "C_Cpp_Runner.msvcSecureNoWarnings": false
+  "C_Cpp_Runner.msvcSecureNoWarnings": false,
+  "files.associations": {
+    "proc.h": "c"
+  }
 }
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/Makefile b/offline_2/xv6-riscv-riscv/Makefile
index 546ecf9..a8b9d44 100644
--- a/offline_2/xv6-riscv-riscv/Makefile
+++ b/offline_2/xv6-riscv-riscv/Makefile
@@ -140,6 +140,8 @@ UPROGS=\
 	$U/_wc\
 	$U/_zombie\
 	$U/_history\
+	$U/_dummyproc\
+	$U/_testprocinfo\
 
 
 fs.img: mkfs/mkfs README $(UPROGS)
diff --git a/offline_2/xv6-riscv-riscv/kernel/main.c b/offline_2/xv6-riscv-riscv/kernel/main.c
index 8911d69..285150a 100644
--- a/offline_2/xv6-riscv-riscv/kernel/main.c
+++ b/offline_2/xv6-riscv-riscv/kernel/main.c
@@ -10,6 +10,7 @@ volatile static int started = 0;
 
 struct syscall_stat syscall_stats[50];
 
+
 const char *syscall_names[] = {
     [SYS_fork] "fork",
     [SYS_exit] "exit",
@@ -33,10 +34,12 @@ const char *syscall_names[] = {
     [SYS_mkdir] "mkdir",
     [SYS_close] "close",
     [SYS_history] "history",
+    [SYS_settickets] "settickets",
+    [SYS_getpinfo] "getpinfo",
 };
 // start() jumps here in supervisor mode on all CPUs.
 
-void initialize_sys_call_stat()
+void initialize_syscall_stat()
 {
   for (int i = 1; i < NELEM(syscall_names); i++)
   {
@@ -46,7 +49,6 @@ void initialize_sys_call_stat()
     syscall_stats[i].accum_time = 0;
   }
 }
-
 void main()
 {
   if (cpuid() == 0)
@@ -68,8 +70,8 @@ void main()
     iinit();            // inode table
     fileinit();         // file table
     virtio_disk_init(); // emulated hard disk
-    initialize_sys_call_stat();
-    userinit();         // first user process
+    initialize_syscall_stat();
+    userinit(); // first user process
     __sync_synchronize();
     started = 1;
   }
diff --git a/offline_2/xv6-riscv-riscv/kernel/param.h b/offline_2/xv6-riscv-riscv/kernel/param.h
index 80ec6d3..b9dc4de 100644
--- a/offline_2/xv6-riscv-riscv/kernel/param.h
+++ b/offline_2/xv6-riscv-riscv/kernel/param.h
@@ -1,15 +1,21 @@
-#define NPROC        64  // maximum number of processes
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       2000  // size of file system in blocks
-#define MAXPATH      128   // maximum file path name
-#define USERSTACK    1     // user stack pages
+#define NPROC 64                  // maximum number of processes
+#define NCPU 8                    // maximum number of CPUs
+#define NOFILE 16                 // open files per process
+#define NFILE 100                 // open files per system
+#define NINODE 50                 // maximum number of active i-nodes
+#define NDEV 10                   // maximum major device number
+#define ROOTDEV 1                 // device number of file system root disk
+#define MAXARG 32                 // max exec arguments
+#define MAXOPBLOCKS 10            // max # of blocks any FS op writes
+#define LOGSIZE (MAXOPBLOCKS * 3) // max data blocks in on-disk log
+#define NBUF (MAXOPBLOCKS * 3)    // size of disk block cache
+#define FSSIZE 2000               // size of file system in blocks
+#define MAXPATH 128               // maximum file path name
+#define USERSTACK 1               // user stack pages
 
+// macros for MLFQ scheduler
+#define TIME_LIMIT_1 1
+#define TIME_LIMIT_2 2
+#define BOOST_INTERVAL 64
+#define DEFAULT_TICKET_COUNT 10
+#define PRINT_SCHEDULING 0
diff --git a/offline_2/xv6-riscv-riscv/kernel/proc.c b/offline_2/xv6-riscv-riscv/kernel/proc.c
index 130d9ce..ec37181 100644
--- a/offline_2/xv6-riscv-riscv/kernel/proc.c
+++ b/offline_2/xv6-riscv-riscv/kernel/proc.c
@@ -5,6 +5,7 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "rand.c"
 
 struct cpu cpus[NCPU];
 
@@ -29,40 +30,39 @@ struct spinlock wait_lock;
 // Allocate a page for each process's kernel stack.
 // Map it high in memory, followed by an invalid
 // guard page.
-void
-proc_mapstacks(pagetable_t kpgtbl)
+void proc_mapstacks(pagetable_t kpgtbl)
 {
   struct proc *p;
-  
-  for(p = proc; p < &proc[NPROC]; p++) {
+
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
     char *pa = kalloc();
-    if(pa == 0)
+    if (pa == 0)
       panic("kalloc");
-    uint64 va = KSTACK((int) (p - proc));
+    uint64 va = KSTACK((int)(p - proc));
     kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
   }
 }
 
 // initialize the proc table.
-void
-procinit(void)
+void procinit(void)
 {
   struct proc *p;
-  
+
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
-  for(p = proc; p < &proc[NPROC]; p++) {
-      initlock(&p->lock, "proc");
-      p->state = UNUSED;
-      p->kstack = KSTACK((int) (p - proc));
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    initlock(&p->lock, "proc");
+    p->state = UNUSED;
+    p->kstack = KSTACK((int)(p - proc));
   }
 }
 
 // Must be called with interrupts disabled,
 // to prevent race with process being moved
 // to a different CPU.
-int
-cpuid()
+int cpuid()
 {
   int id = r_tp();
   return id;
@@ -70,7 +70,7 @@ cpuid()
 
 // Return this CPU's cpu struct.
 // Interrupts must be disabled.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int id = cpuid();
@@ -79,7 +79,7 @@ mycpu(void)
 }
 
 // Return the current struct proc *, or zero if none.
-struct proc*
+struct proc *
 myproc(void)
 {
   push_off();
@@ -89,11 +89,10 @@ myproc(void)
   return p;
 }
 
-int
-allocpid()
+int allocpid()
 {
   int pid;
-  
+
   acquire(&pid_lock);
   pid = nextpid;
   nextpid = nextpid + 1;
@@ -106,16 +105,20 @@ allocpid()
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
 // If there are no free procs, or a memory allocation fails, return 0.
-static struct proc*
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
 
-  for(p = proc; p < &proc[NPROC]; p++) {
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
     acquire(&p->lock);
-    if(p->state == UNUSED) {
+    if (p->state == UNUSED)
+    {
       goto found;
-    } else {
+    }
+    else
+    {
       release(&p->lock);
     }
   }
@@ -126,7 +129,8 @@ found:
   p->state = USED;
 
   // Allocate a trapframe page.
-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+  if ((p->trapframe = (struct trapframe *)kalloc()) == 0)
+  {
     freeproc(p);
     release(&p->lock);
     return 0;
@@ -134,7 +138,8 @@ found:
 
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
-  if(p->pagetable == 0){
+  if (p->pagetable == 0)
+  {
     freeproc(p);
     release(&p->lock);
     return 0;
@@ -146,6 +151,13 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  // Initialize the MLFQ scheduler fields.
+  //--------------------------------------
+  p->queue = 1; // A new process is always inserted at the end (tail) of the topmost queue (queue 1).
+  p->tickets_original = DEFAULT_TICKET_COUNT;
+  p->tickets_current = DEFAULT_TICKET_COUNT;
+  p->current_time_slice = 0;
+  //---------------------------------------
   return p;
 }
 
@@ -155,10 +167,10 @@ found:
 static void
 freeproc(struct proc *p)
 {
-  if(p->trapframe)
-    kfree((void*)p->trapframe);
+  if (p->trapframe)
+    kfree((void *)p->trapframe);
   p->trapframe = 0;
-  if(p->pagetable)
+  if (p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
   p->sz = 0;
@@ -180,23 +192,25 @@ proc_pagetable(struct proc *p)
 
   // An empty page table.
   pagetable = uvmcreate();
-  if(pagetable == 0)
+  if (pagetable == 0)
     return 0;
 
   // map the trampoline code (for system call return)
   // at the highest user virtual address.
   // only the supervisor uses it, on the way
   // to/from user space, so not PTE_U.
-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
-              (uint64)trampoline, PTE_R | PTE_X) < 0){
+  if (mappages(pagetable, TRAMPOLINE, PGSIZE,
+               (uint64)trampoline, PTE_R | PTE_X) < 0)
+  {
     uvmfree(pagetable, 0);
     return 0;
   }
 
   // map the trapframe page just below the trampoline page, for
   // trampoline.S.
-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+  if (mappages(pagetable, TRAPFRAME, PGSIZE,
+               (uint64)(p->trapframe), PTE_R | PTE_W) < 0)
+  {
     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
     uvmfree(pagetable, 0);
     return 0;
@@ -207,8 +221,7 @@ proc_pagetable(struct proc *p)
 
 // Free a process's page table, and free the
 // physical memory it refers to.
-void
-proc_freepagetable(pagetable_t pagetable, uint64 sz)
+void proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
@@ -219,32 +232,30 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
 // assembled from ../user/initcode.S
 // od -t xC ../user/initcode
 uchar initcode[] = {
-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00
-};
+    0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
+    0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
+    0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
+    0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
+    0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
+    0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00};
 
 // Set up first user process.
-void
-userinit(void)
+void userinit(void)
 {
   struct proc *p;
 
   p = allocproc();
   initproc = p;
-  
+
   // allocate one user page and copy initcode's instructions
   // and data into it.
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
 
   // prepare for the very first "return" from kernel to user.
-  p->trapframe->epc = 0;      // user program counter
-  p->trapframe->sp = PGSIZE;  // user stack pointer
+  p->trapframe->epc = 0;     // user program counter
+  p->trapframe->sp = PGSIZE; // user stack pointer
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -256,18 +267,21 @@ userinit(void)
 
 // Grow or shrink user memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint64 sz;
   struct proc *p = myproc();
 
   sz = p->sz;
-  if(n > 0){
-    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+  if (n > 0)
+  {
+    if ((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0)
+    {
       return -1;
     }
-  } else if(n < 0){
+  }
+  else if (n < 0)
+  {
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
   p->sz = sz;
@@ -276,20 +290,21 @@ growproc(int n)
 
 // Create a new process, copying the parent.
 // Sets up child kernel stack to return as if from fork() system call.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *p = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy user memory from parent to child.
-  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+  if (uvmcopy(p->pagetable, np->pagetable, p->sz) < 0)
+  {
     freeproc(np);
     release(&np->lock);
     return -1;
@@ -303,8 +318,8 @@ fork(void)
   np->trapframe->a0 = 0;
 
   // increment reference counts on open file descriptors.
-  for(i = 0; i < NOFILE; i++)
-    if(p->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (p->ofile[i])
       np->ofile[i] = filedup(p->ofile[i]);
   np->cwd = idup(p->cwd);
 
@@ -322,18 +337,28 @@ fork(void)
   np->state = RUNNABLE;
   release(&np->lock);
 
+  // MLFQ scheduling changes
+  // child inherits the same number of tickets as its parent
+  //---------------------------------
+  acquire(&p->lock);
+  np->tickets_original = p->tickets_original;
+  np->tickets_current = p->tickets_original;
+  release(&p->lock);
+  //---------------------------------
+
   return pid;
 }
 
 // Pass p's abandoned children to init.
 // Caller must hold wait_lock.
-void
-reparent(struct proc *p)
+void reparent(struct proc *p)
 {
   struct proc *pp;
 
-  for(pp = proc; pp < &proc[NPROC]; pp++){
-    if(pp->parent == p){
+  for (pp = proc; pp < &proc[NPROC]; pp++)
+  {
+    if (pp->parent == p)
+    {
       pp->parent = initproc;
       wakeup(initproc);
     }
@@ -343,17 +368,18 @@ reparent(struct proc *p)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait().
-void
-exit(int status)
+void exit(int status)
 {
   struct proc *p = myproc();
 
-  if(p == initproc)
+  if (p == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(int fd = 0; fd < NOFILE; fd++){
-    if(p->ofile[fd]){
+  for (int fd = 0; fd < NOFILE; fd++)
+  {
+    if (p->ofile[fd])
+    {
       struct file *f = p->ofile[fd];
       fileclose(f);
       p->ofile[fd] = 0;
@@ -372,7 +398,7 @@ exit(int status)
 
   // Parent might be sleeping in wait().
   wakeup(p->parent);
-  
+
   acquire(&p->lock);
 
   p->xstate = status;
@@ -387,8 +413,7 @@ exit(int status)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(uint64 addr)
+int wait(uint64 addr)
 {
   struct proc *pp;
   int havekids, pid;
@@ -396,20 +421,25 @@ wait(uint64 addr)
 
   acquire(&wait_lock);
 
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(pp = proc; pp < &proc[NPROC]; pp++){
-      if(pp->parent == p){
+    for (pp = proc; pp < &proc[NPROC]; pp++)
+    {
+      if (pp->parent == p)
+      {
         // make sure the child isn't still in exit() or swtch().
         acquire(&pp->lock);
 
         havekids = 1;
-        if(pp->state == ZOMBIE){
+        if (pp->state == ZOMBIE)
+        {
           // Found one.
           pid = pp->pid;
-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
-                                  sizeof(pp->xstate)) < 0) {
+          if (addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+                                   sizeof(pp->xstate)) < 0)
+          {
             release(&pp->lock);
             release(&wait_lock);
             return -1;
@@ -424,13 +454,14 @@ wait(uint64 addr)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || killed(p)){
+    if (!havekids || killed(p))
+    {
       release(&wait_lock);
       return -1;
     }
-    
+
     // Wait for a child to exit.
-    sleep(p, &wait_lock);  //DOC: wait-sleep
+    sleep(p, &wait_lock); // DOC: wait-sleep
   }
 }
 
@@ -441,45 +472,140 @@ wait(uint64 addr)
 //  - swtch to start running that process.
 //  - eventually that process transfers control
 //    via swtch back to the scheduler.
-void
-scheduler(void)
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
+  // static int boost_interval = 0;
 
   c->proc = 0;
-  for(;;){
-    // The most recent process to run may have had interrupts
-    // turned off; enable them to avoid a deadlock if all
-    // processes are waiting.
+  c->boost_interval = 0;
+  for (;;)
+  {
+    // Enable interrupts to avoid deadlock.
     intr_on();
 
-    int found = 0;
-    for(p = proc; p < &proc[NPROC]; p++) {
-      acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
-        found = 1;
+    // Priority Boosting
+    if (c->boost_interval >= BOOST_INTERVAL)
+    {
+      for (p = proc; p < &proc[NPROC]; p++)
+      {
+        acquire(&p->lock);
+        if (p->state == RUNNABLE)
+        {
+          if (PRINT_SCHEDULING)
+          {
+            printf("Boosting process %d from queue %d to queue 1\n", p->pid, p->queue);
+          }
+          p->queue = 1;
+          p->current_time_slice = 0;
+        }
+        release(&p->lock);
+      }
+      c->boost_interval = 0; // Reset after boosting
+    }
+
+    p = 0;
+
+    // Lottery Scheduling
+
+    int total_tickets = 0;
+    for (struct proc *temp_p = proc; temp_p < &proc[NPROC]; temp_p++)
+    {
+      acquire(&temp_p->lock);
+      if (temp_p->state == RUNNABLE && temp_p->queue == 1)
+      {
+        total_tickets += temp_p->tickets_current;
+      }
+      release(&temp_p->lock);
+    }
+
+    if (total_tickets > 0)
+    {
+      unsigned long winner_ticket = random() % total_tickets;
+      int sum = 0;
+      for (struct proc *temp_p = proc; temp_p < &proc[NPROC]; temp_p++)
+      {
+        acquire(&temp_p->lock);
+        if (temp_p->state == RUNNABLE && temp_p->queue == 1)
+        {
+          sum += temp_p->tickets_current;
+          if (sum > winner_ticket)
+          {
+            p = temp_p;
+            break;
+          }
+        }
+        release(&temp_p->lock);
       }
-      release(&p->lock);
     }
-    if(found == 0) {
-      // nothing to run; stop running on this core until an interrupt.
-      intr_on();
-      asm volatile("wfi");
+
+    // If no winner from lottery, try Round-Robin (Queue 2)
+    if (p == 0)
+    {
+      for (struct proc *temp_p = proc; temp_p < &proc[NPROC]; temp_p++)
+      {
+        acquire(&temp_p->lock);
+        if (temp_p->state == RUNNABLE && temp_p->queue == 2)
+        {
+          p = temp_p;
+          break;
+        }
+        release(&temp_p->lock);
+      }
     }
+
+    if (p)
+    {
+      p->state = RUNNING;
+      c->proc = p;
+      swtch(&c->context, &p->context);
+      c->proc = 0;
+
+      // Update stats for the queue it just ran in
+      if (p->queue == 1)
+      {
+        if (p->tickets_current > 0)
+          p->tickets_current--;
+        p->current_time_slice++;
+        p->time_slices++;
+        if (p->current_time_slice > TIME_LIMIT_1)
+        {
+          if (PRINT_SCHEDULING)
+          {
+            printf("Process %d moved to queue 2 after %d time slices in queue 1\n", p->pid, p->current_time_slice);
+          }
+          p->queue = 2;
+          p->current_time_slice = 0;
+        }
+        if (p->tickets_current <= 0)
+        {
+          p->state = UNUSED;
+        }
+      }
+      else
+      {
+        p->current_time_slice++;
+        p->time_slices++;
+        if (p->current_time_slice > TIME_LIMIT_2)
+        {
+          if (PRINT_SCHEDULING)
+          {
+            printf("Process %d reinserted to queue 2 after time slice %d\n", p->pid, p->current_time_slice);
+          }
+          p->current_time_slice = 0;
+        }
+        if (p->tickets_current <= 0)
+        {
+          p->state = UNUSED;
+        }
+      }
+
+      release(&p->lock);
+    }
+    c->boost_interval++;
   }
 }
-
 // Switch to scheduler.  Must hold only p->lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -487,19 +613,18 @@ scheduler(void)
 // be proc->intena and proc->noff, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&p->lock))
+  if (!holding(&p->lock))
     panic("sched p->lock");
-  if(mycpu()->noff != 1)
+  if (mycpu()->noff != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(intr_get())
+  if (intr_get())
     panic("sched interruptible");
 
   intena = mycpu()->intena;
@@ -508,8 +633,7 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
   struct proc *p = myproc();
   acquire(&p->lock);
@@ -520,15 +644,15 @@ yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch to forkret.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
 
   // Still holding p->lock from scheduler.
   release(&myproc()->lock);
 
-  if (first) {
+  if (first)
+  {
     // File system initialization must be run in the context of a
     // regular process (e.g., because it calls sleep), and thus cannot
     // be run from main().
@@ -544,11 +668,10 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   // Must acquire p->lock in order to
   // change p->state and then call sched.
   // Once we hold p->lock, we can be
@@ -556,7 +679,7 @@ sleep(void *chan, struct spinlock *lk)
   // (wakeup locks p->lock),
   // so it's okay to release lk.
 
-  acquire(&p->lock);  //DOC: sleeplock1
+  acquire(&p->lock); // DOC: sleeplock1
   release(lk);
 
   // Go to sleep.
@@ -575,15 +698,17 @@ sleep(void *chan, struct spinlock *lk)
 
 // Wake up all processes sleeping on chan.
 // Must be called without any p->lock.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   struct proc *p;
 
-  for(p = proc; p < &proc[NPROC]; p++) {
-    if(p != myproc()){
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p != myproc())
+    {
       acquire(&p->lock);
-      if(p->state == SLEEPING && p->chan == chan) {
+      if (p->state == SLEEPING && p->chan == chan)
+      {
         p->state = RUNNABLE;
       }
       release(&p->lock);
@@ -594,16 +719,18 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // The victim won't exit until it tries to return
 // to user space (see usertrap() in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
-  for(p = proc; p < &proc[NPROC]; p++){
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
     acquire(&p->lock);
-    if(p->pid == pid){
+    if (p->pid == pid)
+    {
       p->killed = 1;
-      if(p->state == SLEEPING){
+      if (p->state == SLEEPING)
+      {
         // Wake process from sleep().
         p->state = RUNNABLE;
       }
@@ -615,19 +742,17 @@ kill(int pid)
   return -1;
 }
 
-void
-setkilled(struct proc *p)
+void setkilled(struct proc *p)
 {
   acquire(&p->lock);
   p->killed = 1;
   release(&p->lock);
 }
 
-int
-killed(struct proc *p)
+int killed(struct proc *p)
 {
   int k;
-  
+
   acquire(&p->lock);
   k = p->killed;
   release(&p->lock);
@@ -637,13 +762,15 @@ killed(struct proc *p)
 // Copy to either a user address, or kernel address,
 // depending on usr_dst.
 // Returns 0 on success, -1 on error.
-int
-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+int either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
 {
   struct proc *p = myproc();
-  if(user_dst){
+  if (user_dst)
+  {
     return copyout(p->pagetable, dst, src, len);
-  } else {
+  }
+  else
+  {
     memmove((char *)dst, src, len);
     return 0;
   }
@@ -652,14 +779,16 @@ either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
 // Copy from either a user address, or kernel address,
 // depending on usr_src.
 // Returns 0 on success, -1 on error.
-int
-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+int either_copyin(void *dst, int user_src, uint64 src, uint64 len)
 {
   struct proc *p = myproc();
-  if(user_src){
+  if (user_src)
+  {
     return copyin(p->pagetable, dst, src, len);
-  } else {
-    memmove(dst, (char*)src, len);
+  }
+  else
+  {
+    memmove(dst, (char *)src, len);
     return 0;
   }
 }
@@ -667,25 +796,24 @@ either_copyin(void *dst, int user_src, uint64 src, uint64 len)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [USED]      "used",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [USED] "used",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   struct proc *p;
   char *state;
 
   printf("\n");
-  for(p = proc; p < &proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
diff --git a/offline_2/xv6-riscv-riscv/kernel/proc.h b/offline_2/xv6-riscv-riscv/kernel/proc.h
index d021857..79ddd50 100644
--- a/offline_2/xv6-riscv-riscv/kernel/proc.h
+++ b/offline_2/xv6-riscv-riscv/kernel/proc.h
@@ -24,6 +24,7 @@ struct cpu {
   struct context context;     // swtch() here to enter scheduler().
   int noff;                   // Depth of push_off() nesting.
   int intena;                 // Were interrupts enabled before push_off()?
+  int boost_interval;
 };
 
 extern struct cpu cpus[NCPU];
@@ -104,4 +105,13 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  // MLFQ scheduler fields
+  //----------------------
+  int queue;
+  int tickets_original;
+  int tickets_current;
+  int time_slices;
+  int current_time_slice;
+  //----------------------
 };
diff --git a/offline_2/xv6-riscv-riscv/kernel/pstat.h b/offline_2/xv6-riscv-riscv/kernel/pstat.h
new file mode 100644
index 0000000..2064a48
--- /dev/null
+++ b/offline_2/xv6-riscv-riscv/kernel/pstat.h
@@ -0,0 +1,16 @@
+#ifndef _PSTAT_H_
+#define _PSTAT_H_
+#include "param.h"
+#include "spinlock.h"
+struct pstat
+{
+    int pid[NPROC];
+    int inuse[NPROC];
+    int inQ[NPROC];
+    int tickets_original[NPROC];
+    int tickets_current[NPROC];
+    int time_slices[NPROC];
+    struct spinlock lock;
+};
+
+#endif // _PSTAT_H_
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/kernel/rand.c b/offline_2/xv6-riscv-riscv/kernel/rand.c
new file mode 100644
index 0000000..9361a4d
--- /dev/null
+++ b/offline_2/xv6-riscv-riscv/kernel/rand.c
@@ -0,0 +1,25 @@
+#include "param.h"
+#include "types.h"
+#include "defs.h"
+
+// Return a integer between 0 and ((2^32 - 1) / 2), which is 2147483647.
+uint
+random(void)
+{
+  // Take from http://stackoverflow.com/questions/1167253/implementation-of-rand
+  static unsigned int z1 = 12345, z2 = 12345, z3 = 12345, z4 = 12345;
+  unsigned int b;
+  b  = ((z1 << 6) ^ z1) >> 13;
+  z1 = ((z1 & 4294967294U) << 18) ^ b;
+  b  = ((z2 << 2) ^ z2) >> 27; 
+  z2 = ((z2 & 4294967288U) << 2) ^ b;
+  b  = ((z3 << 13) ^ z3) >> 21;
+  z3 = ((z3 & 4294967280U) << 7) ^ b;
+  b  = ((z4 << 3) ^ z4) >> 12;
+  z4 = ((z4 & 4294967168U) << 13) ^ b;
+
+  return (z1 ^ z2 ^ z3 ^ z4) / 2;
+}
+
+//credits to
+//https://github.com/joonlim/xv6/blob/master/random.c
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.c b/offline_2/xv6-riscv-riscv/kernel/syscall.c
index 35b9ff0..76d302b 100644
--- a/offline_2/xv6-riscv-riscv/kernel/syscall.c
+++ b/offline_2/xv6-riscv-riscv/kernel/syscall.c
@@ -103,6 +103,9 @@ extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
 extern uint64 sys_history(void);
+extern uint64 sys_settickets(void);
+extern uint64 sys_getpinfo(void);
+
 extern uint ticks;
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -129,6 +132,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
 [SYS_history] sys_history,
+[SYS_settickets] sys_settickets,
+[SYS_getpinfo] sys_getpinfo,
 };
 
 void
diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.h b/offline_2/xv6-riscv-riscv/kernel/syscall.h
index 3b56b8f..809745f 100644
--- a/offline_2/xv6-riscv-riscv/kernel/syscall.h
+++ b/offline_2/xv6-riscv-riscv/kernel/syscall.h
@@ -20,4 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
-#define SYS_history 22
\ No newline at end of file
+#define SYS_history 22
+#define SYS_settickets 23
+#define SYS_getpinfo 24
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/kernel/sysproc.c b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
index 10b0e2c..3efd16d 100644
--- a/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+++ b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
@@ -7,6 +7,9 @@
 #include "proc.h"
 #include "syscall.h"
 #include "syscall_stat.h"
+#include "pstat.h"
+
+extern struct proc proc[NPROC];
 
 uint64
 sys_exit(void)
@@ -129,3 +132,78 @@ sys_history(void)
   }
   return 0;
 }
+
+// MLFQ scheduler related syscalls
+uint64
+sys_settickets(void)
+{
+  int tickets;
+  struct proc *p = myproc();
+
+  argint(0, &tickets);
+  if (tickets < 1)
+  {
+    acquire(&p->lock);
+    p->tickets_original = DEFAULT_TICKET_COUNT;
+    p->tickets_current = DEFAULT_TICKET_COUNT;
+    release(&p->lock);
+    return -1;
+  }
+
+  acquire(&p->lock);
+  p->tickets_original = tickets;
+  p->tickets_current = tickets;
+  release(&p->lock);
+
+  return 0;
+}
+
+uint64
+sys_getpinfo(void)
+{
+  struct pstat pstat_local;
+  struct proc *p;
+
+  uint64 uptr;
+  argaddr(0, &uptr);
+
+  // Initialize and fill pstat_local
+  for (int i = 0; i < NPROC; i++)
+  {
+    pstat_local.pid[i] = 0;
+    pstat_local.inuse[i] = 0;
+    pstat_local.inQ[i] = 0;
+    pstat_local.tickets_original[i] = 0;
+    pstat_local.tickets_current[i] = 0;
+    pstat_local.time_slices[i] = 0;
+    initlock(&pstat_local.lock, "pstat_lock");
+  }
+
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    acquire(&p->lock);
+    if (p->state != UNUSED)
+    {
+      acquire(&pstat_local.lock);
+      int i = p - proc;
+      pstat_local.pid[i] = p->pid;
+      pstat_local.inuse[i] = 1;
+      pstat_local.inQ[i] = p->queue;
+      pstat_local.tickets_original[i] = p->tickets_original;
+      pstat_local.tickets_current[i] = p->tickets_current;
+      pstat_local.time_slices[i] = p->time_slices;
+      release(&pstat_local.lock);
+    }
+    release(&p->lock);
+  }
+
+  acquire(&pstat_local.lock);
+  int ret = copyout(myproc()->pagetable, uptr, (char *)&pstat_local, sizeof(struct pstat));
+  release(&pstat_local.lock);
+  if (ret < 0)
+  {
+    return -1;
+  }
+
+  return 0;
+}
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/new_task1 b/offline_2/xv6-riscv-riscv/new_task1
new file mode 100644
index 0000000..e69de29
diff --git a/offline_2/xv6-riscv-riscv/patch b/offline_2/xv6-riscv-riscv/patch
new file mode 100644
index 0000000..dc94b44
--- /dev/null
+++ b/offline_2/xv6-riscv-riscv/patch
@@ -0,0 +1,18937 @@
+diff --git a/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
+new file mode 100644
+index 0000000..c2098a2
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
+@@ -0,0 +1,18 @@
++{
++  "configurations": [
++    {
++      "name": "linux-gcc-x64",
++      "includePath": [
++        "${workspaceFolder}/**"
++      ],
++      "compilerPath": "/usr/bin/gcc",
++      "cStandard": "${default}",
++      "cppStandard": "${default}",
++      "intelliSenseMode": "linux-gcc-x64",
++      "compilerArgs": [
++        ""
++      ]
++    }
++  ],
++  "version": 4
++}
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/.vscode/launch.json b/offline_2/xv6-riscv-riscv/.vscode/launch.json
+new file mode 100644
+index 0000000..cc00405
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/.vscode/launch.json
+@@ -0,0 +1,24 @@
++{
++  "version": "0.2.0",
++  "configurations": [
++    {
++      "name": "C/C++ Runner: Debug Session",
++      "type": "cppdbg",
++      "request": "launch",
++      "args": [],
++      "stopAtEntry": false,
++      "externalConsole": false,
++      "cwd": ".",
++      "program": "build/Debug/outDebug",
++      "MIMode": "gdb",
++      "miDebuggerPath": "gdb",
++      "setupCommands": [
++        {
++          "description": "Enable pretty-printing for gdb",
++          "text": "-enable-pretty-printing",
++          "ignoreFailures": true
++        }
++      ]
++    }
++  ]
++}
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/.vscode/settings.json b/offline_2/xv6-riscv-riscv/.vscode/settings.json
+new file mode 100644
+index 0000000..bb879da
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/.vscode/settings.json
+@@ -0,0 +1,59 @@
++{
++  "C_Cpp_Runner.cCompilerPath": "gcc",
++  "C_Cpp_Runner.cppCompilerPath": "g++",
++  "C_Cpp_Runner.debuggerPath": "gdb",
++  "C_Cpp_Runner.cStandard": "",
++  "C_Cpp_Runner.cppStandard": "",
++  "C_Cpp_Runner.msvcBatchPath": "C:/Program Files/Microsoft Visual Studio/VR_NR/Community/VC/Auxiliary/Build/vcvarsall.bat",
++  "C_Cpp_Runner.useMsvc": false,
++  "C_Cpp_Runner.warnings": [
++    "-Wall",
++    "-Wextra",
++    "-Wpedantic",
++    "-Wshadow",
++    "-Wformat=2",
++    "-Wcast-align",
++    "-Wconversion",
++    "-Wsign-conversion",
++    "-Wnull-dereference"
++  ],
++  "C_Cpp_Runner.msvcWarnings": [
++    "/W4",
++    "/permissive-",
++    "/w14242",
++    "/w14287",
++    "/w14296",
++    "/w14311",
++    "/w14826",
++    "/w44062",
++    "/w44242",
++    "/w14905",
++    "/w14906",
++    "/w14263",
++    "/w44265",
++    "/w14928"
++  ],
++  "C_Cpp_Runner.enableWarnings": true,
++  "C_Cpp_Runner.warningsAsError": false,
++  "C_Cpp_Runner.compilerArgs": [],
++  "C_Cpp_Runner.linkerArgs": [],
++  "C_Cpp_Runner.includePaths": [],
++  "C_Cpp_Runner.includeSearch": [
++    "*",
++    "**/*"
++  ],
++  "C_Cpp_Runner.excludeSearch": [
++    "**/build",
++    "**/build/**",
++    "**/.*",
++    "**/.*/**",
++    "**/.vscode",
++    "**/.vscode/**"
++  ],
++  "C_Cpp_Runner.useAddressSanitizer": false,
++  "C_Cpp_Runner.useUndefinedSanitizer": false,
++  "C_Cpp_Runner.useLeakSanitizer": false,
++  "C_Cpp_Runner.showCompilationTime": false,
++  "C_Cpp_Runner.useLinkTimeOptimization": false,
++  "C_Cpp_Runner.msvcSecureNoWarnings": false
++}
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/Makefile b/offline_2/xv6-riscv-riscv/Makefile
+index f8c820e..546ecf9 100644
+--- a/offline_2/xv6-riscv-riscv/Makefile
++++ b/offline_2/xv6-riscv-riscv/Makefile
+@@ -139,6 +139,8 @@ UPROGS=\
+ 	$U/_grind\
+ 	$U/_wc\
+ 	$U/_zombie\
++	$U/_history\
++
+ 
+ fs.img: mkfs/mkfs README $(UPROGS)
+ 	mkfs/mkfs fs.img README $(UPROGS)
+diff --git a/offline_2/xv6-riscv-riscv/kernel/main.c b/offline_2/xv6-riscv-riscv/kernel/main.c
+index f0d3171..8911d69 100644
+--- a/offline_2/xv6-riscv-riscv/kernel/main.c
++++ b/offline_2/xv6-riscv-riscv/kernel/main.c
+@@ -3,43 +3,86 @@
+ #include "memlayout.h"
+ #include "riscv.h"
+ #include "defs.h"
+-
++#include "syscall.h"
++#include "syscall_stat.h"
++#include "spinlock.h"
+ volatile static int started = 0;
+ 
++struct syscall_stat syscall_stats[50];
++
++const char *syscall_names[] = {
++    [SYS_fork] "fork",
++    [SYS_exit] "exit",
++    [SYS_wait] "wait",
++    [SYS_pipe] "pipe",
++    [SYS_read] "read",
++    [SYS_kill] "kill",
++    [SYS_exec] "exec",
++    [SYS_fstat] "fstat",
++    [SYS_chdir] "chdir",
++    [SYS_dup] "dup",
++    [SYS_getpid] "getpid",
++    [SYS_sbrk] "sbrk",
++    [SYS_sleep] "sleep",
++    [SYS_uptime] "uptime",
++    [SYS_open] "open",
++    [SYS_write] "write",
++    [SYS_mknod] "mknod",
++    [SYS_unlink] "unlink",
++    [SYS_link] "link",
++    [SYS_mkdir] "mkdir",
++    [SYS_close] "close",
++    [SYS_history] "history",
++};
+ // start() jumps here in supervisor mode on all CPUs.
+-void
+-main()
++
++void initialize_sys_call_stat()
++{
++  for (int i = 1; i < NELEM(syscall_names); i++)
++  {
++    initlock(&syscall_stats[i].syscall_stat_lock, "syscall_stat_lock");
++    strncpy(syscall_stats[i].syscall_name, syscall_names[i], sizeof(syscall_stats[i].syscall_name));
++    syscall_stats[i].count = 0;
++    syscall_stats[i].accum_time = 0;
++  }
++}
++
++void main()
+ {
+-  if(cpuid() == 0){
++  if (cpuid() == 0)
++  {
+     consoleinit();
+     printfinit();
+     printf("\n");
+     printf("xv6 kernel is booting\n");
+     printf("\n");
+-    kinit();         // physical page allocator
+-    kvminit();       // create kernel page table
+-    kvminithart();   // turn on paging
+-    procinit();      // process table
+-    trapinit();      // trap vectors
+-    trapinithart();  // install kernel trap vector
+-    plicinit();      // set up interrupt controller
+-    plicinithart();  // ask PLIC for device interrupts
+-    binit();         // buffer cache
+-    iinit();         // inode table
+-    fileinit();      // file table
++    kinit();            // physical page allocator
++    kvminit();          // create kernel page table
++    kvminithart();      // turn on paging
++    procinit();         // process table
++    trapinit();         // trap vectors
++    trapinithart();     // install kernel trap vector
++    plicinit();         // set up interrupt controller
++    plicinithart();     // ask PLIC for device interrupts
++    binit();            // buffer cache
++    iinit();            // inode table
++    fileinit();         // file table
+     virtio_disk_init(); // emulated hard disk
+-    userinit();      // first user process
++    initialize_sys_call_stat();
++    userinit();         // first user process
+     __sync_synchronize();
+     started = 1;
+-  } else {
+-    while(started == 0)
++  }
++  else
++  {
++    while (started == 0)
+       ;
+     __sync_synchronize();
+     printf("hart %d starting\n", cpuid());
+-    kvminithart();    // turn on paging
+-    trapinithart();   // install kernel trap vector
+-    plicinithart();   // ask PLIC for device interrupts
++    kvminithart();  // turn on paging
++    trapinithart(); // install kernel trap vector
++    plicinithart(); // ask PLIC for device interrupts
+   }
+ 
+-  scheduler();        
++  scheduler();
+ }
+diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.c b/offline_2/xv6-riscv-riscv/kernel/syscall.c
+index ed65409..35b9ff0 100644
+--- a/offline_2/xv6-riscv-riscv/kernel/syscall.c
++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.c
+@@ -6,6 +6,7 @@
+ #include "proc.h"
+ #include "syscall.h"
+ #include "defs.h"
++#include "syscall_stat.h"
+ 
+ // Fetch the uint64 at addr from the current process.
+ int
+@@ -101,7 +102,8 @@ extern uint64 sys_unlink(void);
+ extern uint64 sys_link(void);
+ extern uint64 sys_mkdir(void);
+ extern uint64 sys_close(void);
+-
++extern uint64 sys_history(void);
++extern uint ticks;
+ // An array mapping syscall numbers from syscall.h
+ // to the function that handles the system call.
+ static uint64 (*syscalls[])(void) = {
+@@ -126,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_history] sys_history,
+ };
+ 
+ void
+@@ -133,15 +136,23 @@ syscall(void)
+ {
+   int num;
+   struct proc *p = myproc();
+-
++  uint start_ticks = ticks;
+   num = p->trapframe->a7;
+   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+     // Use num to lookup the system call function for num, call it,
+     // and store its return value in p->trapframe->a0
++
++    //update the syscall statistics
+     p->trapframe->a0 = syscalls[num]();
+   } else {
+     printf("%d %s: unknown sys call %d\n",
+             p->pid, p->name, num);
+     p->trapframe->a0 = -1;
+   }
++  uint end_ticks = ticks;
++  // Update syscall statistics
++  acquire(&syscall_stats[num].syscall_stat_lock);
++  syscall_stats[num].count++;
++  syscall_stats[num].accum_time += (end_ticks - start_ticks);
++  release(&syscall_stats[num].syscall_stat_lock);
+ }
+diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.h b/offline_2/xv6-riscv-riscv/kernel/syscall.h
+index bc5f356..3b56b8f 100644
+--- a/offline_2/xv6-riscv-riscv/kernel/syscall.h
++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.h
+@@ -20,3 +20,4 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_history 22
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
+new file mode 100644
+index 0000000..7066b76
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
+@@ -0,0 +1,10 @@
++#include "spinlock.h"
++
++struct syscall_stat {
++    char syscall_name[16];
++    int count;
++    int accum_time;
++    struct spinlock syscall_stat_lock;
++};
++
++extern struct syscall_stat syscall_stats[50];
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/kernel/sysproc.c b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+index 3b4d5bd..10b0e2c 100644
+--- a/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++++ b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+@@ -5,6 +5,8 @@
+ #include "memlayout.h"
+ #include "spinlock.h"
+ #include "proc.h"
++#include "syscall.h"
++#include "syscall_stat.h"
+ 
+ uint64
+ sys_exit(void)
+@@ -12,7 +14,7 @@ sys_exit(void)
+   int n;
+   argint(0, &n);
+   exit(n);
+-  return 0;  // not reached
++  return 0; // not reached
+ }
+ 
+ uint64
+@@ -43,7 +45,7 @@ sys_sbrk(void)
+ 
+   argint(0, &n);
+   addr = myproc()->sz;
+-  if(growproc(n) < 0)
++  if (growproc(n) < 0)
+     return -1;
+   return addr;
+ }
+@@ -55,12 +57,14 @@ sys_sleep(void)
+   uint ticks0;
+ 
+   argint(0, &n);
+-  if(n < 0)
++  if (n < 0)
+     n = 0;
+   acquire(&tickslock);
+   ticks0 = ticks;
+-  while(ticks - ticks0 < n){
+-    if(killed(myproc())){
++  while (ticks - ticks0 < n)
++  {
++    if (killed(myproc()))
++    {
+       release(&tickslock);
+       return -1;
+     }
+@@ -91,3 +95,37 @@ sys_uptime(void)
+   release(&tickslock);
+   return xticks;
+ }
++
++uint64
++sys_history(void)
++{
++  int syscall_num;
++  uint64 userspace_struct_address;
++
++  argint(0, &syscall_num);
++  argaddr(1, &userspace_struct_address);
++  if (syscall_num < 0 || syscall_num >= NELEM(syscall_stats))
++  {
++    return -1;
++  }
++  struct syscall_stat temp_stat;
++  // acquire lock
++  acquire(&syscall_stats[syscall_num].syscall_stat_lock);
++  // temp_stat = syscall_stats[syscall_num];
++  memmove(&temp_stat, &syscall_stats[syscall_num], sizeof(temp_stat));
++  release(&syscall_stats[syscall_num].syscall_stat_lock);
++  // Ensure the syscall name is null-terminated
++  temp_stat.syscall_name[sizeof(temp_stat.syscall_name) - 1] = '\0';
++  // Check if the userspace address is valid
++  if (userspace_struct_address + sizeof(temp_stat) >= MAXVA)
++  {
++    return -1;
++  }
++  // Copy the syscall statistics to user space
++  int ret_val = copyout(myproc()->pagetable, userspace_struct_address, (char *)&temp_stat, sizeof(temp_stat));
++  if (ret_val < 0)
++  {
++    return -1;
++  }
++  return 0;
++}
+diff --git a/offline_2/xv6-riscv-riscv/new_task1.patch b/offline_2/xv6-riscv-riscv/new_task1.patch
+new file mode 100644
+index 0000000..60090dc
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/new_task1.patch
+@@ -0,0 +1,9466 @@
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
++new file mode 100644
++index 0000000..c2098a2
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
++@@ -0,0 +1,18 @@
+++{
+++  "configurations": [
+++    {
+++      "name": "linux-gcc-x64",
+++      "includePath": [
+++        "${workspaceFolder}/**"
+++      ],
+++      "compilerPath": "/usr/bin/gcc",
+++      "cStandard": "${default}",
+++      "cppStandard": "${default}",
+++      "intelliSenseMode": "linux-gcc-x64",
+++      "compilerArgs": [
+++        ""
+++      ]
+++    }
+++  ],
+++  "version": 4
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/launch.json b/offline_2/xv6-riscv-riscv/.vscode/launch.json
++new file mode 100644
++index 0000000..cc00405
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/launch.json
++@@ -0,0 +1,24 @@
+++{
+++  "version": "0.2.0",
+++  "configurations": [
+++    {
+++      "name": "C/C++ Runner: Debug Session",
+++      "type": "cppdbg",
+++      "request": "launch",
+++      "args": [],
+++      "stopAtEntry": false,
+++      "externalConsole": false,
+++      "cwd": ".",
+++      "program": "build/Debug/outDebug",
+++      "MIMode": "gdb",
+++      "miDebuggerPath": "gdb",
+++      "setupCommands": [
+++        {
+++          "description": "Enable pretty-printing for gdb",
+++          "text": "-enable-pretty-printing",
+++          "ignoreFailures": true
+++        }
+++      ]
+++    }
+++  ]
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/settings.json b/offline_2/xv6-riscv-riscv/.vscode/settings.json
++new file mode 100644
++index 0000000..bb879da
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/settings.json
++@@ -0,0 +1,59 @@
+++{
+++  "C_Cpp_Runner.cCompilerPath": "gcc",
+++  "C_Cpp_Runner.cppCompilerPath": "g++",
+++  "C_Cpp_Runner.debuggerPath": "gdb",
+++  "C_Cpp_Runner.cStandard": "",
+++  "C_Cpp_Runner.cppStandard": "",
+++  "C_Cpp_Runner.msvcBatchPath": "C:/Program Files/Microsoft Visual Studio/VR_NR/Community/VC/Auxiliary/Build/vcvarsall.bat",
+++  "C_Cpp_Runner.useMsvc": false,
+++  "C_Cpp_Runner.warnings": [
+++    "-Wall",
+++    "-Wextra",
+++    "-Wpedantic",
+++    "-Wshadow",
+++    "-Wformat=2",
+++    "-Wcast-align",
+++    "-Wconversion",
+++    "-Wsign-conversion",
+++    "-Wnull-dereference"
+++  ],
+++  "C_Cpp_Runner.msvcWarnings": [
+++    "/W4",
+++    "/permissive-",
+++    "/w14242",
+++    "/w14287",
+++    "/w14296",
+++    "/w14311",
+++    "/w14826",
+++    "/w44062",
+++    "/w44242",
+++    "/w14905",
+++    "/w14906",
+++    "/w14263",
+++    "/w44265",
+++    "/w14928"
+++  ],
+++  "C_Cpp_Runner.enableWarnings": true,
+++  "C_Cpp_Runner.warningsAsError": false,
+++  "C_Cpp_Runner.compilerArgs": [],
+++  "C_Cpp_Runner.linkerArgs": [],
+++  "C_Cpp_Runner.includePaths": [],
+++  "C_Cpp_Runner.includeSearch": [
+++    "*",
+++    "**/*"
+++  ],
+++  "C_Cpp_Runner.excludeSearch": [
+++    "**/build",
+++    "**/build/**",
+++    "**/.*",
+++    "**/.*/**",
+++    "**/.vscode",
+++    "**/.vscode/**"
+++  ],
+++  "C_Cpp_Runner.useAddressSanitizer": false,
+++  "C_Cpp_Runner.useUndefinedSanitizer": false,
+++  "C_Cpp_Runner.useLeakSanitizer": false,
+++  "C_Cpp_Runner.showCompilationTime": false,
+++  "C_Cpp_Runner.useLinkTimeOptimization": false,
+++  "C_Cpp_Runner.msvcSecureNoWarnings": false
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/Makefile b/offline_2/xv6-riscv-riscv/Makefile
++index f8c820e..546ecf9 100644
++--- a/offline_2/xv6-riscv-riscv/Makefile
+++++ b/offline_2/xv6-riscv-riscv/Makefile
++@@ -139,6 +139,8 @@ UPROGS=\
++ 	$U/_grind\
++ 	$U/_wc\
++ 	$U/_zombie\
+++	$U/_history\
+++
++ 
++ fs.img: mkfs/mkfs README $(UPROGS)
++ 	mkfs/mkfs fs.img README $(UPROGS)
++diff --git a/offline_2/xv6-riscv-riscv/kernel/main.c b/offline_2/xv6-riscv-riscv/kernel/main.c
++index f0d3171..d62bd0a 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/main.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/main.c
++@@ -3,43 +3,86 @@
++ #include "memlayout.h"
++ #include "riscv.h"
++ #include "defs.h"
++-
+++#include "syscall.h"
+++#include "syscall_stat.h"
+++#include "spinlock.h"
++ volatile static int started = 0;
++ 
+++// struct syscall_stat syscall_stats[50];
+++
+++const char *syscall_names[] = {
+++    [SYS_fork] "fork",
+++    [SYS_exit] "exit",
+++    [SYS_wait] "wait",
+++    [SYS_pipe] "pipe",
+++    [SYS_read] "read",
+++    [SYS_kill] "kill",
+++    [SYS_exec] "exec",
+++    [SYS_fstat] "fstat",
+++    [SYS_chdir] "chdir",
+++    [SYS_dup] "dup",
+++    [SYS_getpid] "getpid",
+++    [SYS_sbrk] "sbrk",
+++    [SYS_sleep] "sleep",
+++    [SYS_uptime] "uptime",
+++    [SYS_open] "open",
+++    [SYS_write] "write",
+++    [SYS_mknod] "mknod",
+++    [SYS_unlink] "unlink",
+++    [SYS_link] "link",
+++    [SYS_mkdir] "mkdir",
+++    [SYS_close] "close",
+++    [SYS_history] "history",
+++};
++ // start() jumps here in supervisor mode on all CPUs.
++-void
++-main()
+++
+++void initialize_sys_call_stat()
++ {
++-  if(cpuid() == 0){
+++  for (int i = 1; i < NELEM(syscall_names); i++)
+++  {
+++    initlock(&syscall_stats[i].syscall_stat_lock, "syscall_stat_lock");
+++    strncpy(syscall_stats[i].syscall_name, syscall_names[i], sizeof(syscall_stats[i].syscall_name));
+++    syscall_stats[i].count = 0;
+++    syscall_stats[i].accum_time = 0;
+++  }
+++}
+++
+++void main()
+++{
+++  if (cpuid() == 0)
+++  {
++     consoleinit();
++     printfinit();
++     printf("\n");
++     printf("xv6 kernel is booting\n");
++     printf("\n");
++-    kinit();         // physical page allocator
++-    kvminit();       // create kernel page table
++-    kvminithart();   // turn on paging
++-    procinit();      // process table
++-    trapinit();      // trap vectors
++-    trapinithart();  // install kernel trap vector
++-    plicinit();      // set up interrupt controller
++-    plicinithart();  // ask PLIC for device interrupts
++-    binit();         // buffer cache
++-    iinit();         // inode table
++-    fileinit();      // file table
+++    kinit();            // physical page allocator
+++    kvminit();          // create kernel page table
+++    kvminithart();      // turn on paging
+++    procinit();         // process table
+++    trapinit();         // trap vectors
+++    trapinithart();     // install kernel trap vector
+++    plicinit();         // set up interrupt controller
+++    plicinithart();     // ask PLIC for device interrupts
+++    binit();            // buffer cache
+++    iinit();            // inode table
+++    fileinit();         // file table
++     virtio_disk_init(); // emulated hard disk
++-    userinit();      // first user process
+++    initialize_sys_call_stat();
+++    userinit();         // first user process
++     __sync_synchronize();
++     started = 1;
++-  } else {
++-    while(started == 0)
+++  }
+++  else
+++  {
+++    while (started == 0)
++       ;
++     __sync_synchronize();
++     printf("hart %d starting\n", cpuid());
++-    kvminithart();    // turn on paging
++-    trapinithart();   // install kernel trap vector
++-    plicinithart();   // ask PLIC for device interrupts
+++    kvminithart();  // turn on paging
+++    trapinithart(); // install kernel trap vector
+++    plicinithart(); // ask PLIC for device interrupts
++   }
++-
++-  scheduler();        
+++  
+++  scheduler();
++ }
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.c b/offline_2/xv6-riscv-riscv/kernel/syscall.c
++index ed65409..35b9ff0 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.c
++@@ -6,6 +6,7 @@
++ #include "proc.h"
++ #include "syscall.h"
++ #include "defs.h"
+++#include "syscall_stat.h"
++ 
++ // Fetch the uint64 at addr from the current process.
++ int
++@@ -101,7 +102,8 @@ extern uint64 sys_unlink(void);
++ extern uint64 sys_link(void);
++ extern uint64 sys_mkdir(void);
++ extern uint64 sys_close(void);
++-
+++extern uint64 sys_history(void);
+++extern uint ticks;
++ // An array mapping syscall numbers from syscall.h
++ // to the function that handles the system call.
++ static uint64 (*syscalls[])(void) = {
++@@ -126,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
++ [SYS_link]    sys_link,
++ [SYS_mkdir]   sys_mkdir,
++ [SYS_close]   sys_close,
+++[SYS_history] sys_history,
++ };
++ 
++ void
++@@ -133,15 +136,23 @@ syscall(void)
++ {
++   int num;
++   struct proc *p = myproc();
++-
+++  uint start_ticks = ticks;
++   num = p->trapframe->a7;
++   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
++     // Use num to lookup the system call function for num, call it,
++     // and store its return value in p->trapframe->a0
+++
+++    //update the syscall statistics
++     p->trapframe->a0 = syscalls[num]();
++   } else {
++     printf("%d %s: unknown sys call %d\n",
++             p->pid, p->name, num);
++     p->trapframe->a0 = -1;
++   }
+++  uint end_ticks = ticks;
+++  // Update syscall statistics
+++  acquire(&syscall_stats[num].syscall_stat_lock);
+++  syscall_stats[num].count++;
+++  syscall_stats[num].accum_time += (end_ticks - start_ticks);
+++  release(&syscall_stats[num].syscall_stat_lock);
++ }
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.h b/offline_2/xv6-riscv-riscv/kernel/syscall.h
++index bc5f356..3b56b8f 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.h
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.h
++@@ -20,3 +20,4 @@
++ #define SYS_link   19
++ #define SYS_mkdir  20
++ #define SYS_close  21
+++#define SYS_history 22
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
++new file mode 100644
++index 0000000..7066b76
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
++@@ -0,0 +1,10 @@
+++#include "spinlock.h"
+++
+++struct syscall_stat {
+++    char syscall_name[16];
+++    int count;
+++    int accum_time;
+++    struct spinlock syscall_stat_lock;
+++};
+++
+++extern struct syscall_stat syscall_stats[50];
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/kernel/sysproc.c b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++index 3b4d5bd..10b0e2c 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++@@ -5,6 +5,8 @@
++ #include "memlayout.h"
++ #include "spinlock.h"
++ #include "proc.h"
+++#include "syscall.h"
+++#include "syscall_stat.h"
++ 
++ uint64
++ sys_exit(void)
++@@ -12,7 +14,7 @@ sys_exit(void)
++   int n;
++   argint(0, &n);
++   exit(n);
++-  return 0;  // not reached
+++  return 0; // not reached
++ }
++ 
++ uint64
++@@ -43,7 +45,7 @@ sys_sbrk(void)
++ 
++   argint(0, &n);
++   addr = myproc()->sz;
++-  if(growproc(n) < 0)
+++  if (growproc(n) < 0)
++     return -1;
++   return addr;
++ }
++@@ -55,12 +57,14 @@ sys_sleep(void)
++   uint ticks0;
++ 
++   argint(0, &n);
++-  if(n < 0)
+++  if (n < 0)
++     n = 0;
++   acquire(&tickslock);
++   ticks0 = ticks;
++-  while(ticks - ticks0 < n){
++-    if(killed(myproc())){
+++  while (ticks - ticks0 < n)
+++  {
+++    if (killed(myproc()))
+++    {
++       release(&tickslock);
++       return -1;
++     }
++@@ -91,3 +95,37 @@ sys_uptime(void)
++   release(&tickslock);
++   return xticks;
++ }
+++
+++uint64
+++sys_history(void)
+++{
+++  int syscall_num;
+++  uint64 userspace_struct_address;
+++
+++  argint(0, &syscall_num);
+++  argaddr(1, &userspace_struct_address);
+++  if (syscall_num < 0 || syscall_num >= NELEM(syscall_stats))
+++  {
+++    return -1;
+++  }
+++  struct syscall_stat temp_stat;
+++  // acquire lock
+++  acquire(&syscall_stats[syscall_num].syscall_stat_lock);
+++  // temp_stat = syscall_stats[syscall_num];
+++  memmove(&temp_stat, &syscall_stats[syscall_num], sizeof(temp_stat));
+++  release(&syscall_stats[syscall_num].syscall_stat_lock);
+++  // Ensure the syscall name is null-terminated
+++  temp_stat.syscall_name[sizeof(temp_stat.syscall_name) - 1] = '\0';
+++  // Check if the userspace address is valid
+++  if (userspace_struct_address + sizeof(temp_stat) >= MAXVA)
+++  {
+++    return -1;
+++  }
+++  // Copy the syscall statistics to user space
+++  int ret_val = copyout(myproc()->pagetable, userspace_struct_address, (char *)&temp_stat, sizeof(temp_stat));
+++  if (ret_val < 0)
+++  {
+++    return -1;
+++  }
+++  return 0;
+++}
++diff --git a/offline_2/xv6-riscv-riscv/task1.patch b/offline_2/xv6-riscv-riscv/task1.patch
++new file mode 100644
++index 0000000..a65286f
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/task1.patch
++@@ -0,0 +1,4730 @@
+++diff --git a/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
+++new file mode 100644
+++index 0000000..c2098a2
+++--- /dev/null
++++++ b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
+++@@ -0,0 +1,18 @@
++++{
++++  "configurations": [
++++    {
++++      "name": "linux-gcc-x64",
++++      "includePath": [
++++        "${workspaceFolder}/**"
++++      ],
++++      "compilerPath": "/usr/bin/gcc",
++++      "cStandard": "${default}",
++++      "cppStandard": "${default}",
++++      "intelliSenseMode": "linux-gcc-x64",
++++      "compilerArgs": [
++++        ""
++++      ]
++++    }
++++  ],
++++  "version": 4
++++}
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/.vscode/launch.json b/offline_2/xv6-riscv-riscv/.vscode/launch.json
+++new file mode 100644
+++index 0000000..cc00405
+++--- /dev/null
++++++ b/offline_2/xv6-riscv-riscv/.vscode/launch.json
+++@@ -0,0 +1,24 @@
++++{
++++  "version": "0.2.0",
++++  "configurations": [
++++    {
++++      "name": "C/C++ Runner: Debug Session",
++++      "type": "cppdbg",
++++      "request": "launch",
++++      "args": [],
++++      "stopAtEntry": false,
++++      "externalConsole": false,
++++      "cwd": ".",
++++      "program": "build/Debug/outDebug",
++++      "MIMode": "gdb",
++++      "miDebuggerPath": "gdb",
++++      "setupCommands": [
++++        {
++++          "description": "Enable pretty-printing for gdb",
++++          "text": "-enable-pretty-printing",
++++          "ignoreFailures": true
++++        }
++++      ]
++++    }
++++  ]
++++}
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/.vscode/settings.json b/offline_2/xv6-riscv-riscv/.vscode/settings.json
+++new file mode 100644
+++index 0000000..bb879da
+++--- /dev/null
++++++ b/offline_2/xv6-riscv-riscv/.vscode/settings.json
+++@@ -0,0 +1,59 @@
++++{
++++  "C_Cpp_Runner.cCompilerPath": "gcc",
++++  "C_Cpp_Runner.cppCompilerPath": "g++",
++++  "C_Cpp_Runner.debuggerPath": "gdb",
++++  "C_Cpp_Runner.cStandard": "",
++++  "C_Cpp_Runner.cppStandard": "",
++++  "C_Cpp_Runner.msvcBatchPath": "C:/Program Files/Microsoft Visual Studio/VR_NR/Community/VC/Auxiliary/Build/vcvarsall.bat",
++++  "C_Cpp_Runner.useMsvc": false,
++++  "C_Cpp_Runner.warnings": [
++++    "-Wall",
++++    "-Wextra",
++++    "-Wpedantic",
++++    "-Wshadow",
++++    "-Wformat=2",
++++    "-Wcast-align",
++++    "-Wconversion",
++++    "-Wsign-conversion",
++++    "-Wnull-dereference"
++++  ],
++++  "C_Cpp_Runner.msvcWarnings": [
++++    "/W4",
++++    "/permissive-",
++++    "/w14242",
++++    "/w14287",
++++    "/w14296",
++++    "/w14311",
++++    "/w14826",
++++    "/w44062",
++++    "/w44242",
++++    "/w14905",
++++    "/w14906",
++++    "/w14263",
++++    "/w44265",
++++    "/w14928"
++++  ],
++++  "C_Cpp_Runner.enableWarnings": true,
++++  "C_Cpp_Runner.warningsAsError": false,
++++  "C_Cpp_Runner.compilerArgs": [],
++++  "C_Cpp_Runner.linkerArgs": [],
++++  "C_Cpp_Runner.includePaths": [],
++++  "C_Cpp_Runner.includeSearch": [
++++    "*",
++++    "**/*"
++++  ],
++++  "C_Cpp_Runner.excludeSearch": [
++++    "**/build",
++++    "**/build/**",
++++    "**/.*",
++++    "**/.*/**",
++++    "**/.vscode",
++++    "**/.vscode/**"
++++  ],
++++  "C_Cpp_Runner.useAddressSanitizer": false,
++++  "C_Cpp_Runner.useUndefinedSanitizer": false,
++++  "C_Cpp_Runner.useLeakSanitizer": false,
++++  "C_Cpp_Runner.showCompilationTime": false,
++++  "C_Cpp_Runner.useLinkTimeOptimization": false,
++++  "C_Cpp_Runner.msvcSecureNoWarnings": false
++++}
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/Makefile b/offline_2/xv6-riscv-riscv/Makefile
+++index f8c820e..546ecf9 100644
+++--- a/offline_2/xv6-riscv-riscv/Makefile
++++++ b/offline_2/xv6-riscv-riscv/Makefile
+++@@ -139,6 +139,8 @@ UPROGS=\
+++ 	$U/_grind\
+++ 	$U/_wc\
+++ 	$U/_zombie\
++++	$U/_history\
++++
+++ 
+++ fs.img: mkfs/mkfs README $(UPROGS)
+++ 	mkfs/mkfs fs.img README $(UPROGS)
+++diff --git a/offline_2/xv6-riscv-riscv/kernel/main.c b/offline_2/xv6-riscv-riscv/kernel/main.c
+++index f0d3171..d62bd0a 100644
+++--- a/offline_2/xv6-riscv-riscv/kernel/main.c
++++++ b/offline_2/xv6-riscv-riscv/kernel/main.c
+++@@ -3,43 +3,86 @@
+++ #include "memlayout.h"
+++ #include "riscv.h"
+++ #include "defs.h"
+++-
++++#include "syscall.h"
++++#include "syscall_stat.h"
++++#include "spinlock.h"
+++ volatile static int started = 0;
+++ 
++++// struct syscall_stat syscall_stats[50];
++++
++++const char *syscall_names[] = {
++++    [SYS_fork] "fork",
++++    [SYS_exit] "exit",
++++    [SYS_wait] "wait",
++++    [SYS_pipe] "pipe",
++++    [SYS_read] "read",
++++    [SYS_kill] "kill",
++++    [SYS_exec] "exec",
++++    [SYS_fstat] "fstat",
++++    [SYS_chdir] "chdir",
++++    [SYS_dup] "dup",
++++    [SYS_getpid] "getpid",
++++    [SYS_sbrk] "sbrk",
++++    [SYS_sleep] "sleep",
++++    [SYS_uptime] "uptime",
++++    [SYS_open] "open",
++++    [SYS_write] "write",
++++    [SYS_mknod] "mknod",
++++    [SYS_unlink] "unlink",
++++    [SYS_link] "link",
++++    [SYS_mkdir] "mkdir",
++++    [SYS_close] "close",
++++    [SYS_history] "history",
++++};
+++ // start() jumps here in supervisor mode on all CPUs.
+++-void
+++-main()
++++
++++void initialize_sys_call_stat()
+++ {
+++-  if(cpuid() == 0){
++++  for (int i = 1; i < NELEM(syscall_names); i++)
++++  {
++++    initlock(&syscall_stats[i].syscall_stat_lock, "syscall_stat_lock");
++++    strncpy(syscall_stats[i].syscall_name, syscall_names[i], sizeof(syscall_stats[i].syscall_name));
++++    syscall_stats[i].count = 0;
++++    syscall_stats[i].accum_time = 0;
++++  }
++++}
++++
++++void main()
++++{
++++  if (cpuid() == 0)
++++  {
+++     consoleinit();
+++     printfinit();
+++     printf("\n");
+++     printf("xv6 kernel is booting\n");
+++     printf("\n");
+++-    kinit();         // physical page allocator
+++-    kvminit();       // create kernel page table
+++-    kvminithart();   // turn on paging
+++-    procinit();      // process table
+++-    trapinit();      // trap vectors
+++-    trapinithart();  // install kernel trap vector
+++-    plicinit();      // set up interrupt controller
+++-    plicinithart();  // ask PLIC for device interrupts
+++-    binit();         // buffer cache
+++-    iinit();         // inode table
+++-    fileinit();      // file table
++++    kinit();            // physical page allocator
++++    kvminit();          // create kernel page table
++++    kvminithart();      // turn on paging
++++    procinit();         // process table
++++    trapinit();         // trap vectors
++++    trapinithart();     // install kernel trap vector
++++    plicinit();         // set up interrupt controller
++++    plicinithart();     // ask PLIC for device interrupts
++++    binit();            // buffer cache
++++    iinit();            // inode table
++++    fileinit();         // file table
+++     virtio_disk_init(); // emulated hard disk
+++-    userinit();      // first user process
++++    initialize_sys_call_stat();
++++    userinit();         // first user process
+++     __sync_synchronize();
+++     started = 1;
+++-  } else {
+++-    while(started == 0)
++++  }
++++  else
++++  {
++++    while (started == 0)
+++       ;
+++     __sync_synchronize();
+++     printf("hart %d starting\n", cpuid());
+++-    kvminithart();    // turn on paging
+++-    trapinithart();   // install kernel trap vector
+++-    plicinithart();   // ask PLIC for device interrupts
++++    kvminithart();  // turn on paging
++++    trapinithart(); // install kernel trap vector
++++    plicinithart(); // ask PLIC for device interrupts
+++   }
+++-
+++-  scheduler();        
++++  
++++  scheduler();
+++ }
+++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.c b/offline_2/xv6-riscv-riscv/kernel/syscall.c
+++index ed65409..35b9ff0 100644
+++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.c
++++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.c
+++@@ -6,6 +6,7 @@
+++ #include "proc.h"
+++ #include "syscall.h"
+++ #include "defs.h"
++++#include "syscall_stat.h"
+++ 
+++ // Fetch the uint64 at addr from the current process.
+++ int
+++@@ -101,7 +102,8 @@ extern uint64 sys_unlink(void);
+++ extern uint64 sys_link(void);
+++ extern uint64 sys_mkdir(void);
+++ extern uint64 sys_close(void);
+++-
++++extern uint64 sys_history(void);
++++extern uint ticks;
+++ // An array mapping syscall numbers from syscall.h
+++ // to the function that handles the system call.
+++ static uint64 (*syscalls[])(void) = {
+++@@ -126,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
+++ [SYS_link]    sys_link,
+++ [SYS_mkdir]   sys_mkdir,
+++ [SYS_close]   sys_close,
++++[SYS_history] sys_history,
+++ };
+++ 
+++ void
+++@@ -133,15 +136,23 @@ syscall(void)
+++ {
+++   int num;
+++   struct proc *p = myproc();
+++-
++++  uint start_ticks = ticks;
+++   num = p->trapframe->a7;
+++   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+++     // Use num to lookup the system call function for num, call it,
+++     // and store its return value in p->trapframe->a0
++++
++++    //update the syscall statistics
+++     p->trapframe->a0 = syscalls[num]();
+++   } else {
+++     printf("%d %s: unknown sys call %d\n",
+++             p->pid, p->name, num);
+++     p->trapframe->a0 = -1;
+++   }
++++  uint end_ticks = ticks;
++++  // Update syscall statistics
++++  acquire(&syscall_stats[num].syscall_stat_lock);
++++  syscall_stats[num].count++;
++++  syscall_stats[num].accum_time += (end_ticks - start_ticks);
++++  release(&syscall_stats[num].syscall_stat_lock);
+++ }
+++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.h b/offline_2/xv6-riscv-riscv/kernel/syscall.h
+++index bc5f356..3b56b8f 100644
+++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.h
++++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.h
+++@@ -20,3 +20,4 @@
+++ #define SYS_link   19
+++ #define SYS_mkdir  20
+++ #define SYS_close  21
++++#define SYS_history 22
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
+++new file mode 100644
+++index 0000000..7066b76
+++--- /dev/null
++++++ b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
+++@@ -0,0 +1,10 @@
++++#include "spinlock.h"
++++
++++struct syscall_stat {
++++    char syscall_name[16];
++++    int count;
++++    int accum_time;
++++    struct spinlock syscall_stat_lock;
++++};
++++
++++extern struct syscall_stat syscall_stats[50];
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/kernel/sysproc.c b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+++index 3b4d5bd..10b0e2c 100644
+++--- a/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++++++ b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+++@@ -5,6 +5,8 @@
+++ #include "memlayout.h"
+++ #include "spinlock.h"
+++ #include "proc.h"
++++#include "syscall.h"
++++#include "syscall_stat.h"
+++ 
+++ uint64
+++ sys_exit(void)
+++@@ -12,7 +14,7 @@ sys_exit(void)
+++   int n;
+++   argint(0, &n);
+++   exit(n);
+++-  return 0;  // not reached
++++  return 0; // not reached
+++ }
+++ 
+++ uint64
+++@@ -43,7 +45,7 @@ sys_sbrk(void)
+++ 
+++   argint(0, &n);
+++   addr = myproc()->sz;
+++-  if(growproc(n) < 0)
++++  if (growproc(n) < 0)
+++     return -1;
+++   return addr;
+++ }
+++@@ -55,12 +57,14 @@ sys_sleep(void)
+++   uint ticks0;
+++ 
+++   argint(0, &n);
+++-  if(n < 0)
++++  if (n < 0)
+++     n = 0;
+++   acquire(&tickslock);
+++   ticks0 = ticks;
+++-  while(ticks - ticks0 < n){
+++-    if(killed(myproc())){
++++  while (ticks - ticks0 < n)
++++  {
++++    if (killed(myproc()))
++++    {
+++       release(&tickslock);
+++       return -1;
+++     }
+++@@ -91,3 +95,37 @@ sys_uptime(void)
+++   release(&tickslock);
+++   return xticks;
+++ }
++++
++++uint64
++++sys_history(void)
++++{
++++  int syscall_num;
++++  uint64 userspace_struct_address;
++++
++++  argint(0, &syscall_num);
++++  argaddr(1, &userspace_struct_address);
++++  if (syscall_num < 0 || syscall_num >= NELEM(syscall_stats))
++++  {
++++    return -1;
++++  }
++++  struct syscall_stat temp_stat;
++++  // acquire lock
++++  acquire(&syscall_stats[syscall_num].syscall_stat_lock);
++++  // temp_stat = syscall_stats[syscall_num];
++++  memmove(&temp_stat, &syscall_stats[syscall_num], sizeof(temp_stat));
++++  release(&syscall_stats[syscall_num].syscall_stat_lock);
++++  // Ensure the syscall name is null-terminated
++++  temp_stat.syscall_name[sizeof(temp_stat.syscall_name) - 1] = '\0';
++++  // Check if the userspace address is valid
++++  if (userspace_struct_address + sizeof(temp_stat) >= MAXVA)
++++  {
++++    return -1;
++++  }
++++  // Copy the syscall statistics to user space
++++  int ret_val = copyout(myproc()->pagetable, userspace_struct_address, (char *)&temp_stat, sizeof(temp_stat));
++++  if (ret_val < 0)
++++  {
++++    return -1;
++++  }
++++  return 0;
++++}
+++diff --git a/offline_2/xv6-riscv-riscv/user/history.c b/offline_2/xv6-riscv-riscv/user/history.c
+++new file mode 100644
+++index 0000000..54e980a
+++--- /dev/null
++++++ b/offline_2/xv6-riscv-riscv/user/history.c
+++@@ -0,0 +1,47 @@
++++#include "kernel/types.h"
++++#include "kernel/stat.h"
++++#include "user/user.h"
++++#include "kernel/syscall.h"
++++#include "kernel/syscall_stat.h"
++++
++++void print_history(int syscall_num)
++++{
++++    struct syscall_stat s_stat;
++++
++++    if (history(syscall_num, &s_stat) == 0)
++++    {
++++        printf("%d: syscall: %s, #: %d, time: %d\n",
++++               syscall_num,
++++               s_stat.syscall_name,
++++               s_stat.count,
++++               s_stat.accum_time);
++++    }
++++    else
++++    {
++++        printf("Error fetching history for syscall %d\n", syscall_num);
++++    }
++++}
++++
++++int main(int argc, char *argv[])
++++{
++++    if (argc < 2)
++++    {
++++        // No arguments, print all
++++        for (int i = 1; i <= 24; i++)
++++            print_history(i);
++++    }
++++    else
++++    {
++++        int syscall_num = atoi(argv[1]);
++++        if (syscall_num > 0)
++++        {
++++            print_history(syscall_num);
++++        }
++++        else
++++        {
++++            printf("Invalid syscall number.\n");
++++        }
++++    }
++++
++++    exit(0);
++++}
+++\ No newline at end of file
+++diff --git a/offline_2/xv6-riscv-riscv/user/user.h b/offline_2/xv6-riscv-riscv/user/user.h
+++index f16fe27..1cb3ac8 100644
+++--- a/offline_2/xv6-riscv-riscv/user/user.h
++++++ b/offline_2/xv6-riscv-riscv/user/user.h
+++@@ -1,5 +1,5 @@
+++ struct stat;
+++-
++++struct syscall_stat;
+++ // system calls
+++ int fork(void);
+++ int exit(int) __attribute__((noreturn));
+++@@ -22,6 +22,7 @@ int getpid(void);
+++ char* sbrk(int);
+++ int sleep(int);
+++ int uptime(void);
++++int history(int, struct syscall_stat*);
+++ 
+++ // ulib.c
+++ int stat(const char*, struct stat*);
+++diff --git a/offline_2/xv6-riscv-riscv/user/usertests.c b/offline_2/xv6-riscv-riscv/user/usertests.c
+++index 28b53f9..4273164 100644
+++--- a/offline_2/xv6-riscv-riscv/user/usertests.c
++++++ b/offline_2/xv6-riscv-riscv/user/usertests.c
+++@@ -17,7 +17,7 @@
+++ // prints "OK".
+++ //
+++ 
+++-#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
++++#define BUFSZ ((MAXOPBLOCKS + 2) * BSIZE)
+++ 
+++ char buf[BUFSZ];
+++ 
+++@@ -29,42 +29,47 @@ char buf[BUFSZ];
+++ 
+++ // what if you pass ridiculous pointers to system calls
+++ // that read user memory with copyin?
+++-void
+++-copyin(char *s)
++++void copyin(char *s)
+++ {
+++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++-                     0xffffffffffffffff };
++++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++++                    0xffffffffffffffff};
+++ 
+++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++++  {
+++     uint64 addr = addrs[ai];
+++-    
+++-    int fd = open("copyin1", O_CREATE|O_WRONLY);
+++-    if(fd < 0){
++++
++++    int fd = open("copyin1", O_CREATE | O_WRONLY);
++++    if (fd < 0)
++++    {
+++       printf("open(copyin1) failed\n");
+++       exit(1);
+++     }
+++-    int n = write(fd, (void*)addr, 8192);
+++-    if(n >= 0){
+++-      printf("write(fd, %p, 8192) returned %d, not -1\n", (void*)addr, n);
++++    int n = write(fd, (void *)addr, 8192);
++++    if (n >= 0)
++++    {
++++      printf("write(fd, %p, 8192) returned %d, not -1\n", (void *)addr, n);
+++       exit(1);
+++     }
+++     close(fd);
+++     unlink("copyin1");
+++-    
+++-    n = write(1, (char*)addr, 8192);
+++-    if(n > 0){
+++-      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++++
++++    n = write(1, (char *)addr, 8192);
++++    if (n > 0)
++++    {
++++      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+++       exit(1);
+++     }
+++-    
++++
+++     int fds[2];
+++-    if(pipe(fds) < 0){
++++    if (pipe(fds) < 0)
++++    {
+++       printf("pipe() failed\n");
+++       exit(1);
+++     }
+++-    n = write(fds[1], (char*)addr, 8192);
+++-    if(n > 0){
+++-      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++++    n = write(fds[1], (char *)addr, 8192);
++++    if (n > 0)
++++    {
++++      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+++       exit(1);
+++     }
+++     close(fds[0]);
+++@@ -74,40 +79,45 @@ copyin(char *s)
+++ 
+++ // what if you pass ridiculous pointers to system calls
+++ // that write user memory with copyout?
+++-void
+++-copyout(char *s)
++++void copyout(char *s)
+++ {
+++-  uint64 addrs[] = { 0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++-                     0xffffffffffffffff };
++++  uint64 addrs[] = {0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++++                    0xffffffffffffffff};
+++ 
+++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++++  {
+++     uint64 addr = addrs[ai];
+++ 
+++     int fd = open("README", 0);
+++-    if(fd < 0){
++++    if (fd < 0)
++++    {
+++       printf("open(README) failed\n");
+++       exit(1);
+++     }
+++-    int n = read(fd, (void*)addr, 8192);
+++-    if(n > 0){
+++-      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++++    int n = read(fd, (void *)addr, 8192);
++++    if (n > 0)
++++    {
++++      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+++       exit(1);
+++     }
+++     close(fd);
+++ 
+++     int fds[2];
+++-    if(pipe(fds) < 0){
++++    if (pipe(fds) < 0)
++++    {
+++       printf("pipe() failed\n");
+++       exit(1);
+++     }
+++     n = write(fds[1], "x", 1);
+++-    if(n != 1){
++++    if (n != 1)
++++    {
+++       printf("pipe write failed\n");
+++       exit(1);
+++     }
+++-    n = read(fds[0], (void*)addr, 8192);
+++-    if(n > 0){
+++-      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++++    n = read(fds[0], (void *)addr, 8192);
++++    if (n > 0)
++++    {
++++      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+++       exit(1);
+++     }
+++     close(fds[0]);
+++@@ -116,18 +126,19 @@ copyout(char *s)
+++ }
+++ 
+++ // what if you pass ridiculous string pointers to system calls?
+++-void
+++-copyinstr1(char *s)
++++void copyinstr1(char *s)
+++ {
+++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++-                     0xffffffffffffffff };
++++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++++                    0xffffffffffffffff};
+++ 
+++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++++  {
+++     uint64 addr = addrs[ai];
+++ 
+++-    int fd = open((char *)addr, O_CREATE|O_WRONLY);
+++-    if(fd >= 0){
+++-      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
++++    int fd = open((char *)addr, O_CREATE | O_WRONLY);
++++    if (fd >= 0)
++++    {
++++      printf("open(%p) returned %d, not -1\n", (void *)addr, fd);
+++       exit(1);
+++     }
+++   }
+++@@ -136,53 +147,59 @@ copyinstr1(char *s)
+++ // what if a string system call argument is exactly the size
+++ // of the kernel buffer it is copied into, so that the null
+++ // would fall just beyond the end of the kernel buffer?
+++-void
+++-copyinstr2(char *s)
++++void copyinstr2(char *s)
+++ {
+++-  char b[MAXPATH+1];
++++  char b[MAXPATH + 1];
+++ 
+++-  for(int i = 0; i < MAXPATH; i++)
++++  for (int i = 0; i < MAXPATH; i++)
+++     b[i] = 'x';
+++   b[MAXPATH] = '\0';
+++-  
++++
+++   int ret = unlink(b);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("unlink(%s) returned %d, not -1\n", b, ret);
+++     exit(1);
+++   }
+++ 
+++   int fd = open(b, O_CREATE | O_WRONLY);
+++-  if(fd != -1){
++++  if (fd != -1)
++++  {
+++     printf("open(%s) returned %d, not -1\n", b, fd);
+++     exit(1);
+++   }
+++ 
+++   ret = link(b, b);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+++     exit(1);
+++   }
+++ 
+++-  char *args[] = { "xx", 0 };
++++  char *args[] = {"xx", 0};
+++   ret = exec(b, args);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("exec(%s) returned %d, not -1\n", b, fd);
+++     exit(1);
+++   }
+++ 
+++   int pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed\n");
+++     exit(1);
+++   }
+++-  if(pid == 0){
+++-    static char big[PGSIZE+1];
+++-    for(int i = 0; i < PGSIZE; i++)
++++  if (pid == 0)
++++  {
++++    static char big[PGSIZE + 1];
++++    for (int i = 0; i < PGSIZE; i++)
+++       big[i] = 'x';
+++     big[PGSIZE] = '\0';
+++-    char *args2[] = { big, big, big, 0 };
++++    char *args2[] = {big, big, big, 0};
+++     ret = exec("echo", args2);
+++-    if(ret != -1){
++++    if (ret != -1)
++++    {
+++       printf("exec(echo, BIG) returned %d, not -1\n", fd);
+++       exit(1);
+++     }
+++@@ -191,51 +208,57 @@ copyinstr2(char *s)
+++ 
+++   int st = 0;
+++   wait(&st);
+++-  if(st != 747){
++++  if (st != 747)
++++  {
+++     printf("exec(echo, BIG) succeeded, should have failed\n");
+++     exit(1);
+++   }
+++ }
+++ 
+++ // what if a string argument crosses over the end of last user page?
+++-void
+++-copyinstr3(char *s)
++++void copyinstr3(char *s)
+++ {
+++   sbrk(8192);
+++-  uint64 top = (uint64) sbrk(0);
+++-  if((top % PGSIZE) != 0){
++++  uint64 top = (uint64)sbrk(0);
++++  if ((top % PGSIZE) != 0)
++++  {
+++     sbrk(PGSIZE - (top % PGSIZE));
+++   }
+++-  top = (uint64) sbrk(0);
+++-  if(top % PGSIZE){
++++  top = (uint64)sbrk(0);
++++  if (top % PGSIZE)
++++  {
+++     printf("oops\n");
+++     exit(1);
+++   }
+++ 
+++-  char *b = (char *) (top - 1);
++++  char *b = (char *)(top - 1);
+++   *b = 'x';
+++ 
+++   int ret = unlink(b);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("unlink(%s) returned %d, not -1\n", b, ret);
+++     exit(1);
+++   }
+++ 
+++   int fd = open(b, O_CREATE | O_WRONLY);
+++-  if(fd != -1){
++++  if (fd != -1)
++++  {
+++     printf("open(%s) returned %d, not -1\n", b, fd);
+++     exit(1);
+++   }
+++ 
+++   ret = link(b, b);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+++     exit(1);
+++   }
+++ 
+++-  char *args[] = { "xx", 0 };
++++  char *args[] = {"xx", 0};
+++   ret = exec(b, args);
+++-  if(ret != -1){
++++  if (ret != -1)
++++  {
+++     printf("exec(%s) returned %d, not -1\n", b, fd);
+++     exit(1);
+++   }
+++@@ -243,96 +266,105 @@ copyinstr3(char *s)
+++ 
+++ // See if the kernel refuses to read/write user memory that the
+++ // application doesn't have anymore, because it returned it.
+++-void
+++-rwsbrk()
++++void rwsbrk(char *)
+++ {
+++   int fd, n;
+++-  
+++-  uint64 a = (uint64) sbrk(8192);
+++ 
+++-  if(a == 0xffffffffffffffffLL) {
++++  uint64 a = (uint64)sbrk(8192);
++++
++++  if (a == 0xffffffffffffffffLL)
++++  {
+++     printf("sbrk(rwsbrk) failed\n");
+++     exit(1);
+++   }
+++-  
+++-  if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
++++
++++  if ((uint64)sbrk(-8192) == 0xffffffffffffffffLL)
++++  {
+++     printf("sbrk(rwsbrk) shrink failed\n");
+++     exit(1);
+++   }
+++ 
+++-  fd = open("rwsbrk", O_CREATE|O_WRONLY);
+++-  if(fd < 0){
++++  fd = open("rwsbrk", O_CREATE | O_WRONLY);
++++  if (fd < 0)
++++  {
+++     printf("open(rwsbrk) failed\n");
+++     exit(1);
+++   }
+++-  n = write(fd, (void*)(a+4096), 1024);
+++-  if(n >= 0){
+++-    printf("write(fd, %p, 1024) returned %d, not -1\n", (void*)a+4096, n);
++++  n = write(fd, (void *)(a + 4096), 1024);
++++  if (n >= 0)
++++  {
++++    printf("write(fd, %p, 1024) returned %d, not -1\n", (void *)a + 4096, n);
+++     exit(1);
+++   }
+++   close(fd);
+++   unlink("rwsbrk");
+++ 
+++   fd = open("README", O_RDONLY);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("open(rwsbrk) failed\n");
+++     exit(1);
+++   }
+++-  n = read(fd, (void*)(a+4096), 10);
+++-  if(n >= 0){
+++-    printf("read(fd, %p, 10) returned %d, not -1\n", (void*)a+4096, n);
++++  n = read(fd, (void *)(a + 4096), 10);
++++  if (n >= 0)
++++  {
++++    printf("read(fd, %p, 10) returned %d, not -1\n", (void *)a + 4096, n);
+++     exit(1);
+++   }
+++   close(fd);
+++-  
++++
+++   exit(0);
+++ }
+++ 
+++ // test O_TRUNC.
+++-void
+++-truncate1(char *s)
++++void truncate1(char *s)
+++ {
+++   char buf[32];
+++-  
++++
+++   unlink("truncfile");
+++-  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
++++  int fd1 = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
+++   write(fd1, "abcd", 4);
+++   close(fd1);
+++ 
+++   int fd2 = open("truncfile", O_RDONLY);
+++   int n = read(fd2, buf, sizeof(buf));
+++-  if(n != 4){
++++  if (n != 4)
++++  {
+++     printf("%s: read %d bytes, wanted 4\n", s, n);
+++     exit(1);
+++   }
+++ 
+++-  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
++++  fd1 = open("truncfile", O_WRONLY | O_TRUNC);
+++ 
+++   int fd3 = open("truncfile", O_RDONLY);
+++   n = read(fd3, buf, sizeof(buf));
+++-  if(n != 0){
++++  if (n != 0)
++++  {
+++     printf("aaa fd3=%d\n", fd3);
+++     printf("%s: read %d bytes, wanted 0\n", s, n);
+++     exit(1);
+++   }
+++ 
+++   n = read(fd2, buf, sizeof(buf));
+++-  if(n != 0){
++++  if (n != 0)
++++  {
+++     printf("bbb fd2=%d\n", fd2);
+++     printf("%s: read %d bytes, wanted 0\n", s, n);
+++     exit(1);
+++   }
+++-  
++++
+++   write(fd1, "abcdef", 6);
+++ 
+++   n = read(fd3, buf, sizeof(buf));
+++-  if(n != 6){
++++  if (n != 6)
++++  {
+++     printf("%s: read %d bytes, wanted 6\n", s, n);
+++     exit(1);
+++   }
+++ 
+++   n = read(fd2, buf, sizeof(buf));
+++-  if(n != 2){
++++  if (n != 2)
++++  {
+++     printf("%s: read %d bytes, wanted 2\n", s, n);
+++     exit(1);
+++   }
+++@@ -348,18 +380,18 @@ truncate1(char *s)
+++ // this causes a write at an offset beyond the end of the file.
+++ // such writes fail on xv6 (unlike POSIX) but at least
+++ // they don't crash.
+++-void
+++-truncate2(char *s)
++++void truncate2(char *s)
+++ {
+++   unlink("truncfile");
+++ 
+++-  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
++++  int fd1 = open("truncfile", O_CREATE | O_TRUNC | O_WRONLY);
+++   write(fd1, "abcd", 4);
+++ 
+++-  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
++++  int fd2 = open("truncfile", O_TRUNC | O_WRONLY);
+++ 
+++   int n = write(fd1, "x", 1);
+++-  if(n != -1){
++++  if (n != -1)
++++  {
+++     printf("%s: write returned %d, expected -1\n", s, n);
+++     exit(1);
+++   }
+++@@ -369,29 +401,33 @@ truncate2(char *s)
+++   close(fd2);
+++ }
+++ 
+++-void
+++-truncate3(char *s)
++++void truncate3(char *s)
+++ {
+++   int pid, xstatus;
+++ 
+++-  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
+++-  
++++  close(open("truncfile", O_CREATE | O_TRUNC | O_WRONLY));
++++
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(pid == 0){
+++-    for(int i = 0; i < 100; i++){
++++  if (pid == 0)
++++  {
++++    for (int i = 0; i < 100; i++)
++++    {
+++       char buf[32];
+++       int fd = open("truncfile", O_WRONLY);
+++-      if(fd < 0){
++++      if (fd < 0)
++++      {
+++         printf("%s: open failed\n", s);
+++         exit(1);
+++       }
+++       int n = write(fd, "1234567890", 10);
+++-      if(n != 10){
++++      if (n != 10)
++++      {
+++         printf("%s: write got %d, expected 10\n", s, n);
+++         exit(1);
+++       }
+++@@ -403,14 +439,17 @@ truncate3(char *s)
+++     exit(0);
+++   }
+++ 
+++-  for(int i = 0; i < 150; i++){
+++-    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+++-    if(fd < 0){
++++  for (int i = 0; i < 150; i++)
++++  {
++++    int fd = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
++++    if (fd < 0)
++++    {
+++       printf("%s: open failed\n", s);
+++       exit(1);
+++     }
+++     int n = write(fd, "xxx", 3);
+++-    if(n != 3){
++++    if (n != 3)
++++    {
+++       printf("%s: write got %d, expected 3\n", s, n);
+++       exit(1);
+++     }
+++@@ -421,51 +460,57 @@ truncate3(char *s)
+++   unlink("truncfile");
+++   exit(xstatus);
+++ }
+++-  
+++ 
+++ // does chdir() call iput(p->cwd) in a transaction?
+++-void
+++-iputtest(char *s)
++++void iputtest(char *s)
+++ {
+++-  if(mkdir("iputdir") < 0){
++++  if (mkdir("iputdir") < 0)
++++  {
+++     printf("%s: mkdir failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("iputdir") < 0){
++++  if (chdir("iputdir") < 0)
++++  {
+++     printf("%s: chdir iputdir failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("../iputdir") < 0){
++++  if (unlink("../iputdir") < 0)
++++  {
+++     printf("%s: unlink ../iputdir failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("/") < 0){
++++  if (chdir("/") < 0)
++++  {
+++     printf("%s: chdir / failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++ // does exit() call iput(p->cwd) in a transaction?
+++-void
+++-exitiputtest(char *s)
++++void exitiputtest(char *s)
+++ {
+++   int pid, xstatus;
+++ 
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++-  if(pid == 0){
+++-    if(mkdir("iputdir") < 0){
++++  if (pid == 0)
++++  {
++++    if (mkdir("iputdir") < 0)
++++    {
+++       printf("%s: mkdir failed\n", s);
+++       exit(1);
+++     }
+++-    if(chdir("iputdir") < 0){
++++    if (chdir("iputdir") < 0)
++++    {
+++       printf("%s: child chdir failed\n", s);
+++       exit(1);
+++     }
+++-    if(unlink("../iputdir") < 0){
++++    if (unlink("../iputdir") < 0)
++++    {
+++       printf("%s: unlink ../iputdir failed\n", s);
+++       exit(1);
+++     }
+++@@ -486,30 +531,34 @@ exitiputtest(char *s)
+++ //      for(i = 0; i < 10000; i++)
+++ //        yield();
+++ //    }
+++-void
+++-openiputtest(char *s)
++++void openiputtest(char *s)
+++ {
+++   int pid, xstatus;
+++ 
+++-  if(mkdir("oidir") < 0){
++++  if (mkdir("oidir") < 0)
++++  {
+++     printf("%s: mkdir oidir failed\n", s);
+++     exit(1);
+++   }
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     int fd = open("oidir", O_RDWR);
+++-    if(fd >= 0){
++++    if (fd >= 0)
++++    {
+++       printf("%s: open directory for write succeeded\n", s);
+++       exit(1);
+++     }
+++     exit(0);
+++   }
+++   sleep(1);
+++-  if(unlink("oidir") != 0){
++++  if (unlink("oidir") != 0)
++++  {
+++     printf("%s: unlink failed\n", s);
+++     exit(1);
+++   }
+++@@ -519,79 +568,92 @@ openiputtest(char *s)
+++ 
+++ // simple file system tests
+++ 
+++-void
+++-opentest(char *s)
++++void opentest(char *s)
+++ {
+++   int fd;
+++ 
+++   fd = open("echo", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open echo failed!\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++   fd = open("doesnotexist", 0);
+++-  if(fd >= 0){
++++  if (fd >= 0)
++++  {
+++     printf("%s: open doesnotexist succeeded!\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-void
+++-writetest(char *s)
++++void writetest(char *s)
+++ {
+++   int fd;
+++   int i;
+++-  enum { N=100, SZ=10 };
+++-  
+++-  fd = open("small", O_CREATE|O_RDWR);
+++-  if(fd < 0){
++++  enum
++++  {
++++    N = 100,
++++    SZ = 10
++++  };
++++
++++  fd = open("small", O_CREATE | O_RDWR);
++++  if (fd < 0)
++++  {
+++     printf("%s: error: creat small failed!\n", s);
+++     exit(1);
+++   }
+++-  for(i = 0; i < N; i++){
+++-    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
++++  for (i = 0; i < N; i++)
++++  {
++++    if (write(fd, "aaaaaaaaaa", SZ) != SZ)
++++    {
+++       printf("%s: error: write aa %d new file failed\n", s, i);
+++       exit(1);
+++     }
+++-    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
++++    if (write(fd, "bbbbbbbbbb", SZ) != SZ)
++++    {
+++       printf("%s: error: write bb %d new file failed\n", s, i);
+++       exit(1);
+++     }
+++   }
+++   close(fd);
+++   fd = open("small", O_RDONLY);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: error: open small failed!\n", s);
+++     exit(1);
+++   }
+++-  i = read(fd, buf, N*SZ*2);
+++-  if(i != N*SZ*2){
++++  i = read(fd, buf, N * SZ * 2);
++++  if (i != N * SZ * 2)
++++  {
+++     printf("%s: read failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(unlink("small") < 0){
++++  if (unlink("small") < 0)
++++  {
+++     printf("%s: unlink small failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-void
+++-writebig(char *s)
++++void writebig(char *s)
+++ {
+++   int i, fd, n;
+++ 
+++-  fd = open("big", O_CREATE|O_RDWR);
+++-  if(fd < 0){
++++  fd = open("big", O_CREATE | O_RDWR);
++++  if (fd < 0)
++++  {
+++     printf("%s: error: creat big failed!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  for(i = 0; i < MAXFILE; i++){
+++-    ((int*)buf)[0] = i;
+++-    if(write(fd, buf, BSIZE) != BSIZE){
++++  for (i = 0; i < MAXFILE; i++)
++++  {
++++    ((int *)buf)[0] = i;
++++    if (write(fd, buf, BSIZE) != BSIZE)
++++    {
+++       printf("%s: error: write big file failed i=%d\n", s, i);
+++       exit(1);
+++     }
+++@@ -600,56 +662,68 @@ writebig(char *s)
+++   close(fd);
+++ 
+++   fd = open("big", O_RDONLY);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: error: open big failed!\n", s);
+++     exit(1);
+++   }
+++ 
+++   n = 0;
+++-  for(;;){
++++  for (;;)
++++  {
+++     i = read(fd, buf, BSIZE);
+++-    if(i == 0){
+++-      if(n != MAXFILE){
++++    if (i == 0)
++++    {
++++      if (n != MAXFILE)
++++      {
+++         printf("%s: read only %d blocks from big", s, n);
+++         exit(1);
+++       }
+++       break;
+++-    } else if(i != BSIZE){
++++    }
++++    else if (i != BSIZE)
++++    {
+++       printf("%s: read failed %d\n", s, i);
+++       exit(1);
+++     }
+++-    if(((int*)buf)[0] != n){
++++    if (((int *)buf)[0] != n)
++++    {
+++       printf("%s: read content of block %d is %d\n", s,
+++-             n, ((int*)buf)[0]);
++++             n, ((int *)buf)[0]);
+++       exit(1);
+++     }
+++     n++;
+++   }
+++   close(fd);
+++-  if(unlink("big") < 0){
++++  if (unlink("big") < 0)
++++  {
+++     printf("%s: unlink big failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++ // many creates, followed by unlink test
+++-void
+++-createtest(char *s)
++++void createtest(char *s)
+++ {
+++   int i, fd;
+++-  enum { N=52 };
++++  enum
++++  {
++++    N = 52
++++  };
+++ 
+++   char name[3];
+++   name[0] = 'a';
+++   name[2] = '\0';
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     name[1] = '0' + i;
+++-    fd = open(name, O_CREATE|O_RDWR);
++++    fd = open(name, O_CREATE | O_RDWR);
+++     close(fd);
+++   }
+++   name[0] = 'a';
+++   name[2] = '\0';
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     name[1] = '0' + i;
+++     unlink(name);
+++   }
+++@@ -657,152 +731,180 @@ createtest(char *s)
+++ 
+++ void dirtest(char *s)
+++ {
+++-  if(mkdir("dir0") < 0){
++++  if (mkdir("dir0") < 0)
++++  {
+++     printf("%s: mkdir failed\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(chdir("dir0") < 0){
++++  if (chdir("dir0") < 0)
++++  {
+++     printf("%s: chdir dir0 failed\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(chdir("..") < 0){
++++  if (chdir("..") < 0)
++++  {
+++     printf("%s: chdir .. failed\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(unlink("dir0") < 0){
++++  if (unlink("dir0") < 0)
++++  {
+++     printf("%s: unlink dir0 failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-void
+++-exectest(char *s)
++++void exectest(char *s)
+++ {
+++   int fd, xstatus, pid;
+++-  char *echoargv[] = { "echo", "OK", 0 };
++++  char *echoargv[] = {"echo", "OK", 0};
+++   char buf[3];
+++ 
+++   unlink("echo-ok");
+++   pid = fork();
+++-  if(pid < 0) {
+++-     printf("%s: fork failed\n", s);
+++-     exit(1);
++++  if (pid < 0)
++++  {
++++    printf("%s: fork failed\n", s);
++++    exit(1);
+++   }
+++-  if(pid == 0) {
++++  if (pid == 0)
++++  {
+++     close(1);
+++-    fd = open("echo-ok", O_CREATE|O_WRONLY);
+++-    if(fd < 0) {
++++    fd = open("echo-ok", O_CREATE | O_WRONLY);
++++    if (fd < 0)
++++    {
+++       printf("%s: create failed\n", s);
+++       exit(1);
+++     }
+++-    if(fd != 1) {
++++    if (fd != 1)
++++    {
+++       printf("%s: wrong fd\n", s);
+++       exit(1);
+++     }
+++-    if(exec("echo", echoargv) < 0){
++++    if (exec("echo", echoargv) < 0)
++++    {
+++       printf("%s: exec echo failed\n", s);
+++       exit(1);
+++     }
+++     // won't get to here
+++   }
+++-  if (wait(&xstatus) != pid) {
++++  if (wait(&xstatus) != pid)
++++  {
+++     printf("%s: wait failed!\n", s);
+++   }
+++-  if(xstatus != 0)
++++  if (xstatus != 0)
+++     exit(xstatus);
+++ 
+++   fd = open("echo-ok", O_RDONLY);
+++-  if(fd < 0) {
++++  if (fd < 0)
++++  {
+++     printf("%s: open failed\n", s);
+++     exit(1);
+++   }
+++-  if (read(fd, buf, 2) != 2) {
++++  if (read(fd, buf, 2) != 2)
++++  {
+++     printf("%s: read failed\n", s);
+++     exit(1);
+++   }
+++   unlink("echo-ok");
+++-  if(buf[0] == 'O' && buf[1] == 'K')
++++  if (buf[0] == 'O' && buf[1] == 'K')
+++     exit(0);
+++-  else {
++++  else
++++  {
+++     printf("%s: wrong output\n", s);
+++     exit(1);
+++   }
+++-
+++ }
+++ 
+++ // simple fork and pipe read/write
+++ 
+++-void
+++-pipe1(char *s)
++++void pipe1(char *s)
+++ {
+++   int fds[2], pid, xstatus;
+++   int seq, i, n, cc, total;
+++-  enum { N=5, SZ=1033 };
+++-  
+++-  if(pipe(fds) != 0){
++++  enum
++++  {
++++    N = 5,
++++    SZ = 1033
++++  };
++++
++++  if (pipe(fds) != 0)
++++  {
+++     printf("%s: pipe() failed\n", s);
+++     exit(1);
+++   }
+++   pid = fork();
+++   seq = 0;
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     close(fds[0]);
+++-    for(n = 0; n < N; n++){
+++-      for(i = 0; i < SZ; i++)
++++    for (n = 0; n < N; n++)
++++    {
++++      for (i = 0; i < SZ; i++)
+++         buf[i] = seq++;
+++-      if(write(fds[1], buf, SZ) != SZ){
++++      if (write(fds[1], buf, SZ) != SZ)
++++      {
+++         printf("%s: pipe1 oops 1\n", s);
+++         exit(1);
+++       }
+++     }
+++     exit(0);
+++-  } else if(pid > 0){
++++  }
++++  else if (pid > 0)
++++  {
+++     close(fds[1]);
+++     total = 0;
+++     cc = 1;
+++-    while((n = read(fds[0], buf, cc)) > 0){
+++-      for(i = 0; i < n; i++){
+++-        if((buf[i] & 0xff) != (seq++ & 0xff)){
++++    while ((n = read(fds[0], buf, cc)) > 0)
++++    {
++++      for (i = 0; i < n; i++)
++++      {
++++        if ((buf[i] & 0xff) != (seq++ & 0xff))
++++        {
+++           printf("%s: pipe1 oops 2\n", s);
+++           return;
+++         }
+++       }
+++       total += n;
+++       cc = cc * 2;
+++-      if(cc > sizeof(buf))
++++      if (cc > sizeof(buf))
+++         cc = sizeof(buf);
+++     }
+++-    if(total != N * SZ){
++++    if (total != N * SZ)
++++    {
+++       printf("%s: pipe1 oops 3 total %d\n", s, total);
+++       exit(1);
+++     }
+++     close(fds[0]);
+++     wait(&xstatus);
+++     exit(xstatus);
+++-  } else {
++++  }
++++  else
++++  {
+++     printf("%s: fork() failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-
+++ // test if child is killed (status = -1)
+++-void
+++-killstatus(char *s)
++++void killstatus(char *s)
+++ {
+++   int xst;
+++-  
+++-  for(int i = 0; i < 100; i++){
++++
++++  for (int i = 0; i < 100; i++)
++++  {
+++     int pid1 = fork();
+++-    if(pid1 < 0){
++++    if (pid1 < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid1 == 0){
+++-      while(1) {
++++    if (pid1 == 0)
++++    {
++++      while (1)
++++      {
+++         getpid();
+++       }
+++       exit(0);
+++@@ -810,56 +912,61 @@ killstatus(char *s)
+++     sleep(1);
+++     kill(pid1);
+++     wait(&xst);
+++-    if(xst != -1) {
+++-       printf("%s: status should be -1\n", s);
+++-       exit(1);
++++    if (xst != -1)
++++    {
++++      printf("%s: status should be -1\n", s);
++++      exit(1);
+++     }
+++   }
+++   exit(0);
+++ }
+++ 
+++ // meant to be run w/ at most two CPUs
+++-void
+++-preempt(char *s)
++++void preempt(char *s)
+++ {
+++   int pid1, pid2, pid3;
+++   int pfds[2];
+++ 
+++   pid1 = fork();
+++-  if(pid1 < 0) {
++++  if (pid1 < 0)
++++  {
+++     printf("%s: fork failed", s);
+++     exit(1);
+++   }
+++-  if(pid1 == 0)
+++-    for(;;)
++++  if (pid1 == 0)
++++    for (;;)
+++       ;
+++ 
+++   pid2 = fork();
+++-  if(pid2 < 0) {
++++  if (pid2 < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++-  if(pid2 == 0)
+++-    for(;;)
++++  if (pid2 == 0)
++++    for (;;)
+++       ;
+++ 
+++   pipe(pfds);
+++   pid3 = fork();
+++-  if(pid3 < 0) {
+++-     printf("%s: fork failed\n", s);
+++-     exit(1);
++++  if (pid3 < 0)
++++  {
++++    printf("%s: fork failed\n", s);
++++    exit(1);
+++   }
+++-  if(pid3 == 0){
++++  if (pid3 == 0)
++++  {
+++     close(pfds[0]);
+++-    if(write(pfds[1], "x", 1) != 1)
++++    if (write(pfds[1], "x", 1) != 1)
+++       printf("%s: preempt write error", s);
+++     close(pfds[1]);
+++-    for(;;)
++++    for (;;)
+++       ;
+++   }
+++ 
+++   close(pfds[1]);
+++-  if(read(pfds[0], buf, sizeof(buf)) != 1){
++++  if (read(pfds[0], buf, sizeof(buf)) != 1)
++++  {
+++     printf("%s: preempt read error", s);
+++     return;
+++   }
+++@@ -875,28 +982,34 @@ preempt(char *s)
+++ }
+++ 
+++ // try to find any races between exit and wait
+++-void
+++-exitwait(char *s)
++++void exitwait(char *s)
+++ {
+++   int i, pid;
+++ 
+++-  for(i = 0; i < 100; i++){
++++  for (i = 0; i < 100; i++)
++++  {
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid){
++++    if (pid)
++++    {
+++       int xstate;
+++-      if(wait(&xstate) != pid){
++++      if (wait(&xstate) != pid)
++++      {
+++         printf("%s: wait wrong pid\n", s);
+++         exit(1);
+++       }
+++-      if(i != xstate) {
++++      if (i != xstate)
++++      {
+++         printf("%s: wait wrong exit status\n", s);
+++         exit(1);
+++       }
+++-    } else {
++++    }
++++    else
++++    {
+++       exit(i);
+++     }
+++   }
+++@@ -905,24 +1018,30 @@ exitwait(char *s)
+++ // try to find races in the reparenting
+++ // code that handles a parent exiting
+++ // when it still has live children.
+++-void
+++-reparent(char *s)
++++void reparent(char *s)
+++ {
+++   int master_pid = getpid();
+++-  for(int i = 0; i < 200; i++){
++++  for (int i = 0; i < 200; i++)
++++  {
+++     int pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid){
+++-      if(wait(0) != pid){
++++    if (pid)
++++    {
++++      if (wait(0) != pid)
++++      {
+++         printf("%s: wait wrong pid\n", s);
+++         exit(1);
+++       }
+++-    } else {
++++    }
++++    else
++++    {
+++       int pid2 = fork();
+++-      if(pid2 < 0){
++++      if (pid2 < 0)
++++      {
+++         kill(master_pid);
+++         exit(1);
+++       }
+++@@ -933,26 +1052,34 @@ reparent(char *s)
+++ }
+++ 
+++ // what if two children exit() at the same time?
+++-void
+++-twochildren(char *s)
++++void twochildren(char *s)
+++ {
+++-  for(int i = 0; i < 1000; i++){
++++  for (int i = 0; i < 1000; i++)
++++  {
+++     int pid1 = fork();
+++-    if(pid1 < 0){
++++    if (pid1 < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid1 == 0){
++++    if (pid1 == 0)
++++    {
+++       exit(0);
+++-    } else {
++++    }
++++    else
++++    {
+++       int pid2 = fork();
+++-      if(pid2 < 0){
++++      if (pid2 < 0)
++++      {
+++         printf("%s: fork failed\n", s);
+++         exit(1);
+++       }
+++-      if(pid2 == 0){
++++      if (pid2 == 0)
++++      {
+++         exit(0);
+++-      } else {
++++      }
++++      else
++++      {
+++         wait(0);
+++         wait(0);
+++       }
+++@@ -961,24 +1088,32 @@ twochildren(char *s)
+++ }
+++ 
+++ // concurrent forks to try to expose locking bugs.
+++-void
+++-forkfork(char *s)
++++void forkfork(char *s)
+++ {
+++-  enum { N=2 };
+++-  
+++-  for(int i = 0; i < N; i++){
++++  enum
++++  {
++++    N = 2
++++  };
++++
++++  for (int i = 0; i < N; i++)
++++  {
+++     int pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed", s);
+++       exit(1);
+++     }
+++-    if(pid == 0){
+++-      for(int j = 0; j < 200; j++){
++++    if (pid == 0)
++++    {
++++      for (int j = 0; j < 200; j++)
++++      {
+++         int pid1 = fork();
+++-        if(pid1 < 0){
++++        if (pid1 < 0)
++++        {
+++           exit(1);
+++         }
+++-        if(pid1 == 0){
++++        if (pid1 == 0)
++++        {
+++           exit(0);
+++         }
+++         wait(0);
+++@@ -988,33 +1123,39 @@ forkfork(char *s)
+++   }
+++ 
+++   int xstatus;
+++-  for(int i = 0; i < N; i++){
++++  for (int i = 0; i < N; i++)
++++  {
+++     wait(&xstatus);
+++-    if(xstatus != 0) {
++++    if (xstatus != 0)
++++    {
+++       printf("%s: fork in child failed", s);
+++       exit(1);
+++     }
+++   }
+++ }
+++ 
+++-void
+++-forkforkfork(char *s)
++++void forkforkfork(char *s)
+++ {
+++   unlink("stopforking");
+++ 
+++   int pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed", s);
+++     exit(1);
+++   }
+++-  if(pid == 0){
+++-    while(1){
++++  if (pid == 0)
++++  {
++++    while (1)
++++    {
+++       int fd = open("stopforking", 0);
+++-      if(fd >= 0){
++++      if (fd >= 0)
++++      {
+++         exit(0);
+++       }
+++-      if(fork() < 0){
+++-        close(open("stopforking", O_CREATE|O_RDWR));
++++      if (fork() < 0)
++++      {
++++        close(open("stopforking", O_CREATE | O_RDWR));
+++       }
+++     }
+++ 
+++@@ -1022,7 +1163,7 @@ forkforkfork(char *s)
+++   }
+++ 
+++   sleep(20); // two seconds
+++-  close(open("stopforking", O_CREATE|O_RDWR));
++++  close(open("stopforking", O_CREATE | O_RDWR));
+++   wait(0);
+++   sleep(10); // one second
+++ }
+++@@ -1032,16 +1173,18 @@ forkforkfork(char *s)
+++ // deadlocks against init's wait()? also used to trigger a "panic:
+++ // release" due to exit() releasing a different p->parent->lock than
+++ // it acquired.
+++-void
+++-reparent2(char *s)
++++void reparent2(char *s)
+++ {
+++-  for(int i = 0; i < 800; i++){
++++  for (int i = 0; i < 800; i++)
++++  {
+++     int pid1 = fork();
+++-    if(pid1 < 0){
++++    if (pid1 < 0)
++++    {
+++       printf("fork failed\n");
+++       exit(1);
+++     }
+++-    if(pid1 == 0){
++++    if (pid1 == 0)
++++    {
+++       fork();
+++       fork();
+++       exit(0);
+++@@ -1053,34 +1196,40 @@ reparent2(char *s)
+++ }
+++ 
+++ // allocate all mem, free it, and allocate again
+++-void
+++-mem(char *s)
++++void mem(char *s)
+++ {
+++   void *m1, *m2;
+++   int pid;
+++ 
+++-  if((pid = fork()) == 0){
++++  if ((pid = fork()) == 0)
++++  {
+++     m1 = 0;
+++-    while((m2 = malloc(10001)) != 0){
+++-      *(char**)m2 = m1;
++++    while ((m2 = malloc(10001)) != 0)
++++    {
++++      *(char **)m2 = m1;
+++       m1 = m2;
+++     }
+++-    while(m1){
+++-      m2 = *(char**)m1;
++++    while (m1)
++++    {
++++      m2 = *(char **)m1;
+++       free(m1);
+++       m1 = m2;
+++     }
+++-    m1 = malloc(1024*20);
+++-    if(m1 == 0){
++++    m1 = malloc(1024 * 20);
++++    if (m1 == 0)
++++    {
+++       printf("%s: couldn't allocate mem?!!\n", s);
+++       exit(1);
+++     }
+++     free(m1);
+++     exit(0);
+++-  } else {
++++  }
++++  else
++++  {
+++     int xstatus;
+++     wait(&xstatus);
+++-    if(xstatus == -1){
++++    if (xstatus == -1)
++++    {
+++       // probably page fault, so might be lazy lab,
+++       // so OK.
+++       exit(0);
+++@@ -1093,56 +1242,71 @@ mem(char *s)
+++ 
+++ // two processes write to the same file descriptor
+++ // is the offset shared? does inode locking work?
+++-void
+++-sharedfd(char *s)
++++void sharedfd(char *s)
+++ {
+++   int fd, pid, i, n, nc, np;
+++-  enum { N = 1000, SZ=10};
++++  enum
++++  {
++++    N = 1000,
++++    SZ = 10
++++  };
+++   char buf[SZ];
+++ 
+++   unlink("sharedfd");
+++-  fd = open("sharedfd", O_CREATE|O_RDWR);
+++-  if(fd < 0){
++++  fd = open("sharedfd", O_CREATE | O_RDWR);
++++  if (fd < 0)
++++  {
+++     printf("%s: cannot open sharedfd for writing", s);
+++     exit(1);
+++   }
+++   pid = fork();
+++-  memset(buf, pid==0?'c':'p', sizeof(buf));
+++-  for(i = 0; i < N; i++){
+++-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
++++  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
++++  for (i = 0; i < N; i++)
++++  {
++++    if (write(fd, buf, sizeof(buf)) != sizeof(buf))
++++    {
+++       printf("%s: write sharedfd failed\n", s);
+++       exit(1);
+++     }
+++   }
+++-  if(pid == 0) {
++++  if (pid == 0)
++++  {
+++     exit(0);
+++-  } else {
++++  }
++++  else
++++  {
+++     int xstatus;
+++     wait(&xstatus);
+++-    if(xstatus != 0)
++++    if (xstatus != 0)
+++       exit(xstatus);
+++   }
+++-  
++++
+++   close(fd);
+++   fd = open("sharedfd", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: cannot open sharedfd for reading\n", s);
+++     exit(1);
+++   }
+++   nc = np = 0;
+++-  while((n = read(fd, buf, sizeof(buf))) > 0){
+++-    for(i = 0; i < sizeof(buf); i++){
+++-      if(buf[i] == 'c')
++++  while ((n = read(fd, buf, sizeof(buf))) > 0)
++++  {
++++    for (i = 0; i < sizeof(buf); i++)
++++    {
++++      if (buf[i] == 'c')
+++         nc++;
+++-      if(buf[i] == 'p')
++++      if (buf[i] == 'p')
+++         np++;
+++     }
+++   }
+++   close(fd);
+++   unlink("sharedfd");
+++-  if(nc == N*SZ && np == N*SZ){
++++  if (nc == N * SZ && np == N * SZ)
++++  {
+++     exit(0);
+++-  } else {
++++  }
++++  else
++++  {
+++     printf("%s: nc/np test fails\n", s);
+++     exit(1);
+++   }
+++@@ -1150,34 +1314,44 @@ sharedfd(char *s)
+++ 
+++ // four processes write different files at the same
+++ // time, to test block allocation.
+++-void
+++-fourfiles(char *s)
++++void fourfiles(char *s)
+++ {
+++   int fd, pid, i, j, n, total, pi;
+++-  char *names[] = { "f0", "f1", "f2", "f3" };
++++  char *names[] = {"f0", "f1", "f2", "f3"};
+++   char *fname;
+++-  enum { N=12, NCHILD=4, SZ=500 };
+++-  
+++-  for(pi = 0; pi < NCHILD; pi++){
++++  enum
++++  {
++++    N = 12,
++++    NCHILD = 4,
++++    SZ = 500
++++  };
++++
++++  for (pi = 0; pi < NCHILD; pi++)
++++  {
+++     fname = names[pi];
+++     unlink(fname);
+++ 
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++ 
+++-    if(pid == 0){
++++    if (pid == 0)
++++    {
+++       fd = open(fname, O_CREATE | O_RDWR);
+++-      if(fd < 0){
++++      if (fd < 0)
++++      {
+++         printf("%s: create failed\n", s);
+++         exit(1);
+++       }
+++ 
+++-      memset(buf, '0'+pi, SZ);
+++-      for(i = 0; i < N; i++){
+++-        if((n = write(fd, buf, SZ)) != SZ){
++++      memset(buf, '0' + pi, SZ);
++++      for (i = 0; i < N; i++)
++++      {
++++        if ((n = write(fd, buf, SZ)) != SZ)
++++        {
+++           printf("write failed %d\n", n);
+++           exit(1);
+++         }
+++@@ -1187,19 +1361,24 @@ fourfiles(char *s)
+++   }
+++ 
+++   int xstatus;
+++-  for(pi = 0; pi < NCHILD; pi++){
++++  for (pi = 0; pi < NCHILD; pi++)
++++  {
+++     wait(&xstatus);
+++-    if(xstatus != 0)
++++    if (xstatus != 0)
+++       exit(xstatus);
+++   }
+++ 
+++-  for(i = 0; i < NCHILD; i++){
++++  for (i = 0; i < NCHILD; i++)
++++  {
+++     fname = names[i];
+++     fd = open(fname, 0);
+++     total = 0;
+++-    while((n = read(fd, buf, sizeof(buf))) > 0){
+++-      for(j = 0; j < n; j++){
+++-        if(buf[j] != '0'+i){
++++    while ((n = read(fd, buf, sizeof(buf))) > 0)
++++    {
++++      for (j = 0; j < n; j++)
++++      {
++++        if (buf[j] != '0' + i)
++++        {
+++           printf("%s: wrong char\n", s);
+++           exit(1);
+++         }
+++@@ -1207,7 +1386,8 @@ fourfiles(char *s)
+++       total += n;
+++     }
+++     close(fd);
+++-    if(total != N*SZ){
++++    if (total != N * SZ)
++++    {
+++       printf("wrong length %d\n", total);
+++       exit(1);
+++     }
+++@@ -1216,34 +1396,44 @@ fourfiles(char *s)
+++ }
+++ 
+++ // four processes create and delete different files in same directory
+++-void
+++-createdelete(char *s)
++++void createdelete(char *s)
+++ {
+++-  enum { N = 20, NCHILD=4 };
++++  enum
++++  {
++++    N = 20,
++++    NCHILD = 4
++++  };
+++   int pid, i, fd, pi;
+++   char name[32];
+++ 
+++-  for(pi = 0; pi < NCHILD; pi++){
++++  for (pi = 0; pi < NCHILD; pi++)
++++  {
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++ 
+++-    if(pid == 0){
++++    if (pid == 0)
++++    {
+++       name[0] = 'p' + pi;
+++       name[2] = '\0';
+++-      for(i = 0; i < N; i++){
++++      for (i = 0; i < N; i++)
++++      {
+++         name[1] = '0' + i;
+++         fd = open(name, O_CREATE | O_RDWR);
+++-        if(fd < 0){
++++        if (fd < 0)
++++        {
+++           printf("%s: create failed\n", s);
+++           exit(1);
+++         }
+++         close(fd);
+++-        if(i > 0 && (i % 2 ) == 0){
++++        if (i > 0 && (i % 2) == 0)
++++        {
+++           name[1] = '0' + (i / 2);
+++-          if(unlink(name) < 0){
++++          if (unlink(name) < 0)
++++          {
+++             printf("%s: unlink failed\n", s);
+++             exit(1);
+++           }
+++@@ -1254,32 +1444,40 @@ createdelete(char *s)
+++   }
+++ 
+++   int xstatus;
+++-  for(pi = 0; pi < NCHILD; pi++){
++++  for (pi = 0; pi < NCHILD; pi++)
++++  {
+++     wait(&xstatus);
+++-    if(xstatus != 0)
++++    if (xstatus != 0)
+++       exit(1);
+++   }
+++ 
+++   name[0] = name[1] = name[2] = 0;
+++-  for(i = 0; i < N; i++){
+++-    for(pi = 0; pi < NCHILD; pi++){
++++  for (i = 0; i < N; i++)
++++  {
++++    for (pi = 0; pi < NCHILD; pi++)
++++    {
+++       name[0] = 'p' + pi;
+++       name[1] = '0' + i;
+++       fd = open(name, 0);
+++-      if((i == 0 || i >= N/2) && fd < 0){
++++      if ((i == 0 || i >= N / 2) && fd < 0)
++++      {
+++         printf("%s: oops createdelete %s didn't exist\n", s, name);
+++         exit(1);
+++-      } else if((i >= 1 && i < N/2) && fd >= 0){
++++      }
++++      else if ((i >= 1 && i < N / 2) && fd >= 0)
++++      {
+++         printf("%s: oops createdelete %s did exist\n", s, name);
+++         exit(1);
+++       }
+++-      if(fd >= 0)
++++      if (fd >= 0)
+++         close(fd);
+++     }
+++   }
+++ 
+++-  for(i = 0; i < N; i++){
+++-    for(pi = 0; pi < NCHILD; pi++){
++++  for (i = 0; i < N; i++)
++++  {
++++    for (pi = 0; pi < NCHILD; pi++)
++++    {
+++       name[0] = 'p' + pi;
+++       name[1] = '0' + i;
+++       unlink(name);
+++@@ -1288,14 +1486,17 @@ createdelete(char *s)
+++ }
+++ 
+++ // can I unlink a file and still read it?
+++-void
+++-unlinkread(char *s)
++++void unlinkread(char *s)
+++ {
+++-  enum { SZ = 5 };
++++  enum
++++  {
++++    SZ = 5
++++  };
+++   int fd, fd1;
+++ 
+++   fd = open("unlinkread", O_CREATE | O_RDWR);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: create unlinkread failed\n", s);
+++     exit(1);
+++   }
+++@@ -1303,11 +1504,13 @@ unlinkread(char *s)
+++   close(fd);
+++ 
+++   fd = open("unlinkread", O_RDWR);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open unlinkread failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("unlinkread") != 0){
++++  if (unlink("unlinkread") != 0)
++++  {
+++     printf("%s: unlink unlinkread failed\n", s);
+++     exit(1);
+++   }
+++@@ -1316,15 +1519,18 @@ unlinkread(char *s)
+++   write(fd1, "yyy", 3);
+++   close(fd1);
+++ 
+++-  if(read(fd, buf, sizeof(buf)) != SZ){
++++  if (read(fd, buf, sizeof(buf)) != SZ)
++++  {
+++     printf("%s: unlinkread read failed", s);
+++     exit(1);
+++   }
+++-  if(buf[0] != 'h'){
++++  if (buf[0] != 'h')
++++  {
+++     printf("%s: unlinkread wrong data\n", s);
+++     exit(1);
+++   }
+++-  if(write(fd, buf, 10) != 10){
++++  if (write(fd, buf, 10) != 10)
++++  {
+++     printf("%s: unlinkread write failed\n", s);
+++     exit(1);
+++   }
+++@@ -1332,102 +1538,126 @@ unlinkread(char *s)
+++   unlink("unlinkread");
+++ }
+++ 
+++-void
+++-linktest(char *s)
++++void linktest(char *s)
+++ {
+++-  enum { SZ = 5 };
++++  enum
++++  {
++++    SZ = 5
++++  };
+++   int fd;
+++ 
+++   unlink("lf1");
+++   unlink("lf2");
+++ 
+++-  fd = open("lf1", O_CREATE|O_RDWR);
+++-  if(fd < 0){
++++  fd = open("lf1", O_CREATE | O_RDWR);
++++  if (fd < 0)
++++  {
+++     printf("%s: create lf1 failed\n", s);
+++     exit(1);
+++   }
+++-  if(write(fd, "hello", SZ) != SZ){
++++  if (write(fd, "hello", SZ) != SZ)
++++  {
+++     printf("%s: write lf1 failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(link("lf1", "lf2") < 0){
++++  if (link("lf1", "lf2") < 0)
++++  {
+++     printf("%s: link lf1 lf2 failed\n", s);
+++     exit(1);
+++   }
+++   unlink("lf1");
+++ 
+++-  if(open("lf1", 0) >= 0){
++++  if (open("lf1", 0) >= 0)
++++  {
+++     printf("%s: unlinked lf1 but it is still there!\n", s);
+++     exit(1);
+++   }
+++ 
+++   fd = open("lf2", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open lf2 failed\n", s);
+++     exit(1);
+++   }
+++-  if(read(fd, buf, sizeof(buf)) != SZ){
++++  if (read(fd, buf, sizeof(buf)) != SZ)
++++  {
+++     printf("%s: read lf2 failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(link("lf2", "lf2") >= 0){
++++  if (link("lf2", "lf2") >= 0)
++++  {
+++     printf("%s: link lf2 lf2 succeeded! oops\n", s);
+++     exit(1);
+++   }
+++ 
+++   unlink("lf2");
+++-  if(link("lf2", "lf1") >= 0){
++++  if (link("lf2", "lf1") >= 0)
++++  {
+++     printf("%s: link non-existent succeeded! oops\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(link(".", "lf1") >= 0){
++++  if (link(".", "lf1") >= 0)
++++  {
+++     printf("%s: link . lf1 succeeded! oops\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++ // test concurrent create/link/unlink of the same file
+++-void
+++-concreate(char *s)
++++void concreate(char *s)
+++ {
+++-  enum { N = 40 };
++++  enum
++++  {
++++    N = 40
++++  };
+++   char file[3];
+++   int i, pid, n, fd;
+++   char fa[N];
+++-  struct {
++++  struct
++++  {
+++     ushort inum;
+++     char name[DIRSIZ];
+++   } de;
+++ 
+++   file[0] = 'C';
+++   file[2] = '\0';
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     file[1] = '0' + i;
+++     unlink(file);
+++     pid = fork();
+++-    if(pid && (i % 3) == 1){
++++    if (pid && (i % 3) == 1)
++++    {
+++       link("C0", file);
+++-    } else if(pid == 0 && (i % 5) == 1){
++++    }
++++    else if (pid == 0 && (i % 5) == 1)
++++    {
+++       link("C0", file);
+++-    } else {
++++    }
++++    else
++++    {
+++       fd = open(file, O_CREATE | O_RDWR);
+++-      if(fd < 0){
++++      if (fd < 0)
++++      {
+++         printf("concreate create %s failed\n", file);
+++         exit(1);
+++       }
+++       close(fd);
+++     }
+++-    if(pid == 0) {
++++    if (pid == 0)
++++    {
+++       exit(0);
+++-    } else {
++++    }
++++    else
++++    {
+++       int xstatus;
+++       wait(&xstatus);
+++-      if(xstatus != 0)
++++      if (xstatus != 0)
+++         exit(1);
+++     }
+++   }
+++@@ -1435,16 +1665,20 @@ concreate(char *s)
+++   memset(fa, 0, sizeof(fa));
+++   fd = open(".", 0);
+++   n = 0;
+++-  while(read(fd, &de, sizeof(de)) > 0){
+++-    if(de.inum == 0)
++++  while (read(fd, &de, sizeof(de)) > 0)
++++  {
++++    if (de.inum == 0)
+++       continue;
+++-    if(de.name[0] == 'C' && de.name[2] == '\0'){
++++    if (de.name[0] == 'C' && de.name[2] == '\0')
++++    {
+++       i = de.name[1] - '0';
+++-      if(i < 0 || i >= sizeof(fa)){
++++      if (i < 0 || i >= sizeof(fa))
++++      {
+++         printf("%s: concreate weird file %s\n", s, de.name);
+++         exit(1);
+++       }
+++-      if(fa[i]){
++++      if (fa[i])
++++      {
+++         printf("%s: concreate duplicate file %s\n", s, de.name);
+++         exit(1);
+++       }
+++@@ -1454,27 +1688,33 @@ concreate(char *s)
+++   }
+++   close(fd);
+++ 
+++-  if(n != N){
++++  if (n != N)
++++  {
+++     printf("%s: concreate not enough files in directory listing\n", s);
+++     exit(1);
+++   }
+++ 
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     file[1] = '0' + i;
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(((i % 3) == 0 && pid == 0) ||
+++-       ((i % 3) == 1 && pid != 0)){
++++    if (((i % 3) == 0 && pid == 0) ||
++++        ((i % 3) == 1 && pid != 0))
++++    {
+++       close(open(file, 0));
+++       close(open(file, 0));
+++       close(open(file, 0));
+++       close(open(file, 0));
+++       close(open(file, 0));
+++       close(open(file, 0));
+++-    } else {
++++    }
++++    else
++++    {
+++       unlink(file);
+++       unlink(file);
+++       unlink(file);
+++@@ -1482,7 +1722,7 @@ concreate(char *s)
+++       unlink(file);
+++       unlink(file);
+++     }
+++-    if(pid == 0)
++++    if (pid == 0)
+++       exit(0);
+++     else
+++       wait(0);
+++@@ -1491,68 +1731,77 @@ concreate(char *s)
+++ 
+++ // another concurrent link/unlink/create test,
+++ // to look for deadlocks.
+++-void
+++-linkunlink(char *s)
++++void linkunlink(char *s)
+++ {
+++   int pid, i;
+++ 
+++   unlink("x");
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++ 
+++   unsigned int x = (pid ? 1 : 97);
+++-  for(i = 0; i < 100; i++){
++++  for (i = 0; i < 100; i++)
++++  {
+++     x = x * 1103515245 + 12345;
+++-    if((x % 3) == 0){
++++    if ((x % 3) == 0)
++++    {
+++       close(open("x", O_RDWR | O_CREATE));
+++-    } else if((x % 3) == 1){
++++    }
++++    else if ((x % 3) == 1)
++++    {
+++       link("cat", "x");
+++-    } else {
++++    }
++++    else
++++    {
+++       unlink("x");
+++     }
+++   }
+++ 
+++-  if(pid)
++++  if (pid)
+++     wait(0);
+++   else
+++     exit(0);
+++ }
+++ 
+++-
+++-void
+++-subdir(char *s)
++++void subdir(char *s)
+++ {
+++   int fd, cc;
+++ 
+++   unlink("ff");
+++-  if(mkdir("dd") != 0){
++++  if (mkdir("dd") != 0)
++++  {
+++     printf("%s: mkdir dd failed\n", s);
+++     exit(1);
+++   }
+++ 
+++   fd = open("dd/ff", O_CREATE | O_RDWR);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: create dd/ff failed\n", s);
+++     exit(1);
+++   }
+++   write(fd, "ff", 2);
+++   close(fd);
+++ 
+++-  if(unlink("dd") >= 0){
++++  if (unlink("dd") >= 0)
++++  {
+++     printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(mkdir("/dd/dd") != 0){
++++  if (mkdir("/dd/dd") != 0)
++++  {
+++     printf("%s: subdir mkdir dd/dd failed\n", s);
+++     exit(1);
+++   }
+++ 
+++   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: create dd/dd/ff failed\n", s);
+++     exit(1);
+++   }
+++@@ -1560,164 +1809,199 @@ subdir(char *s)
+++   close(fd);
+++ 
+++   fd = open("dd/dd/../ff", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open dd/dd/../ff failed\n", s);
+++     exit(1);
+++   }
+++   cc = read(fd, buf, sizeof(buf));
+++-  if(cc != 2 || buf[0] != 'f'){
++++  if (cc != 2 || buf[0] != 'f')
++++  {
+++     printf("%s: dd/dd/../ff wrong content\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++++  if (link("dd/dd/ff", "dd/dd/ffff") != 0)
++++  {
+++     printf("%s: link dd/dd/ff dd/dd/ffff failed\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(unlink("dd/dd/ff") != 0){
++++  if (unlink("dd/dd/ff") != 0)
++++  {
+++     printf("%s: unlink dd/dd/ff failed\n", s);
+++     exit(1);
+++   }
+++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++++  if (open("dd/dd/ff", O_RDONLY) >= 0)
++++  {
+++     printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(chdir("dd") != 0){
++++  if (chdir("dd") != 0)
++++  {
+++     printf("%s: chdir dd failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("dd/../../dd") != 0){
++++  if (chdir("dd/../../dd") != 0)
++++  {
+++     printf("%s: chdir dd/../../dd failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("dd/../../../dd") != 0){
++++  if (chdir("dd/../../../dd") != 0)
++++  {
+++     printf("%s: chdir dd/../../../dd failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("./..") != 0){
++++  if (chdir("./..") != 0)
++++  {
+++     printf("%s: chdir ./.. failed\n", s);
+++     exit(1);
+++   }
+++ 
+++   fd = open("dd/dd/ffff", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open dd/dd/ffff failed\n", s);
+++     exit(1);
+++   }
+++-  if(read(fd, buf, sizeof(buf)) != 2){
++++  if (read(fd, buf, sizeof(buf)) != 2)
++++  {
+++     printf("%s: read dd/dd/ffff wrong len\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++++  if (open("dd/dd/ff", O_RDONLY) >= 0)
++++  {
+++     printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++++  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0)
++++  {
+++     printf("%s: create dd/ff/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++++  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0)
++++  {
+++     printf("%s: create dd/xx/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(open("dd", O_CREATE) >= 0){
++++  if (open("dd", O_CREATE) >= 0)
++++  {
+++     printf("%s: create dd succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(open("dd", O_RDWR) >= 0){
++++  if (open("dd", O_RDWR) >= 0)
++++  {
+++     printf("%s: open dd rdwr succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(open("dd", O_WRONLY) >= 0){
++++  if (open("dd", O_WRONLY) >= 0)
++++  {
+++     printf("%s: open dd wronly succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
++++  if (link("dd/ff/ff", "dd/dd/xx") == 0)
++++  {
+++     printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
++++  if (link("dd/xx/ff", "dd/dd/xx") == 0)
++++  {
+++     printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(link("dd/ff", "dd/dd/ffff") == 0){
++++  if (link("dd/ff", "dd/dd/ffff") == 0)
++++  {
+++     printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("dd/ff/ff") == 0){
++++  if (mkdir("dd/ff/ff") == 0)
++++  {
+++     printf("%s: mkdir dd/ff/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("dd/xx/ff") == 0){
++++  if (mkdir("dd/xx/ff") == 0)
++++  {
+++     printf("%s: mkdir dd/xx/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("dd/dd/ffff") == 0){
++++  if (mkdir("dd/dd/ffff") == 0)
++++  {
+++     printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd/xx/ff") == 0){
++++  if (unlink("dd/xx/ff") == 0)
++++  {
+++     printf("%s: unlink dd/xx/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd/ff/ff") == 0){
++++  if (unlink("dd/ff/ff") == 0)
++++  {
+++     printf("%s: unlink dd/ff/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("dd/ff") == 0){
++++  if (chdir("dd/ff") == 0)
++++  {
+++     printf("%s: chdir dd/ff succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("dd/xx") == 0){
++++  if (chdir("dd/xx") == 0)
++++  {
+++     printf("%s: chdir dd/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(unlink("dd/dd/ffff") != 0){
++++  if (unlink("dd/dd/ffff") != 0)
++++  {
+++     printf("%s: unlink dd/dd/ff failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd/ff") != 0){
++++  if (unlink("dd/ff") != 0)
++++  {
+++     printf("%s: unlink dd/ff failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd") == 0){
++++  if (unlink("dd") == 0)
++++  {
+++     printf("%s: unlink non-empty dd succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd/dd") < 0){
++++  if (unlink("dd/dd") < 0)
++++  {
+++     printf("%s: unlink dd/dd failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dd") < 0){
++++  if (unlink("dd") < 0)
++++  {
+++     printf("%s: unlink dd failed\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++ // test writes that are larger than the log.
+++-void
+++-bigwrite(char *s)
++++void bigwrite(char *s)
+++ {
+++   int fd, sz;
+++ 
+++   unlink("bigwrite");
+++-  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
++++  for (sz = 499; sz < (MAXOPBLOCKS + 2) * BSIZE; sz += 471)
++++  {
+++     fd = open("bigwrite", O_CREATE | O_RDWR);
+++-    if(fd < 0){
++++    if (fd < 0)
++++    {
+++       printf("%s: cannot create bigwrite\n", s);
+++       exit(1);
+++     }
+++     int i;
+++-    for(i = 0; i < 2; i++){
++++    for (i = 0; i < 2; i++)
++++    {
+++       int cc = write(fd, buf, sz);
+++-      if(cc != sz){
++++      if (cc != sz)
++++      {
+++         printf("%s: write(%d) ret %d\n", s, sz, cc);
+++         exit(1);
+++       }
+++@@ -1727,22 +2011,27 @@ bigwrite(char *s)
+++   }
+++ }
+++ 
+++-
+++-void
+++-bigfile(char *s)
++++void bigfile(char *s)
+++ {
+++-  enum { N = 20, SZ=600 };
++++  enum
++++  {
++++    N = 20,
++++    SZ = 600
++++  };
+++   int fd, i, total, cc;
+++ 
+++   unlink("bigfile.dat");
+++   fd = open("bigfile.dat", O_CREATE | O_RDWR);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: cannot create bigfile", s);
+++     exit(1);
+++   }
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     memset(buf, i, SZ);
+++-    if(write(fd, buf, SZ) != SZ){
++++    if (write(fd, buf, SZ) != SZ)
++++    {
+++       printf("%s: write bigfile failed\n", s);
+++       exit(1);
+++     }
+++@@ -1750,70 +2039,81 @@ bigfile(char *s)
+++   close(fd);
+++ 
+++   fd = open("bigfile.dat", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: cannot open bigfile\n", s);
+++     exit(1);
+++   }
+++   total = 0;
+++-  for(i = 0; ; i++){
+++-    cc = read(fd, buf, SZ/2);
+++-    if(cc < 0){
++++  for (i = 0;; i++)
++++  {
++++    cc = read(fd, buf, SZ / 2);
++++    if (cc < 0)
++++    {
+++       printf("%s: read bigfile failed\n", s);
+++       exit(1);
+++     }
+++-    if(cc == 0)
++++    if (cc == 0)
+++       break;
+++-    if(cc != SZ/2){
++++    if (cc != SZ / 2)
++++    {
+++       printf("%s: short read bigfile\n", s);
+++       exit(1);
+++     }
+++-    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
++++    if (buf[0] != i / 2 || buf[SZ / 2 - 1] != i / 2)
++++    {
+++       printf("%s: read bigfile wrong data\n", s);
+++       exit(1);
+++     }
+++     total += cc;
+++   }
+++   close(fd);
+++-  if(total != N*SZ){
++++  if (total != N * SZ)
++++  {
+++     printf("%s: read bigfile wrong total\n", s);
+++     exit(1);
+++   }
+++   unlink("bigfile.dat");
+++ }
+++ 
+++-void
+++-fourteen(char *s)
++++void fourteen(char *s)
+++ {
+++   int fd;
+++ 
+++   // DIRSIZ is 14.
+++ 
+++-  if(mkdir("12345678901234") != 0){
++++  if (mkdir("12345678901234") != 0)
++++  {
+++     printf("%s: mkdir 12345678901234 failed\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("12345678901234/123456789012345") != 0){
++++  if (mkdir("12345678901234/123456789012345") != 0)
++++  {
+++     printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
+++     exit(1);
+++   }
+++   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++   fd = open("12345678901234/12345678901234/12345678901234", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  if(mkdir("12345678901234/12345678901234") == 0){
++++  if (mkdir("12345678901234/12345678901234") == 0)
++++  {
+++     printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("123456789012345/12345678901234") == 0){
++++  if (mkdir("123456789012345/12345678901234") == 0)
++++  {
+++     printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
+++     exit(1);
+++   }
+++@@ -1827,92 +2127,108 @@ fourteen(char *s)
+++   unlink("12345678901234");
+++ }
+++ 
+++-void
+++-rmdot(char *s)
++++void rmdot(char *s)
+++ {
+++-  if(mkdir("dots") != 0){
++++  if (mkdir("dots") != 0)
++++  {
+++     printf("%s: mkdir dots failed\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("dots") != 0){
++++  if (chdir("dots") != 0)
++++  {
+++     printf("%s: chdir dots failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink(".") == 0){
++++  if (unlink(".") == 0)
++++  {
+++     printf("%s: rm . worked!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("..") == 0){
++++  if (unlink("..") == 0)
++++  {
+++     printf("%s: rm .. worked!\n", s);
+++     exit(1);
+++   }
+++-  if(chdir("/") != 0){
++++  if (chdir("/") != 0)
++++  {
+++     printf("%s: chdir / failed\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dots/.") == 0){
++++  if (unlink("dots/.") == 0)
++++  {
+++     printf("%s: unlink dots/. worked!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dots/..") == 0){
++++  if (unlink("dots/..") == 0)
++++  {
+++     printf("%s: unlink dots/.. worked!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dots") != 0){
++++  if (unlink("dots") != 0)
++++  {
+++     printf("%s: unlink dots failed!\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-void
+++-dirfile(char *s)
++++void dirfile(char *s)
+++ {
+++   int fd;
+++ 
+++   fd = open("dirfile", O_CREATE);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: create dirfile failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++-  if(chdir("dirfile") == 0){
++++  if (chdir("dirfile") == 0)
++++  {
+++     printf("%s: chdir dirfile succeeded!\n", s);
+++     exit(1);
+++   }
+++   fd = open("dirfile/xx", 0);
+++-  if(fd >= 0){
++++  if (fd >= 0)
++++  {
+++     printf("%s: create dirfile/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++   fd = open("dirfile/xx", O_CREATE);
+++-  if(fd >= 0){
++++  if (fd >= 0)
++++  {
+++     printf("%s: create dirfile/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(mkdir("dirfile/xx") == 0){
++++  if (mkdir("dirfile/xx") == 0)
++++  {
+++     printf("%s: mkdir dirfile/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dirfile/xx") == 0){
++++  if (unlink("dirfile/xx") == 0)
++++  {
+++     printf("%s: unlink dirfile/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(link("README", "dirfile/xx") == 0){
++++  if (link("README", "dirfile/xx") == 0)
++++  {
+++     printf("%s: link to dirfile/xx succeeded!\n", s);
+++     exit(1);
+++   }
+++-  if(unlink("dirfile") != 0){
++++  if (unlink("dirfile") != 0)
++++  {
+++     printf("%s: unlink dirfile failed!\n", s);
+++     exit(1);
+++   }
+++ 
+++   fd = open(".", O_RDWR);
+++-  if(fd >= 0){
++++  if (fd >= 0)
++++  {
+++     printf("%s: open . for writing succeeded!\n", s);
+++     exit(1);
+++   }
+++   fd = open(".", 0);
+++-  if(write(fd, "x", 1) > 0){
++++  if (write(fd, "x", 1) > 0)
++++  {
+++     printf("%s: write . succeeded!\n", s);
+++     exit(1);
+++   }
+++@@ -1921,17 +2237,19 @@ dirfile(char *s)
+++ 
+++ // test that iput() is called at the end of _namei().
+++ // also tests empty file names.
+++-void
+++-iref(char *s)
++++void iref(char *s)
+++ {
+++   int i, fd;
+++ 
+++-  for(i = 0; i < NINODE + 1; i++){
+++-    if(mkdir("irefd") != 0){
++++  for (i = 0; i < NINODE + 1; i++)
++++  {
++++    if (mkdir("irefd") != 0)
++++    {
+++       printf("%s: mkdir irefd failed\n", s);
+++       exit(1);
+++     }
+++-    if(chdir("irefd") != 0){
++++    if (chdir("irefd") != 0)
++++    {
+++       printf("%s: chdir irefd failed\n", s);
+++       exit(1);
+++     }
+++@@ -1939,16 +2257,17 @@ iref(char *s)
+++     mkdir("");
+++     link("README", "");
+++     fd = open("", O_CREATE);
+++-    if(fd >= 0)
++++    if (fd >= 0)
+++       close(fd);
+++     fd = open("xx", O_CREATE);
+++-    if(fd >= 0)
++++    if (fd >= 0)
+++       close(fd);
+++     unlink("xx");
+++   }
+++ 
+++   // clean up
+++-  for(i = 0; i < NINODE + 1; i++){
++++  for (i = 0; i < NINODE + 1; i++)
++++  {
+++     chdir("..");
+++     unlink("irefd");
+++   }
+++@@ -1959,67 +2278,81 @@ iref(char *s)
+++ // test that fork fails gracefully
+++ // the forktest binary also does this, but it runs out of proc entries first.
+++ // inside the bigger usertests binary, we run out of memory first.
+++-void
+++-forktest(char *s)
++++void forktest(char *s)
+++ {
+++-  enum{ N = 1000 };
++++  enum
++++  {
++++    N = 1000
++++  };
+++   int n, pid;
+++ 
+++-  for(n=0; n<N; n++){
++++  for (n = 0; n < N; n++)
++++  {
+++     pid = fork();
+++-    if(pid < 0)
++++    if (pid < 0)
+++       break;
+++-    if(pid == 0)
++++    if (pid == 0)
+++       exit(0);
+++   }
+++ 
+++-  if (n == 0) {
++++  if (n == 0)
++++  {
+++     printf("%s: no fork at all!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  if(n == N){
++++  if (n == N)
++++  {
+++     printf("%s: fork claimed to work 1000 times!\n", s);
+++     exit(1);
+++   }
+++ 
+++-  for(; n > 0; n--){
+++-    if(wait(0) < 0){
++++  for (; n > 0; n--)
++++  {
++++    if (wait(0) < 0)
++++    {
+++       printf("%s: wait stopped early\n", s);
+++       exit(1);
+++     }
+++   }
+++ 
+++-  if(wait(0) != -1){
++++  if (wait(0) != -1)
++++  {
+++     printf("%s: wait got too many\n", s);
+++     exit(1);
+++   }
+++ }
+++ 
+++-void
+++-sbrkbasic(char *s)
++++void sbrkbasic(char *s)
+++ {
+++-  enum { TOOMUCH=1024*1024*1024};
++++  enum
++++  {
++++    TOOMUCH = 1024 * 1024 * 1024
++++  };
+++   int i, pid, xstatus;
+++   char *c, *a, *b;
+++ 
+++   // does sbrk() return the expected failure value?
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed in sbrkbasic\n");
+++     exit(1);
+++   }
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     a = sbrk(TOOMUCH);
+++-    if(a == (char*)0xffffffffffffffffL){
++++    if (a == (char *)0xffffffffffffffffL)
++++    {
+++       // it's OK if this fails.
+++       exit(0);
+++     }
+++-    
+++-    for(b = a; b < a+TOOMUCH; b += 4096){
++++
++++    for (b = a; b < a + TOOMUCH; b += 4096)
++++    {
+++       *b = 99;
+++     }
+++-    
++++
+++     // we should not get here! either sbrk(TOOMUCH)
+++     // should have failed, or (with lazy allocation)
+++     // a pagefault should have killed this process.
+++@@ -2027,16 +2360,19 @@ sbrkbasic(char *s)
+++   }
+++ 
+++   wait(&xstatus);
+++-  if(xstatus == 1){
++++  if (xstatus == 1)
++++  {
+++     printf("%s: too much memory allocated!\n", s);
+++     exit(1);
+++   }
+++ 
+++   // can one sbrk() less than a page?
+++   a = sbrk(0);
+++-  for(i = 0; i < 5000; i++){
++++  for (i = 0; i < 5000; i++)
++++  {
+++     b = sbrk(1);
+++-    if(b != a){
++++    if (b != a)
++++    {
+++       printf("%s: sbrk test failed %d %p %p\n", s, i, a, b);
+++       exit(1);
+++     }
+++@@ -2044,26 +2380,30 @@ sbrkbasic(char *s)
+++     a = b + 1;
+++   }
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: sbrk test fork failed\n", s);
+++     exit(1);
+++   }
+++   c = sbrk(1);
+++   c = sbrk(1);
+++-  if(c != a + 1){
++++  if (c != a + 1)
++++  {
+++     printf("%s: sbrk test failed post-fork\n", s);
+++     exit(1);
+++   }
+++-  if(pid == 0)
++++  if (pid == 0)
+++     exit(0);
+++   wait(&xstatus);
+++   exit(xstatus);
+++ }
+++ 
+++-void
+++-sbrkmuch(char *s)
++++void sbrkmuch(char *s)
+++ {
+++-  enum { BIG=100*1024*1024 };
++++  enum
++++  {
++++    BIG = 100 * 1024 * 1024
++++  };
+++   char *c, *oldbrk, *a, *lastaddr, *p;
+++   uint64 amt;
+++ 
+++@@ -2073,28 +2413,31 @@ sbrkmuch(char *s)
+++   a = sbrk(0);
+++   amt = BIG - (uint64)a;
+++   p = sbrk(amt);
+++-  if (p != a) {
++++  if (p != a)
++++  {
+++     printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
+++     exit(1);
+++   }
+++ 
+++   // touch each page to make sure it exists.
+++   char *eee = sbrk(0);
+++-  for(char *pp = a; pp < eee; pp += 4096)
++++  for (char *pp = a; pp < eee; pp += 4096)
+++     *pp = 1;
+++ 
+++-  lastaddr = (char*) (BIG-1);
++++  lastaddr = (char *)(BIG - 1);
+++   *lastaddr = 99;
+++ 
+++   // can one de-allocate?
+++   a = sbrk(0);
+++   c = sbrk(-PGSIZE);
+++-  if(c == (char*)0xffffffffffffffffL){
++++  if (c == (char *)0xffffffffffffffffL)
++++  {
+++     printf("%s: sbrk could not deallocate\n", s);
+++     exit(1);
+++   }
+++   c = sbrk(0);
+++-  if(c != a - PGSIZE){
++++  if (c != a - PGSIZE)
++++  {
+++     printf("%s: sbrk deallocation produced wrong address, a %p c %p\n", s, a, c);
+++     exit(1);
+++   }
+++@@ -2102,11 +2445,13 @@ sbrkmuch(char *s)
+++   // can one re-allocate that page?
+++   a = sbrk(0);
+++   c = sbrk(PGSIZE);
+++-  if(c != a || sbrk(0) != a + PGSIZE){
++++  if (c != a || sbrk(0) != a + PGSIZE)
++++  {
+++     printf("%s: sbrk re-allocation failed, a %p c %p\n", s, a, c);
+++     exit(1);
+++   }
+++-  if(*lastaddr == 99){
++++  if (*lastaddr == 99)
++++  {
+++     // should be zero
+++     printf("%s: sbrk de-allocation didn't really deallocate\n", s);
+++     exit(1);
+++@@ -2114,118 +2459,134 @@ sbrkmuch(char *s)
+++ 
+++   a = sbrk(0);
+++   c = sbrk(-(sbrk(0) - oldbrk));
+++-  if(c != a){
++++  if (c != a)
++++  {
+++     printf("%s: sbrk downsize failed, a %p c %p\n", s, a, c);
+++     exit(1);
+++   }
+++ }
+++ 
+++ // can we read the kernel's memory?
+++-void
+++-kernmem(char *s)
++++void kernmem(char *s)
+++ {
+++   char *a;
+++   int pid;
+++ 
+++-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
++++  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000)
++++  {
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid == 0){
++++    if (pid == 0)
++++    {
+++       printf("%s: oops could read %p = %x\n", s, a, *a);
+++       exit(1);
+++     }
+++     int xstatus;
+++     wait(&xstatus);
+++-    if(xstatus != -1)  // did kernel kill child?
++++    if (xstatus != -1) // did kernel kill child?
+++       exit(1);
+++   }
+++ }
+++ 
+++ // user code should not be able to write to addresses above MAXVA.
+++-void
+++-MAXVAplus(char *s)
++++void MAXVAplus(char *s)
+++ {
+++   volatile uint64 a = MAXVA;
+++-  for( ; a != 0; a <<= 1){
++++  for (; a != 0; a <<= 1)
++++  {
+++     int pid;
+++     pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++-    if(pid == 0){
+++-      *(char*)a = 99;
+++-      printf("%s: oops wrote %p\n", s, (void*)a);
++++    if (pid == 0)
++++    {
++++      *(char *)a = 99;
++++      printf("%s: oops wrote %p\n", s, (void *)a);
+++       exit(1);
+++     }
+++     int xstatus;
+++     wait(&xstatus);
+++-    if(xstatus != -1)  // did kernel kill child?
++++    if (xstatus != -1) // did kernel kill child?
+++       exit(1);
+++   }
+++ }
+++ 
+++ // if we run the system out of memory, does it clean up the last
+++ // failed allocation?
+++-void
+++-sbrkfail(char *s)
++++void sbrkfail(char *s)
+++ {
+++-  enum { BIG=100*1024*1024 };
++++  enum
++++  {
++++    BIG = 100 * 1024 * 1024
++++  };
+++   int i, xstatus;
+++   int fds[2];
+++   char scratch;
+++   char *c, *a;
+++   int pids[10];
+++   int pid;
+++- 
+++-  if(pipe(fds) != 0){
++++
++++  if (pipe(fds) != 0)
++++  {
+++     printf("%s: pipe() failed\n", s);
+++     exit(1);
+++   }
+++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+++-    if((pids[i] = fork()) == 0){
++++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
++++  {
++++    if ((pids[i] = fork()) == 0)
++++    {
+++       // allocate a lot of memory
+++       sbrk(BIG - (uint64)sbrk(0));
+++       write(fds[1], "x", 1);
+++       // sit around until killed
+++-      for(;;) sleep(1000);
++++      for (;;)
++++        sleep(1000);
+++     }
+++-    if(pids[i] != -1)
++++    if (pids[i] != -1)
+++       read(fds[0], &scratch, 1);
+++   }
+++ 
+++   // if those failed allocations freed up the pages they did allocate,
+++   // we'll be able to allocate here
+++   c = sbrk(PGSIZE);
+++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+++-    if(pids[i] == -1)
++++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
++++  {
++++    if (pids[i] == -1)
+++       continue;
+++     kill(pids[i]);
+++     wait(0);
+++   }
+++-  if(c == (char*)0xffffffffffffffffL){
++++  if (c == (char *)0xffffffffffffffffL)
++++  {
+++     printf("%s: failed sbrk leaked memory\n", s);
+++     exit(1);
+++   }
+++ 
+++-  // test running fork with the above allocated page 
++++  // test running fork with the above allocated page
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     // allocate a lot of memory.
+++     // this should produce a page fault,
+++     // and thus not complete.
+++     a = sbrk(0);
+++-    sbrk(10*BIG);
++++    sbrk(10 * BIG);
+++     int n = 0;
+++-    for (i = 0; i < 10*BIG; i += PGSIZE) {
+++-      n += *(a+i);
++++    for (i = 0; i < 10 * BIG; i += PGSIZE)
++++    {
++++      n += *(a + i);
+++     }
+++     // print n so the compiler doesn't optimize away
+++     // the for loop.
+++@@ -2233,26 +2594,26 @@ sbrkfail(char *s)
+++     exit(1);
+++   }
+++   wait(&xstatus);
+++-  if(xstatus != -1 && xstatus != 2)
++++  if (xstatus != -1 && xstatus != 2)
+++     exit(1);
+++ }
+++ 
+++-  
+++ // test reads/writes from/to allocated memory
+++-void
+++-sbrkarg(char *s)
++++void sbrkarg(char *s)
+++ {
+++   char *a;
+++   int fd, n;
+++ 
+++   a = sbrk(PGSIZE);
+++-  fd = open("sbrk", O_CREATE|O_WRONLY);
++++  fd = open("sbrk", O_CREATE | O_WRONLY);
+++   unlink("sbrk");
+++-  if(fd < 0)  {
++++  if (fd < 0)
++++  {
+++     printf("%s: open sbrk failed\n", s);
+++     exit(1);
+++   }
+++-  if ((n = write(fd, a, PGSIZE)) < 0) {
++++  if ((n = write(fd, a, PGSIZE)) < 0)
++++  {
+++     printf("%s: write sbrk failed\n", s);
+++     exit(1);
+++   }
+++@@ -2260,22 +2621,24 @@ sbrkarg(char *s)
+++ 
+++   // test writes to allocated memory
+++   a = sbrk(PGSIZE);
+++-  if(pipe((int *) a) != 0){
++++  if (pipe((int *)a) != 0)
++++  {
+++     printf("%s: pipe() failed\n", s);
+++     exit(1);
+++-  } 
++++  }
+++ }
+++ 
+++-void
+++-validatetest(char *s)
++++void validatetest(char *s)
+++ {
+++   int hi;
+++   uint64 p;
+++ 
+++-  hi = 1100*1024;
+++-  for(p = 0; p <= (uint)hi; p += PGSIZE){
++++  hi = 1100 * 1024;
++++  for (p = 0; p <= (uint)hi; p += PGSIZE)
++++  {
+++     // try to crash the kernel by passing in a bad string pointer
+++-    if(link("nosuchfile", (char*)p) != -1){
++++    if (link("nosuchfile", (char *)p) != -1)
++++    {
+++       printf("%s: link should not succeed\n", s);
+++       exit(1);
+++     }
+++@@ -2284,13 +2647,14 @@ validatetest(char *s)
+++ 
+++ // does uninitialized data start out zero?
+++ char uninit[10000];
+++-void
+++-bsstest(char *s)
++++void bsstest(char *s)
+++ {
+++   int i;
+++ 
+++-  for(i = 0; i < sizeof(uninit); i++){
+++-    if(uninit[i] != '\0'){
++++  for (i = 0; i < sizeof(uninit); i++)
++++  {
++++    if (uninit[i] != '\0')
++++    {
+++       printf("%s: bss test failed\n", s);
+++       exit(1);
+++     }
+++@@ -2300,38 +2664,41 @@ bsstest(char *s)
+++ // does exec return an error if the arguments
+++ // are larger than a page? or does it write
+++ // below the stack and wreck the instructions/data?
+++-void
+++-bigargtest(char *s)
++++void bigargtest(char *s)
+++ {
+++   int pid, fd, xstatus;
+++ 
+++   unlink("bigarg-ok");
+++   pid = fork();
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     static char *args[MAXARG];
+++     int i;
+++     char big[400];
+++     memset(big, ' ', sizeof(big));
+++-    big[sizeof(big)-1] = '\0';
+++-    for(i = 0; i < MAXARG-1; i++)
++++    big[sizeof(big) - 1] = '\0';
++++    for (i = 0; i < MAXARG - 1; i++)
+++       args[i] = big;
+++-    args[MAXARG-1] = 0;
++++    args[MAXARG - 1] = 0;
+++     // this exec() should fail (and return) because the
+++     // arguments are too large.
+++     exec("echo", args);
+++     fd = open("bigarg-ok", O_CREATE);
+++     close(fd);
+++     exit(0);
+++-  } else if(pid < 0){
++++  }
++++  else if (pid < 0)
++++  {
+++     printf("%s: bigargtest: fork failed\n", s);
+++     exit(1);
+++   }
+++-  
++++
+++   wait(&xstatus);
+++-  if(xstatus != 0)
++++  if (xstatus != 0)
+++     exit(xstatus);
+++   fd = open("bigarg-ok", 0);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: bigarg test failed!\n", s);
+++     exit(1);
+++   }
+++@@ -2340,15 +2707,15 @@ bigargtest(char *s)
+++ 
+++ // what happens when the file system runs out of blocks?
+++ // answer: balloc panics, so this test is not useful.
+++-void
+++-fsfull()
++++void fsfull()
+++ {
+++   int nfiles;
+++   int fsblocks = 0;
+++ 
+++   printf("fsfull test\n");
+++ 
+++-  for(nfiles = 0; ; nfiles++){
++++  for (nfiles = 0;; nfiles++)
++++  {
+++     char name[64];
+++     name[0] = 'f';
+++     name[1] = '0' + nfiles / 1000;
+++@@ -2357,26 +2724,29 @@ fsfull()
+++     name[4] = '0' + (nfiles % 10);
+++     name[5] = '\0';
+++     printf("writing %s\n", name);
+++-    int fd = open(name, O_CREATE|O_RDWR);
+++-    if(fd < 0){
++++    int fd = open(name, O_CREATE | O_RDWR);
++++    if (fd < 0)
++++    {
+++       printf("open %s failed\n", name);
+++       break;
+++     }
+++     int total = 0;
+++-    while(1){
++++    while (1)
++++    {
+++       int cc = write(fd, buf, BSIZE);
+++-      if(cc < BSIZE)
++++      if (cc < BSIZE)
+++         break;
+++       total += cc;
+++       fsblocks++;
+++     }
+++     printf("wrote %d bytes\n", total);
+++     close(fd);
+++-    if(total == 0)
++++    if (total == 0)
+++       break;
+++   }
+++ 
+++-  while(nfiles >= 0){
++++  while (nfiles >= 0)
++++  {
+++     char name[64];
+++     name[0] = 'f';
+++     name[1] = '0' + nfiles / 1000;
+++@@ -2395,7 +2765,8 @@ void argptest(char *s)
+++ {
+++   int fd;
+++   fd = open("init", O_RDONLY);
+++-  if (fd < 0) {
++++  if (fd < 0)
++++  {
+++     printf("%s: open failed\n", s);
+++     exit(1);
+++   }
+++@@ -2405,25 +2776,27 @@ void argptest(char *s)
+++ 
+++ // check that there's an invalid page beneath
+++ // the user stack, to catch stack overflow.
+++-void
+++-stacktest(char *s)
++++void stacktest(char *s)
+++ {
+++   int pid;
+++   int xstatus;
+++-  
++++
+++   pid = fork();
+++-  if(pid == 0) {
+++-    char *sp = (char *) r_sp();
+++-    sp -= USERSTACK*PGSIZE;
++++  if (pid == 0)
++++  {
++++    char *sp = (char *)r_sp();
++++    sp -= USERSTACK * PGSIZE;
+++     // the *sp should cause a trap.
+++     printf("%s: stacktest: read below stack %d\n", s, *sp);
+++     exit(1);
+++-  } else if(pid < 0){
++++  }
++++  else if (pid < 0)
++++  {
+++     printf("%s: fork failed\n", s);
+++     exit(1);
+++   }
+++   wait(&xstatus);
+++-  if(xstatus == -1)  // kernel killed child?
++++  if (xstatus == -1) // kernel killed child?
+++     exit(0);
+++   else
+++     exit(xstatus);
+++@@ -2431,27 +2804,31 @@ stacktest(char *s)
+++ 
+++ // check that writes to a few forbidden addresses
+++ // cause a fault, e.g. process's text and TRAMPOLINE.
+++-void
+++-nowrite(char *s)
++++void nowrite(char *s)
+++ {
+++   int pid;
+++   int xstatus;
+++-  uint64 addrs[] = { 0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++-                     0xffffffffffffffff };
+++-  
+++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++++  uint64 addrs[] = {0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++++                    0xffffffffffffffff};
++++
++++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++++  {
+++     pid = fork();
+++-    if(pid == 0) {
+++-      volatile int *addr = (int *) addrs[ai];
++++    if (pid == 0)
++++    {
++++      volatile int *addr = (int *)addrs[ai];
+++       *addr = 10;
+++       printf("%s: write to %p did not fail!\n", s, addr);
+++       exit(0);
+++-    } else if(pid < 0){
++++    }
++++    else if (pid < 0)
++++    {
+++       printf("%s: fork failed\n", s);
+++       exit(1);
+++     }
+++     wait(&xstatus);
+++-    if(xstatus == 0){
++++    if (xstatus == 0)
++++    {
+++       // kernel did not kill child!
+++       exit(1);
+++     }
+++@@ -2462,9 +2839,8 @@ nowrite(char *s)
+++ // regression test. copyin(), copyout(), and copyinstr() used to cast
+++ // the virtual page address to uint, which (with certain wild system
+++ // call arguments) resulted in a kernel page faults.
+++-void *big = (void*) 0xeaeb0b5b00002f5e;
+++-void
+++-pgbug(char *s)
++++void *big = (void *)0xeaeb0b5b00002f5e;
++++void pgbug(char *s)
+++ {
+++   char *argv[1];
+++   argv[0] = 0;
+++@@ -2477,16 +2853,17 @@ pgbug(char *s)
+++ // regression test. does the kernel panic if a process sbrk()s its
+++ // size to be less than a page, or zero, or reduces the break by an
+++ // amount too small to cause a page to be freed?
+++-void
+++-sbrkbugs(char *s)
++++void sbrkbugs(char *s)
+++ {
+++   int pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed\n");
+++     exit(1);
+++   }
+++-  if(pid == 0){
+++-    int sz = (uint64) sbrk(0);
++++  if (pid == 0)
++++  {
++++    int sz = (uint64)sbrk(0);
+++     // free all user memory; there used to be a bug that
+++     // would not adjust p->sz correctly in this case,
+++     // causing exit() to panic.
+++@@ -2497,12 +2874,14 @@ sbrkbugs(char *s)
+++   wait(0);
+++ 
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed\n");
+++     exit(1);
+++   }
+++-  if(pid == 0){
+++-    int sz = (uint64) sbrk(0);
++++  if (pid == 0)
++++  {
++++    int sz = (uint64)sbrk(0);
+++     // set the break to somewhere in the very first
+++     // page; there used to be a bug that would incorrectly
+++     // free the first page.
+++@@ -2512,13 +2891,15 @@ sbrkbugs(char *s)
+++   wait(0);
+++ 
+++   pid = fork();
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed\n");
+++     exit(1);
+++   }
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     // set the break in the middle of a page.
+++-    sbrk((10*4096 + 2048) - (uint64)sbrk(0));
++++    sbrk((10 * 4096 + 2048) - (uint64)sbrk(0));
+++ 
+++     // reduce the break a bit, but not enough to
+++     // cause a page to be freed. this used to cause
+++@@ -2535,123 +2916,119 @@ sbrkbugs(char *s)
+++ // if process size was somewhat more than a page boundary, and then
+++ // shrunk to be somewhat less than that page boundary, can the kernel
+++ // still copyin() from addresses in the last page?
+++-void
+++-sbrklast(char *s)
++++void sbrklast(char *s)
+++ {
+++-  uint64 top = (uint64) sbrk(0);
+++-  if((top % 4096) != 0)
++++  uint64 top = (uint64)sbrk(0);
++++  if ((top % 4096) != 0)
+++     sbrk(4096 - (top % 4096));
+++   sbrk(4096);
+++   sbrk(10);
+++   sbrk(-20);
+++-  top = (uint64) sbrk(0);
+++-  char *p = (char *) (top - 64);
++++  top = (uint64)sbrk(0);
++++  char *p = (char *)(top - 64);
+++   p[0] = 'x';
+++   p[1] = '\0';
+++-  int fd = open(p, O_RDWR|O_CREATE);
++++  int fd = open(p, O_RDWR | O_CREATE);
+++   write(fd, p, 1);
+++   close(fd);
+++   fd = open(p, O_RDWR);
+++   p[0] = '\0';
+++   read(fd, p, 1);
+++-  if(p[0] != 'x')
++++  if (p[0] != 'x')
+++     exit(1);
+++ }
+++ 
+++-
+++ // does sbrk handle signed int32 wrap-around with
+++ // negative arguments?
+++-void
+++-sbrk8000(char *s)
++++void sbrk8000(char *s)
+++ {
+++   sbrk(0x80000004);
+++   volatile char *top = sbrk(0);
+++-  *(top-1) = *(top-1) + 1;
++++  *(top - 1) = *(top - 1) + 1;
+++ }
+++ 
+++-
+++-
+++ // regression test. test whether exec() leaks memory if one of the
+++ // arguments is invalid. the test passes if the kernel doesn't panic.
+++-void
+++-badarg(char *s)
++++void badarg(char *s)
+++ {
+++-  for(int i = 0; i < 50000; i++){
++++  for (int i = 0; i < 50000; i++)
++++  {
+++     char *argv[2];
+++-    argv[0] = (char*)0xffffffff;
++++    argv[0] = (char *)0xffffffff;
+++     argv[1] = 0;
+++     exec("echo", argv);
+++   }
+++-  
++++
+++   exit(0);
+++ }
+++ 
+++-struct test {
++++struct test
++++{
+++   void (*f)(char *);
+++   char *s;
+++ } quicktests[] = {
+++-  {copyin, "copyin"},
+++-  {copyout, "copyout"},
+++-  {copyinstr1, "copyinstr1"},
+++-  {copyinstr2, "copyinstr2"},
+++-  {copyinstr3, "copyinstr3"},
+++-  {rwsbrk, "rwsbrk" },
+++-  {truncate1, "truncate1"},
+++-  {truncate2, "truncate2"},
+++-  {truncate3, "truncate3"},
+++-  {openiputtest, "openiput"},
+++-  {exitiputtest, "exitiput"},
+++-  {iputtest, "iput"},
+++-  {opentest, "opentest"},
+++-  {writetest, "writetest"},
+++-  {writebig, "writebig"},
+++-  {createtest, "createtest"},
+++-  {dirtest, "dirtest"},
+++-  {exectest, "exectest"},
+++-  {pipe1, "pipe1"},
+++-  {killstatus, "killstatus"},
+++-  {preempt, "preempt"},
+++-  {exitwait, "exitwait"},
+++-  {reparent, "reparent" },
+++-  {twochildren, "twochildren"},
+++-  {forkfork, "forkfork"},
+++-  {forkforkfork, "forkforkfork"},
+++-  {reparent2, "reparent2"},
+++-  {mem, "mem"},
+++-  {sharedfd, "sharedfd"},
+++-  {fourfiles, "fourfiles"},
+++-  {createdelete, "createdelete"},
+++-  {unlinkread, "unlinkread"},
+++-  {linktest, "linktest"},
+++-  {concreate, "concreate"},
+++-  {linkunlink, "linkunlink"},
+++-  {subdir, "subdir"},
+++-  {bigwrite, "bigwrite"},
+++-  {bigfile, "bigfile"},
+++-  {fourteen, "fourteen"},
+++-  {rmdot, "rmdot"},
+++-  {dirfile, "dirfile"},
+++-  {iref, "iref"},
+++-  {forktest, "forktest"},
+++-  {sbrkbasic, "sbrkbasic"},
+++-  {sbrkmuch, "sbrkmuch"},
+++-  {kernmem, "kernmem"},
+++-  {MAXVAplus, "MAXVAplus"},
+++-  {sbrkfail, "sbrkfail"},
+++-  {sbrkarg, "sbrkarg"},
+++-  {validatetest, "validatetest"},
+++-  {bsstest, "bsstest"},
+++-  {bigargtest, "bigargtest"},
+++-  {argptest, "argptest"},
+++-  {stacktest, "stacktest"},
+++-  {nowrite, "nowrite"},
+++-  {pgbug, "pgbug" },
+++-  {sbrkbugs, "sbrkbugs" },
+++-  {sbrklast, "sbrklast"},
+++-  {sbrk8000, "sbrk8000"},
+++-  {badarg, "badarg" },
+++-
+++-  { 0, 0},
++++    {copyin, "copyin"},
++++    {copyout, "copyout"},
++++    {copyinstr1, "copyinstr1"},
++++    {copyinstr2, "copyinstr2"},
++++    {copyinstr3, "copyinstr3"},
++++    {rwsbrk, "rwsbrk"},
++++    {truncate1, "truncate1"},
++++    {truncate2, "truncate2"},
++++    {truncate3, "truncate3"},
++++    {openiputtest, "openiput"},
++++    {exitiputtest, "exitiput"},
++++    {iputtest, "iput"},
++++    {opentest, "opentest"},
++++    {writetest, "writetest"},
++++    {writebig, "writebig"},
++++    {createtest, "createtest"},
++++    {dirtest, "dirtest"},
++++    {exectest, "exectest"},
++++    {pipe1, "pipe1"},
++++    {killstatus, "killstatus"},
++++    {preempt, "preempt"},
++++    {exitwait, "exitwait"},
++++    {reparent, "reparent"},
++++    {twochildren, "twochildren"},
++++    {forkfork, "forkfork"},
++++    {forkforkfork, "forkforkfork"},
++++    {reparent2, "reparent2"},
++++    {mem, "mem"},
++++    {sharedfd, "sharedfd"},
++++    {fourfiles, "fourfiles"},
++++    {createdelete, "createdelete"},
++++    {unlinkread, "unlinkread"},
++++    {linktest, "linktest"},
++++    {concreate, "concreate"},
++++    {linkunlink, "linkunlink"},
++++    {subdir, "subdir"},
++++    {bigwrite, "bigwrite"},
++++    {bigfile, "bigfile"},
++++    {fourteen, "fourteen"},
++++    {rmdot, "rmdot"},
++++    {dirfile, "dirfile"},
++++    {iref, "iref"},
++++    {forktest, "forktest"},
++++    {sbrkbasic, "sbrkbasic"},
++++    {sbrkmuch, "sbrkmuch"},
++++    {kernmem, "kernmem"},
++++    {MAXVAplus, "MAXVAplus"},
++++    {sbrkfail, "sbrkfail"},
++++    {sbrkarg, "sbrkarg"},
++++    {validatetest, "validatetest"},
++++    {bsstest, "bsstest"},
++++    {bigargtest, "bigargtest"},
++++    {argptest, "argptest"},
++++    {stacktest, "stacktest"},
++++    {nowrite, "nowrite"},
++++    {pgbug, "pgbug"},
++++    {sbrkbugs, "sbrkbugs"},
++++    {sbrklast, "sbrklast"},
++++    {sbrk8000, "sbrk8000"},
++++    {badarg, "badarg"},
++++
++++    {0, 0},
+++ };
+++ 
+++ //
+++@@ -2659,40 +3036,47 @@ struct test {
+++ //
+++ 
+++ // directory that uses indirect blocks
+++-void
+++-bigdir(char *s)
++++void bigdir(char *s)
+++ {
+++-  enum { N = 500 };
++++  enum
++++  {
++++    N = 500
++++  };
+++   int i, fd;
+++   char name[10];
+++ 
+++   unlink("bd");
+++ 
+++   fd = open("bd", O_CREATE);
+++-  if(fd < 0){
++++  if (fd < 0)
++++  {
+++     printf("%s: bigdir create failed\n", s);
+++     exit(1);
+++   }
+++   close(fd);
+++ 
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     name[0] = 'x';
+++     name[1] = '0' + (i / 64);
+++     name[2] = '0' + (i % 64);
+++     name[3] = '\0';
+++-    if(link("bd", name) != 0){
++++    if (link("bd", name) != 0)
++++    {
+++       printf("%s: bigdir i=%d link(bd, %s) failed\n", s, i, name);
+++       exit(1);
+++     }
+++   }
+++ 
+++   unlink("bd");
+++-  for(i = 0; i < N; i++){
++++  for (i = 0; i < N; i++)
++++  {
+++     name[0] = 'x';
+++     name[1] = '0' + (i / 64);
+++     name[2] = '0' + (i % 64);
+++     name[3] = '\0';
+++-    if(unlink(name) != 0){
++++    if (unlink(name) != 0)
++++    {
+++       printf("%s: bigdir unlink failed", s);
+++       exit(1);
+++     }
+++@@ -2701,36 +3085,42 @@ bigdir(char *s)
+++ 
+++ // concurrent writes to try to provoke deadlock in the virtio disk
+++ // driver.
+++-void
+++-manywrites(char *s)
++++void manywrites(char *s)
+++ {
+++   int nchildren = 4;
+++   int howmany = 30; // increase to look for deadlock
+++-  
+++-  for(int ci = 0; ci < nchildren; ci++){
++++
++++  for (int ci = 0; ci < nchildren; ci++)
++++  {
+++     int pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("fork failed\n");
+++       exit(1);
+++     }
+++ 
+++-    if(pid == 0){
++++    if (pid == 0)
++++    {
+++       char name[3];
+++       name[0] = 'b';
+++       name[1] = 'a' + ci;
+++       name[2] = '\0';
+++       unlink(name);
+++-      
+++-      for(int iters = 0; iters < howmany; iters++){
+++-        for(int i = 0; i < ci+1; i++){
++++
++++      for (int iters = 0; iters < howmany; iters++)
++++      {
++++        for (int i = 0; i < ci + 1; i++)
++++        {
+++           int fd = open(name, O_CREATE | O_RDWR);
+++-          if(fd < 0){
++++          if (fd < 0)
++++          {
+++             printf("%s: cannot create %s\n", s, name);
+++             exit(1);
+++           }
+++           int sz = sizeof(buf);
+++           int cc = write(fd, buf, sz);
+++-          if(cc != sz){
++++          if (cc != sz)
++++          {
+++             printf("%s: write(%d) ret %d\n", s, sz, cc);
+++             exit(1);
+++           }
+++@@ -2744,10 +3134,11 @@ manywrites(char *s)
+++     }
+++   }
+++ 
+++-  for(int ci = 0; ci < nchildren; ci++){
++++  for (int ci = 0; ci < nchildren; ci++)
++++  {
+++     int st = 0;
+++     wait(&st);
+++-    if(st != 0)
++++    if (st != 0)
+++       exit(st);
+++   }
+++   exit(0);
+++@@ -2758,29 +3149,32 @@ manywrites(char *s)
+++ // file is deleted? if the kernel has this bug, it will panic: balloc:
+++ // out of blocks. assumed_free may need to be raised to be more than
+++ // the number of free blocks. this test takes a long time.
+++-void
+++-badwrite(char *s)
++++void badwrite(char *s)
+++ {
+++   int assumed_free = 600;
+++-  
++++
+++   unlink("junk");
+++-  for(int i = 0; i < assumed_free; i++){
+++-    int fd = open("junk", O_CREATE|O_WRONLY);
+++-    if(fd < 0){
++++  for (int i = 0; i < assumed_free; i++)
++++  {
++++    int fd = open("junk", O_CREATE | O_WRONLY);
++++    if (fd < 0)
++++    {
+++       printf("open junk failed\n");
+++       exit(1);
+++     }
+++-    write(fd, (char*)0xffffffffffL, 1);
++++    write(fd, (char *)0xffffffffffL, 1);
+++     close(fd);
+++     unlink("junk");
+++   }
+++ 
+++-  int fd = open("junk", O_CREATE|O_WRONLY);
+++-  if(fd < 0){
++++  int fd = open("junk", O_CREATE | O_WRONLY);
++++  if (fd < 0)
++++  {
+++     printf("open junk failed\n");
+++     exit(1);
+++   }
+++-  if(write(fd, "x", 1) != 1){
++++  if (write(fd, "x", 1) != 1)
++++  {
+++     printf("write failed\n");
+++     exit(1);
+++   }
+++@@ -2793,34 +3187,40 @@ badwrite(char *s)
+++ // test the exec() code that cleans up if it runs out
+++ // of memory. it's really a test that such a condition
+++ // doesn't cause a panic.
+++-void
+++-execout(char *s)
++++void execout(char *s)
+++ {
+++-  for(int avail = 0; avail < 15; avail++){
++++  for (int avail = 0; avail < 15; avail++)
++++  {
+++     int pid = fork();
+++-    if(pid < 0){
++++    if (pid < 0)
++++    {
+++       printf("fork failed\n");
+++       exit(1);
+++-    } else if(pid == 0){
++++    }
++++    else if (pid == 0)
++++    {
+++       // allocate all of memory.
+++-      while(1){
+++-        uint64 a = (uint64) sbrk(4096);
+++-        if(a == 0xffffffffffffffffLL)
++++      while (1)
++++      {
++++        uint64 a = (uint64)sbrk(4096);
++++        if (a == 0xffffffffffffffffLL)
+++           break;
+++-        *(char*)(a + 4096 - 1) = 1;
++++        *(char *)(a + 4096 - 1) = 1;
+++       }
+++ 
+++       // free a few pages, in order to let exec() make some
+++       // progress.
+++-      for(int i = 0; i < avail; i++)
++++      for (int i = 0; i < avail; i++)
+++         sbrk(-4096);
+++-      
++++
+++       close(1);
+++-      char *args[] = { "echo", "x", 0 };
++++      char *args[] = {"echo", "x", 0};
+++       exec("echo", args);
+++       exit(0);
+++-    } else {
+++-      wait((int*)0);
++++    }
++++    else
++++    {
++++      wait((int *)0);
+++     }
+++   }
+++ 
+++@@ -2828,15 +3228,15 @@ execout(char *s)
+++ }
+++ 
+++ // can the kernel tolerate running out of disk space?
+++-void
+++-diskfull(char *s)
++++void diskfull(char *s)
+++ {
+++   int fi;
+++   int done = 0;
+++ 
+++   unlink("diskfulldir");
+++-  
+++-  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
++++
++++  for (fi = 0; done == 0 && '0' + fi < 0177; fi++)
++++  {
+++     char name[32];
+++     name[0] = 'b';
+++     name[1] = 'i';
+++@@ -2844,16 +3244,19 @@ diskfull(char *s)
+++     name[3] = '0' + fi;
+++     name[4] = '\0';
+++     unlink(name);
+++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+++-    if(fd < 0){
++++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++++    if (fd < 0)
++++    {
+++       // oops, ran out of inodes before running out of blocks.
+++       printf("%s: could not create file %s\n", s, name);
+++       done = 1;
+++       break;
+++     }
+++-    for(int i = 0; i < MAXFILE; i++){
++++    for (int i = 0; i < MAXFILE; i++)
++++    {
+++       char buf[BSIZE];
+++-      if(write(fd, buf, BSIZE) != BSIZE){
++++      if (write(fd, buf, BSIZE) != BSIZE)
++++      {
+++         done = 1;
+++         close(fd);
+++         break;
+++@@ -2867,7 +3270,8 @@ diskfull(char *s)
+++   // directory content. one of these file creations
+++   // is expected to fail.
+++   int nzz = 128;
+++-  for(int i = 0; i < nzz; i++){
++++  for (int i = 0; i < nzz; i++)
++++  {
+++     char name[32];
+++     name[0] = 'z';
+++     name[1] = 'z';
+++@@ -2875,19 +3279,20 @@ diskfull(char *s)
+++     name[3] = '0' + (i % 32);
+++     name[4] = '\0';
+++     unlink(name);
+++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+++-    if(fd < 0)
++++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++++    if (fd < 0)
+++       break;
+++     close(fd);
+++   }
+++ 
+++   // this mkdir() is expected to fail.
+++-  if(mkdir("diskfulldir") == 0)
++++  if (mkdir("diskfulldir") == 0)
+++     printf("%s: mkdir(diskfulldir) unexpectedly succeeded!\n", s);
+++ 
+++   unlink("diskfulldir");
+++ 
+++-  for(int i = 0; i < nzz; i++){
++++  for (int i = 0; i < nzz; i++)
++++  {
+++     char name[32];
+++     name[0] = 'z';
+++     name[1] = 'z';
+++@@ -2897,7 +3302,8 @@ diskfull(char *s)
+++     unlink(name);
+++   }
+++ 
+++-  for(int i = 0; '0' + i < 0177; i++){
++++  for (int i = 0; '0' + i < 0177; i++)
++++  {
+++     char name[32];
+++     name[0] = 'b';
+++     name[1] = 'i';
+++@@ -2908,11 +3314,11 @@ diskfull(char *s)
+++   }
+++ }
+++ 
+++-void
+++-outofinodes(char *s)
++++void outofinodes(char *s)
+++ {
+++-  int nzz = 32*32;
+++-  for(int i = 0; i < nzz; i++){
++++  int nzz = 32 * 32;
++++  for (int i = 0; i < nzz; i++)
++++  {
+++     char name[32];
+++     name[0] = 'z';
+++     name[1] = 'z';
+++@@ -2920,15 +3326,17 @@ outofinodes(char *s)
+++     name[3] = '0' + (i % 32);
+++     name[4] = '\0';
+++     unlink(name);
+++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+++-    if(fd < 0){
++++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++++    if (fd < 0)
++++    {
+++       // failure is eventually expected.
+++       break;
+++     }
+++     close(fd);
+++   }
+++ 
+++-  for(int i = 0; i < nzz; i++){
++++  for (int i = 0; i < nzz; i++)
++++  {
+++     char name[32];
+++     name[0] = 'z';
+++     name[1] = 'z';
+++@@ -2940,14 +3348,14 @@ outofinodes(char *s)
+++ }
+++ 
+++ struct test slowtests[] = {
+++-  {bigdir, "bigdir"},
+++-  {manywrites, "manywrites"},
+++-  {badwrite, "badwrite" },
+++-  {execout, "execout"},
+++-  {diskfull, "diskfull"},
+++-  {outofinodes, "outofinodes"},
+++-    
+++-  { 0, 0},
++++    {bigdir, "bigdir"},
++++    {manywrites, "manywrites"},
++++    {badwrite, "badwrite"},
++++    {execout, "execout"},
++++    {diskfull, "diskfull"},
++++    {outofinodes, "outofinodes"},
++++
++++    {0, 0},
+++ };
+++ 
+++ //
+++@@ -2956,22 +3364,26 @@ struct test slowtests[] = {
+++ 
+++ // run each test in its own process. run returns 1 if child's exit()
+++ // indicates success.
+++-int
+++-run(void f(char *), char *s) {
++++int run(void f(char *), char *s)
++++{
+++   int pid;
+++   int xstatus;
+++ 
+++   printf("test %s: ", s);
+++-  if((pid = fork()) < 0) {
++++  if ((pid = fork()) < 0)
++++  {
+++     printf("runtest: fork error\n");
+++     exit(1);
+++   }
+++-  if(pid == 0) {
++++  if (pid == 0)
++++  {
+++     f(s);
+++     exit(0);
+++-  } else {
++++  }
++++  else
++++  {
+++     wait(&xstatus);
+++-    if(xstatus != 0) 
++++    if (xstatus != 0)
+++       printf("FAILED\n");
+++     else
+++       printf("OK\n");
+++@@ -2979,12 +3391,16 @@ run(void f(char *), char *s) {
+++   }
+++ }
+++ 
+++-int
+++-runtests(struct test *tests, char *justone, int continuous) {
+++-  for (struct test *t = tests; t->s != 0; t++) {
+++-    if((justone == 0) || strcmp(t->s, justone) == 0) {
+++-      if(!run(t->f, t->s)){
+++-        if(continuous != 2){
++++int runtests(struct test *tests, char *justone, int continuous)
++++{
++++  for (struct test *t = tests; t->s != 0; t++)
++++  {
++++    if ((justone == 0) || strcmp(t->s, justone) == 0)
++++    {
++++      if (!run(t->f, t->s))
++++      {
++++        if (continuous != 2)
++++        {
+++           printf("SOME TESTS FAILED\n");
+++           return 1;
+++         }
+++@@ -2994,36 +3410,39 @@ runtests(struct test *tests, char *justone, int continuous) {
+++   return 0;
+++ }
+++ 
+++-
+++ //
+++ // use sbrk() to count how many free physical memory pages there are.
+++ // touches the pages to force allocation.
+++ // because out of memory with lazy allocation results in the process
+++ // taking a fault and being killed, fork and report back.
+++ //
+++-int
+++-countfree()
++++int countfree()
+++ {
+++   int fds[2];
+++ 
+++-  if(pipe(fds) < 0){
++++  if (pipe(fds) < 0)
++++  {
+++     printf("pipe() failed in countfree()\n");
+++     exit(1);
+++   }
+++-  
++++
+++   int pid = fork();
+++ 
+++-  if(pid < 0){
++++  if (pid < 0)
++++  {
+++     printf("fork failed in countfree()\n");
+++     exit(1);
+++   }
+++ 
+++-  if(pid == 0){
++++  if (pid == 0)
++++  {
+++     close(fds[0]);
+++-    
+++-    while(1){
+++-      uint64 a = (uint64) sbrk(4096);
+++-      if(a == 0xffffffffffffffff){
++++
++++    while (1)
++++    {
++++      uint64 a = (uint64)sbrk(4096);
++++      if (a == 0xffffffffffffffff)
++++      {
+++         break;
+++       }
+++ 
+++@@ -3031,7 +3450,8 @@ countfree()
+++       *(char *)(a + 4096 - 1) = 1;
+++ 
+++       // report back one more page.
+++-      if(write(fds[1], "x", 1) != 1){
++++      if (write(fds[1], "x", 1) != 1)
++++      {
+++         printf("write() failed in countfree()\n");
+++         exit(1);
+++       }
+++@@ -3043,74 +3463,93 @@ countfree()
+++   close(fds[1]);
+++ 
+++   int n = 0;
+++-  while(1){
++++  while (1)
++++  {
+++     char c;
+++     int cc = read(fds[0], &c, 1);
+++-    if(cc < 0){
++++    if (cc < 0)
++++    {
+++       printf("read() failed in countfree()\n");
+++       exit(1);
+++     }
+++-    if(cc == 0)
++++    if (cc == 0)
+++       break;
+++     n += 1;
+++   }
+++ 
+++   close(fds[0]);
+++-  wait((int*)0);
+++-  
++++  wait((int *)0);
++++
+++   return n;
+++ }
+++ 
+++-int
+++-drivetests(int quick, int continuous, char *justone) {
+++-  do {
++++int drivetests(int quick, int continuous, char *justone)
++++{
++++  do
++++  {
+++     printf("usertests starting\n");
+++     int free0 = countfree();
+++     int free1 = 0;
+++-    if (runtests(quicktests, justone, continuous)) {
+++-      if(continuous != 2) {
++++    if (runtests(quicktests, justone, continuous))
++++    {
++++      if (continuous != 2)
++++      {
+++         return 1;
+++       }
+++     }
+++-    if(!quick) {
++++    if (!quick)
++++    {
+++       if (justone == 0)
+++         printf("usertests slow tests starting\n");
+++-      if (runtests(slowtests, justone, continuous)) {
+++-        if(continuous != 2) {
++++      if (runtests(slowtests, justone, continuous))
++++      {
++++        if (continuous != 2)
++++        {
+++           return 1;
+++         }
+++       }
+++     }
+++-    if((free1 = countfree()) < free0) {
++++    if ((free1 = countfree()) < free0)
++++    {
+++       printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
+++-      if(continuous != 2) {
++++      if (continuous != 2)
++++      {
+++         return 1;
+++       }
+++     }
+++-  } while(continuous);
++++  } while (continuous);
+++   return 0;
+++ }
+++ 
+++-int
+++-main(int argc, char *argv[])
++++int main(int argc, char *argv[])
+++ {
+++   int continuous = 0;
+++   int quick = 0;
+++   char *justone = 0;
+++ 
+++-  if(argc == 2 && strcmp(argv[1], "-q") == 0){
++++  if (argc == 2 && strcmp(argv[1], "-q") == 0)
++++  {
+++     quick = 1;
+++-  } else if(argc == 2 && strcmp(argv[1], "-c") == 0){
++++  }
++++  else if (argc == 2 && strcmp(argv[1], "-c") == 0)
++++  {
+++     continuous = 1;
+++-  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
++++  }
++++  else if (argc == 2 && strcmp(argv[1], "-C") == 0)
++++  {
+++     continuous = 2;
+++-  } else if(argc == 2 && argv[1][0] != '-'){
++++  }
++++  else if (argc == 2 && argv[1][0] != '-')
++++  {
+++     justone = argv[1];
+++-  } else if(argc > 1){
++++  }
++++  else if (argc > 1)
++++  {
+++     printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
+++     exit(1);
+++   }
+++-  if (drivetests(quick, continuous, justone)) {
++++  if (drivetests(quick, continuous, justone))
++++  {
+++     exit(1);
+++   }
+++   printf("ALL TESTS PASSED\n");
+++diff --git a/offline_2/xv6-riscv-riscv/user/usys.pl b/offline_2/xv6-riscv-riscv/user/usys.pl
+++index 01e426e..9d54e5b 100755
+++--- a/offline_2/xv6-riscv-riscv/user/usys.pl
++++++ b/offline_2/xv6-riscv-riscv/user/usys.pl
+++@@ -36,3 +36,4 @@ entry("getpid");
+++ entry("sbrk");
+++ entry("sleep");
+++ entry("uptime");
++++entry("history");
++diff --git a/offline_2/xv6-riscv-riscv/user/history.c b/offline_2/xv6-riscv-riscv/user/history.c
++new file mode 100644
++index 0000000..54e980a
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/user/history.c
++@@ -0,0 +1,47 @@
+++#include "kernel/types.h"
+++#include "kernel/stat.h"
+++#include "user/user.h"
+++#include "kernel/syscall.h"
+++#include "kernel/syscall_stat.h"
+++
+++void print_history(int syscall_num)
+++{
+++    struct syscall_stat s_stat;
+++
+++    if (history(syscall_num, &s_stat) == 0)
+++    {
+++        printf("%d: syscall: %s, #: %d, time: %d\n",
+++               syscall_num,
+++               s_stat.syscall_name,
+++               s_stat.count,
+++               s_stat.accum_time);
+++    }
+++    else
+++    {
+++        printf("Error fetching history for syscall %d\n", syscall_num);
+++    }
+++}
+++
+++int main(int argc, char *argv[])
+++{
+++    if (argc < 2)
+++    {
+++        // No arguments, print all
+++        for (int i = 1; i <= 24; i++)
+++            print_history(i);
+++    }
+++    else
+++    {
+++        int syscall_num = atoi(argv[1]);
+++        if (syscall_num > 0)
+++        {
+++            print_history(syscall_num);
+++        }
+++        else
+++        {
+++            printf("Invalid syscall number.\n");
+++        }
+++    }
+++
+++    exit(0);
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/user/user.h b/offline_2/xv6-riscv-riscv/user/user.h
++index f16fe27..1cb3ac8 100644
++--- a/offline_2/xv6-riscv-riscv/user/user.h
+++++ b/offline_2/xv6-riscv-riscv/user/user.h
++@@ -1,5 +1,5 @@
++ struct stat;
++-
+++struct syscall_stat;
++ // system calls
++ int fork(void);
++ int exit(int) __attribute__((noreturn));
++@@ -22,6 +22,7 @@ int getpid(void);
++ char* sbrk(int);
++ int sleep(int);
++ int uptime(void);
+++int history(int, struct syscall_stat*);
++ 
++ // ulib.c
++ int stat(const char*, struct stat*);
++diff --git a/offline_2/xv6-riscv-riscv/user/usertests.c b/offline_2/xv6-riscv-riscv/user/usertests.c
++index 28b53f9..4273164 100644
++--- a/offline_2/xv6-riscv-riscv/user/usertests.c
+++++ b/offline_2/xv6-riscv-riscv/user/usertests.c
++@@ -17,7 +17,7 @@
++ // prints "OK".
++ //
++ 
++-#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
+++#define BUFSZ ((MAXOPBLOCKS + 2) * BSIZE)
++ 
++ char buf[BUFSZ];
++ 
++@@ -29,42 +29,47 @@ char buf[BUFSZ];
++ 
++ // what if you pass ridiculous pointers to system calls
++ // that read user memory with copyin?
++-void
++-copyin(char *s)
+++void copyin(char *s)
++ {
++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++ 
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++-    
++-    int fd = open("copyin1", O_CREATE|O_WRONLY);
++-    if(fd < 0){
+++
+++    int fd = open("copyin1", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("open(copyin1) failed\n");
++       exit(1);
++     }
++-    int n = write(fd, (void*)addr, 8192);
++-    if(n >= 0){
++-      printf("write(fd, %p, 8192) returned %d, not -1\n", (void*)addr, n);
+++    int n = write(fd, (void *)addr, 8192);
+++    if (n >= 0)
+++    {
+++      printf("write(fd, %p, 8192) returned %d, not -1\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fd);
++     unlink("copyin1");
++-    
++-    n = write(1, (char*)addr, 8192);
++-    if(n > 0){
++-      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++
+++    n = write(1, (char *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++-    
+++
++     int fds[2];
++-    if(pipe(fds) < 0){
+++    if (pipe(fds) < 0)
+++    {
++       printf("pipe() failed\n");
++       exit(1);
++     }
++-    n = write(fds[1], (char*)addr, 8192);
++-    if(n > 0){
++-      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    n = write(fds[1], (char *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fds[0]);
++@@ -74,40 +79,45 @@ copyin(char *s)
++ 
++ // what if you pass ridiculous pointers to system calls
++ // that write user memory with copyout?
++-void
++-copyout(char *s)
+++void copyout(char *s)
++ {
++-  uint64 addrs[] = { 0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++ 
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++ 
++     int fd = open("README", 0);
++-    if(fd < 0){
+++    if (fd < 0)
+++    {
++       printf("open(README) failed\n");
++       exit(1);
++     }
++-    int n = read(fd, (void*)addr, 8192);
++-    if(n > 0){
++-      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    int n = read(fd, (void *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fd);
++ 
++     int fds[2];
++-    if(pipe(fds) < 0){
+++    if (pipe(fds) < 0)
+++    {
++       printf("pipe() failed\n");
++       exit(1);
++     }
++     n = write(fds[1], "x", 1);
++-    if(n != 1){
+++    if (n != 1)
+++    {
++       printf("pipe write failed\n");
++       exit(1);
++     }
++-    n = read(fds[0], (void*)addr, 8192);
++-    if(n > 0){
++-      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    n = read(fds[0], (void *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fds[0]);
++@@ -116,18 +126,19 @@ copyout(char *s)
++ }
++ 
++ // what if you pass ridiculous string pointers to system calls?
++-void
++-copyinstr1(char *s)
+++void copyinstr1(char *s)
++ {
++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++ 
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++ 
++-    int fd = open((char *)addr, O_CREATE|O_WRONLY);
++-    if(fd >= 0){
++-      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
+++    int fd = open((char *)addr, O_CREATE | O_WRONLY);
+++    if (fd >= 0)
+++    {
+++      printf("open(%p) returned %d, not -1\n", (void *)addr, fd);
++       exit(1);
++     }
++   }
++@@ -136,53 +147,59 @@ copyinstr1(char *s)
++ // what if a string system call argument is exactly the size
++ // of the kernel buffer it is copied into, so that the null
++ // would fall just beyond the end of the kernel buffer?
++-void
++-copyinstr2(char *s)
+++void copyinstr2(char *s)
++ {
++-  char b[MAXPATH+1];
+++  char b[MAXPATH + 1];
++ 
++-  for(int i = 0; i < MAXPATH; i++)
+++  for (int i = 0; i < MAXPATH; i++)
++     b[i] = 'x';
++   b[MAXPATH] = '\0';
++-  
+++
++   int ret = unlink(b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("unlink(%s) returned %d, not -1\n", b, ret);
++     exit(1);
++   }
++ 
++   int fd = open(b, O_CREATE | O_WRONLY);
++-  if(fd != -1){
+++  if (fd != -1)
+++  {
++     printf("open(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++ 
++   ret = link(b, b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
++     exit(1);
++   }
++ 
++-  char *args[] = { "xx", 0 };
+++  char *args[] = {"xx", 0};
++   ret = exec(b, args);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("exec(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++ 
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    static char big[PGSIZE+1];
++-    for(int i = 0; i < PGSIZE; i++)
+++  if (pid == 0)
+++  {
+++    static char big[PGSIZE + 1];
+++    for (int i = 0; i < PGSIZE; i++)
++       big[i] = 'x';
++     big[PGSIZE] = '\0';
++-    char *args2[] = { big, big, big, 0 };
+++    char *args2[] = {big, big, big, 0};
++     ret = exec("echo", args2);
++-    if(ret != -1){
+++    if (ret != -1)
+++    {
++       printf("exec(echo, BIG) returned %d, not -1\n", fd);
++       exit(1);
++     }
++@@ -191,51 +208,57 @@ copyinstr2(char *s)
++ 
++   int st = 0;
++   wait(&st);
++-  if(st != 747){
+++  if (st != 747)
+++  {
++     printf("exec(echo, BIG) succeeded, should have failed\n");
++     exit(1);
++   }
++ }
++ 
++ // what if a string argument crosses over the end of last user page?
++-void
++-copyinstr3(char *s)
+++void copyinstr3(char *s)
++ {
++   sbrk(8192);
++-  uint64 top = (uint64) sbrk(0);
++-  if((top % PGSIZE) != 0){
+++  uint64 top = (uint64)sbrk(0);
+++  if ((top % PGSIZE) != 0)
+++  {
++     sbrk(PGSIZE - (top % PGSIZE));
++   }
++-  top = (uint64) sbrk(0);
++-  if(top % PGSIZE){
+++  top = (uint64)sbrk(0);
+++  if (top % PGSIZE)
+++  {
++     printf("oops\n");
++     exit(1);
++   }
++ 
++-  char *b = (char *) (top - 1);
+++  char *b = (char *)(top - 1);
++   *b = 'x';
++ 
++   int ret = unlink(b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("unlink(%s) returned %d, not -1\n", b, ret);
++     exit(1);
++   }
++ 
++   int fd = open(b, O_CREATE | O_WRONLY);
++-  if(fd != -1){
+++  if (fd != -1)
+++  {
++     printf("open(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++ 
++   ret = link(b, b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
++     exit(1);
++   }
++ 
++-  char *args[] = { "xx", 0 };
+++  char *args[] = {"xx", 0};
++   ret = exec(b, args);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("exec(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++@@ -243,96 +266,105 @@ copyinstr3(char *s)
++ 
++ // See if the kernel refuses to read/write user memory that the
++ // application doesn't have anymore, because it returned it.
++-void
++-rwsbrk()
+++void rwsbrk(char *)
++ {
++   int fd, n;
++-  
++-  uint64 a = (uint64) sbrk(8192);
++ 
++-  if(a == 0xffffffffffffffffLL) {
+++  uint64 a = (uint64)sbrk(8192);
+++
+++  if (a == 0xffffffffffffffffLL)
+++  {
++     printf("sbrk(rwsbrk) failed\n");
++     exit(1);
++   }
++-  
++-  if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
+++
+++  if ((uint64)sbrk(-8192) == 0xffffffffffffffffLL)
+++  {
++     printf("sbrk(rwsbrk) shrink failed\n");
++     exit(1);
++   }
++ 
++-  fd = open("rwsbrk", O_CREATE|O_WRONLY);
++-  if(fd < 0){
+++  fd = open("rwsbrk", O_CREATE | O_WRONLY);
+++  if (fd < 0)
+++  {
++     printf("open(rwsbrk) failed\n");
++     exit(1);
++   }
++-  n = write(fd, (void*)(a+4096), 1024);
++-  if(n >= 0){
++-    printf("write(fd, %p, 1024) returned %d, not -1\n", (void*)a+4096, n);
+++  n = write(fd, (void *)(a + 4096), 1024);
+++  if (n >= 0)
+++  {
+++    printf("write(fd, %p, 1024) returned %d, not -1\n", (void *)a + 4096, n);
++     exit(1);
++   }
++   close(fd);
++   unlink("rwsbrk");
++ 
++   fd = open("README", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("open(rwsbrk) failed\n");
++     exit(1);
++   }
++-  n = read(fd, (void*)(a+4096), 10);
++-  if(n >= 0){
++-    printf("read(fd, %p, 10) returned %d, not -1\n", (void*)a+4096, n);
+++  n = read(fd, (void *)(a + 4096), 10);
+++  if (n >= 0)
+++  {
+++    printf("read(fd, %p, 10) returned %d, not -1\n", (void *)a + 4096, n);
++     exit(1);
++   }
++   close(fd);
++-  
+++
++   exit(0);
++ }
++ 
++ // test O_TRUNC.
++-void
++-truncate1(char *s)
+++void truncate1(char *s)
++ {
++   char buf[32];
++-  
+++
++   unlink("truncfile");
++-  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+++  int fd1 = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
++   write(fd1, "abcd", 4);
++   close(fd1);
++ 
++   int fd2 = open("truncfile", O_RDONLY);
++   int n = read(fd2, buf, sizeof(buf));
++-  if(n != 4){
+++  if (n != 4)
+++  {
++     printf("%s: read %d bytes, wanted 4\n", s, n);
++     exit(1);
++   }
++ 
++-  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
+++  fd1 = open("truncfile", O_WRONLY | O_TRUNC);
++ 
++   int fd3 = open("truncfile", O_RDONLY);
++   n = read(fd3, buf, sizeof(buf));
++-  if(n != 0){
+++  if (n != 0)
+++  {
++     printf("aaa fd3=%d\n", fd3);
++     printf("%s: read %d bytes, wanted 0\n", s, n);
++     exit(1);
++   }
++ 
++   n = read(fd2, buf, sizeof(buf));
++-  if(n != 0){
+++  if (n != 0)
+++  {
++     printf("bbb fd2=%d\n", fd2);
++     printf("%s: read %d bytes, wanted 0\n", s, n);
++     exit(1);
++   }
++-  
+++
++   write(fd1, "abcdef", 6);
++ 
++   n = read(fd3, buf, sizeof(buf));
++-  if(n != 6){
+++  if (n != 6)
+++  {
++     printf("%s: read %d bytes, wanted 6\n", s, n);
++     exit(1);
++   }
++ 
++   n = read(fd2, buf, sizeof(buf));
++-  if(n != 2){
+++  if (n != 2)
+++  {
++     printf("%s: read %d bytes, wanted 2\n", s, n);
++     exit(1);
++   }
++@@ -348,18 +380,18 @@ truncate1(char *s)
++ // this causes a write at an offset beyond the end of the file.
++ // such writes fail on xv6 (unlike POSIX) but at least
++ // they don't crash.
++-void
++-truncate2(char *s)
+++void truncate2(char *s)
++ {
++   unlink("truncfile");
++ 
++-  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
+++  int fd1 = open("truncfile", O_CREATE | O_TRUNC | O_WRONLY);
++   write(fd1, "abcd", 4);
++ 
++-  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
+++  int fd2 = open("truncfile", O_TRUNC | O_WRONLY);
++ 
++   int n = write(fd1, "x", 1);
++-  if(n != -1){
+++  if (n != -1)
+++  {
++     printf("%s: write returned %d, expected -1\n", s, n);
++     exit(1);
++   }
++@@ -369,29 +401,33 @@ truncate2(char *s)
++   close(fd2);
++ }
++ 
++-void
++-truncate3(char *s)
+++void truncate3(char *s)
++ {
++   int pid, xstatus;
++ 
++-  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
++-  
+++  close(open("truncfile", O_CREATE | O_TRUNC | O_WRONLY));
+++
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++ 
++-  if(pid == 0){
++-    for(int i = 0; i < 100; i++){
+++  if (pid == 0)
+++  {
+++    for (int i = 0; i < 100; i++)
+++    {
++       char buf[32];
++       int fd = open("truncfile", O_WRONLY);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("%s: open failed\n", s);
++         exit(1);
++       }
++       int n = write(fd, "1234567890", 10);
++-      if(n != 10){
+++      if (n != 10)
+++      {
++         printf("%s: write got %d, expected 10\n", s, n);
++         exit(1);
++       }
++@@ -403,14 +439,17 @@ truncate3(char *s)
++     exit(0);
++   }
++ 
++-  for(int i = 0; i < 150; i++){
++-    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
++-    if(fd < 0){
+++  for (int i = 0; i < 150; i++)
+++  {
+++    int fd = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
+++    if (fd < 0)
+++    {
++       printf("%s: open failed\n", s);
++       exit(1);
++     }
++     int n = write(fd, "xxx", 3);
++-    if(n != 3){
+++    if (n != 3)
+++    {
++       printf("%s: write got %d, expected 3\n", s, n);
++       exit(1);
++     }
++@@ -421,51 +460,57 @@ truncate3(char *s)
++   unlink("truncfile");
++   exit(xstatus);
++ }
++-  
++ 
++ // does chdir() call iput(p->cwd) in a transaction?
++-void
++-iputtest(char *s)
+++void iputtest(char *s)
++ {
++-  if(mkdir("iputdir") < 0){
+++  if (mkdir("iputdir") < 0)
+++  {
++     printf("%s: mkdir failed\n", s);
++     exit(1);
++   }
++-  if(chdir("iputdir") < 0){
+++  if (chdir("iputdir") < 0)
+++  {
++     printf("%s: chdir iputdir failed\n", s);
++     exit(1);
++   }
++-  if(unlink("../iputdir") < 0){
+++  if (unlink("../iputdir") < 0)
+++  {
++     printf("%s: unlink ../iputdir failed\n", s);
++     exit(1);
++   }
++-  if(chdir("/") < 0){
+++  if (chdir("/") < 0)
+++  {
++     printf("%s: chdir / failed\n", s);
++     exit(1);
++   }
++ }
++ 
++ // does exit() call iput(p->cwd) in a transaction?
++-void
++-exitiputtest(char *s)
+++void exitiputtest(char *s)
++ {
++   int pid, xstatus;
++ 
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
++-    if(mkdir("iputdir") < 0){
+++  if (pid == 0)
+++  {
+++    if (mkdir("iputdir") < 0)
+++    {
++       printf("%s: mkdir failed\n", s);
++       exit(1);
++     }
++-    if(chdir("iputdir") < 0){
+++    if (chdir("iputdir") < 0)
+++    {
++       printf("%s: child chdir failed\n", s);
++       exit(1);
++     }
++-    if(unlink("../iputdir") < 0){
+++    if (unlink("../iputdir") < 0)
+++    {
++       printf("%s: unlink ../iputdir failed\n", s);
++       exit(1);
++     }
++@@ -486,30 +531,34 @@ exitiputtest(char *s)
++ //      for(i = 0; i < 10000; i++)
++ //        yield();
++ //    }
++-void
++-openiputtest(char *s)
+++void openiputtest(char *s)
++ {
++   int pid, xstatus;
++ 
++-  if(mkdir("oidir") < 0){
+++  if (mkdir("oidir") < 0)
+++  {
++     printf("%s: mkdir oidir failed\n", s);
++     exit(1);
++   }
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     int fd = open("oidir", O_RDWR);
++-    if(fd >= 0){
+++    if (fd >= 0)
+++    {
++       printf("%s: open directory for write succeeded\n", s);
++       exit(1);
++     }
++     exit(0);
++   }
++   sleep(1);
++-  if(unlink("oidir") != 0){
+++  if (unlink("oidir") != 0)
+++  {
++     printf("%s: unlink failed\n", s);
++     exit(1);
++   }
++@@ -519,79 +568,92 @@ openiputtest(char *s)
++ 
++ // simple file system tests
++ 
++-void
++-opentest(char *s)
+++void opentest(char *s)
++ {
++   int fd;
++ 
++   fd = open("echo", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open echo failed!\n", s);
++     exit(1);
++   }
++   close(fd);
++   fd = open("doesnotexist", 0);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: open doesnotexist succeeded!\n", s);
++     exit(1);
++   }
++ }
++ 
++-void
++-writetest(char *s)
+++void writetest(char *s)
++ {
++   int fd;
++   int i;
++-  enum { N=100, SZ=10 };
++-  
++-  fd = open("small", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  enum
+++  {
+++    N = 100,
+++    SZ = 10
+++  };
+++
+++  fd = open("small", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: error: creat small failed!\n", s);
++     exit(1);
++   }
++-  for(i = 0; i < N; i++){
++-    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
+++  for (i = 0; i < N; i++)
+++  {
+++    if (write(fd, "aaaaaaaaaa", SZ) != SZ)
+++    {
++       printf("%s: error: write aa %d new file failed\n", s, i);
++       exit(1);
++     }
++-    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
+++    if (write(fd, "bbbbbbbbbb", SZ) != SZ)
+++    {
++       printf("%s: error: write bb %d new file failed\n", s, i);
++       exit(1);
++     }
++   }
++   close(fd);
++   fd = open("small", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: error: open small failed!\n", s);
++     exit(1);
++   }
++-  i = read(fd, buf, N*SZ*2);
++-  if(i != N*SZ*2){
+++  i = read(fd, buf, N * SZ * 2);
+++  if (i != N * SZ * 2)
+++  {
++     printf("%s: read failed\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(unlink("small") < 0){
+++  if (unlink("small") < 0)
+++  {
++     printf("%s: unlink small failed\n", s);
++     exit(1);
++   }
++ }
++ 
++-void
++-writebig(char *s)
+++void writebig(char *s)
++ {
++   int i, fd, n;
++ 
++-  fd = open("big", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("big", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: error: creat big failed!\n", s);
++     exit(1);
++   }
++ 
++-  for(i = 0; i < MAXFILE; i++){
++-    ((int*)buf)[0] = i;
++-    if(write(fd, buf, BSIZE) != BSIZE){
+++  for (i = 0; i < MAXFILE; i++)
+++  {
+++    ((int *)buf)[0] = i;
+++    if (write(fd, buf, BSIZE) != BSIZE)
+++    {
++       printf("%s: error: write big file failed i=%d\n", s, i);
++       exit(1);
++     }
++@@ -600,56 +662,68 @@ writebig(char *s)
++   close(fd);
++ 
++   fd = open("big", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: error: open big failed!\n", s);
++     exit(1);
++   }
++ 
++   n = 0;
++-  for(;;){
+++  for (;;)
+++  {
++     i = read(fd, buf, BSIZE);
++-    if(i == 0){
++-      if(n != MAXFILE){
+++    if (i == 0)
+++    {
+++      if (n != MAXFILE)
+++      {
++         printf("%s: read only %d blocks from big", s, n);
++         exit(1);
++       }
++       break;
++-    } else if(i != BSIZE){
+++    }
+++    else if (i != BSIZE)
+++    {
++       printf("%s: read failed %d\n", s, i);
++       exit(1);
++     }
++-    if(((int*)buf)[0] != n){
+++    if (((int *)buf)[0] != n)
+++    {
++       printf("%s: read content of block %d is %d\n", s,
++-             n, ((int*)buf)[0]);
+++             n, ((int *)buf)[0]);
++       exit(1);
++     }
++     n++;
++   }
++   close(fd);
++-  if(unlink("big") < 0){
+++  if (unlink("big") < 0)
+++  {
++     printf("%s: unlink big failed\n", s);
++     exit(1);
++   }
++ }
++ 
++ // many creates, followed by unlink test
++-void
++-createtest(char *s)
+++void createtest(char *s)
++ {
++   int i, fd;
++-  enum { N=52 };
+++  enum
+++  {
+++    N = 52
+++  };
++ 
++   char name[3];
++   name[0] = 'a';
++   name[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[1] = '0' + i;
++-    fd = open(name, O_CREATE|O_RDWR);
+++    fd = open(name, O_CREATE | O_RDWR);
++     close(fd);
++   }
++   name[0] = 'a';
++   name[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[1] = '0' + i;
++     unlink(name);
++   }
++@@ -657,152 +731,180 @@ createtest(char *s)
++ 
++ void dirtest(char *s)
++ {
++-  if(mkdir("dir0") < 0){
+++  if (mkdir("dir0") < 0)
+++  {
++     printf("%s: mkdir failed\n", s);
++     exit(1);
++   }
++ 
++-  if(chdir("dir0") < 0){
+++  if (chdir("dir0") < 0)
+++  {
++     printf("%s: chdir dir0 failed\n", s);
++     exit(1);
++   }
++ 
++-  if(chdir("..") < 0){
+++  if (chdir("..") < 0)
+++  {
++     printf("%s: chdir .. failed\n", s);
++     exit(1);
++   }
++ 
++-  if(unlink("dir0") < 0){
+++  if (unlink("dir0") < 0)
+++  {
++     printf("%s: unlink dir0 failed\n", s);
++     exit(1);
++   }
++ }
++ 
++-void
++-exectest(char *s)
+++void exectest(char *s)
++ {
++   int fd, xstatus, pid;
++-  char *echoargv[] = { "echo", "OK", 0 };
+++  char *echoargv[] = {"echo", "OK", 0};
++   char buf[3];
++ 
++   unlink("echo-ok");
++   pid = fork();
++-  if(pid < 0) {
++-     printf("%s: fork failed\n", s);
++-     exit(1);
+++  if (pid < 0)
+++  {
+++    printf("%s: fork failed\n", s);
+++    exit(1);
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     close(1);
++-    fd = open("echo-ok", O_CREATE|O_WRONLY);
++-    if(fd < 0) {
+++    fd = open("echo-ok", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("%s: create failed\n", s);
++       exit(1);
++     }
++-    if(fd != 1) {
+++    if (fd != 1)
+++    {
++       printf("%s: wrong fd\n", s);
++       exit(1);
++     }
++-    if(exec("echo", echoargv) < 0){
+++    if (exec("echo", echoargv) < 0)
+++    {
++       printf("%s: exec echo failed\n", s);
++       exit(1);
++     }
++     // won't get to here
++   }
++-  if (wait(&xstatus) != pid) {
+++  if (wait(&xstatus) != pid)
+++  {
++     printf("%s: wait failed!\n", s);
++   }
++-  if(xstatus != 0)
+++  if (xstatus != 0)
++     exit(xstatus);
++ 
++   fd = open("echo-ok", O_RDONLY);
++-  if(fd < 0) {
+++  if (fd < 0)
+++  {
++     printf("%s: open failed\n", s);
++     exit(1);
++   }
++-  if (read(fd, buf, 2) != 2) {
+++  if (read(fd, buf, 2) != 2)
+++  {
++     printf("%s: read failed\n", s);
++     exit(1);
++   }
++   unlink("echo-ok");
++-  if(buf[0] == 'O' && buf[1] == 'K')
+++  if (buf[0] == 'O' && buf[1] == 'K')
++     exit(0);
++-  else {
+++  else
+++  {
++     printf("%s: wrong output\n", s);
++     exit(1);
++   }
++-
++ }
++ 
++ // simple fork and pipe read/write
++ 
++-void
++-pipe1(char *s)
+++void pipe1(char *s)
++ {
++   int fds[2], pid, xstatus;
++   int seq, i, n, cc, total;
++-  enum { N=5, SZ=1033 };
++-  
++-  if(pipe(fds) != 0){
+++  enum
+++  {
+++    N = 5,
+++    SZ = 1033
+++  };
+++
+++  if (pipe(fds) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++   }
++   pid = fork();
++   seq = 0;
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     close(fds[0]);
++-    for(n = 0; n < N; n++){
++-      for(i = 0; i < SZ; i++)
+++    for (n = 0; n < N; n++)
+++    {
+++      for (i = 0; i < SZ; i++)
++         buf[i] = seq++;
++-      if(write(fds[1], buf, SZ) != SZ){
+++      if (write(fds[1], buf, SZ) != SZ)
+++      {
++         printf("%s: pipe1 oops 1\n", s);
++         exit(1);
++       }
++     }
++     exit(0);
++-  } else if(pid > 0){
+++  }
+++  else if (pid > 0)
+++  {
++     close(fds[1]);
++     total = 0;
++     cc = 1;
++-    while((n = read(fds[0], buf, cc)) > 0){
++-      for(i = 0; i < n; i++){
++-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+++    while ((n = read(fds[0], buf, cc)) > 0)
+++    {
+++      for (i = 0; i < n; i++)
+++      {
+++        if ((buf[i] & 0xff) != (seq++ & 0xff))
+++        {
++           printf("%s: pipe1 oops 2\n", s);
++           return;
++         }
++       }
++       total += n;
++       cc = cc * 2;
++-      if(cc > sizeof(buf))
+++      if (cc > sizeof(buf))
++         cc = sizeof(buf);
++     }
++-    if(total != N * SZ){
+++    if (total != N * SZ)
+++    {
++       printf("%s: pipe1 oops 3 total %d\n", s, total);
++       exit(1);
++     }
++     close(fds[0]);
++     wait(&xstatus);
++     exit(xstatus);
++-  } else {
+++  }
+++  else
+++  {
++     printf("%s: fork() failed\n", s);
++     exit(1);
++   }
++ }
++ 
++-
++ // test if child is killed (status = -1)
++-void
++-killstatus(char *s)
+++void killstatus(char *s)
++ {
++   int xst;
++-  
++-  for(int i = 0; i < 100; i++){
+++
+++  for (int i = 0; i < 100; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid1 == 0){
++-      while(1) {
+++    if (pid1 == 0)
+++    {
+++      while (1)
+++      {
++         getpid();
++       }
++       exit(0);
++@@ -810,56 +912,61 @@ killstatus(char *s)
++     sleep(1);
++     kill(pid1);
++     wait(&xst);
++-    if(xst != -1) {
++-       printf("%s: status should be -1\n", s);
++-       exit(1);
+++    if (xst != -1)
+++    {
+++      printf("%s: status should be -1\n", s);
+++      exit(1);
++     }
++   }
++   exit(0);
++ }
++ 
++ // meant to be run w/ at most two CPUs
++-void
++-preempt(char *s)
+++void preempt(char *s)
++ {
++   int pid1, pid2, pid3;
++   int pfds[2];
++ 
++   pid1 = fork();
++-  if(pid1 < 0) {
+++  if (pid1 < 0)
+++  {
++     printf("%s: fork failed", s);
++     exit(1);
++   }
++-  if(pid1 == 0)
++-    for(;;)
+++  if (pid1 == 0)
+++    for (;;)
++       ;
++ 
++   pid2 = fork();
++-  if(pid2 < 0) {
+++  if (pid2 < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid2 == 0)
++-    for(;;)
+++  if (pid2 == 0)
+++    for (;;)
++       ;
++ 
++   pipe(pfds);
++   pid3 = fork();
++-  if(pid3 < 0) {
++-     printf("%s: fork failed\n", s);
++-     exit(1);
+++  if (pid3 < 0)
+++  {
+++    printf("%s: fork failed\n", s);
+++    exit(1);
++   }
++-  if(pid3 == 0){
+++  if (pid3 == 0)
+++  {
++     close(pfds[0]);
++-    if(write(pfds[1], "x", 1) != 1)
+++    if (write(pfds[1], "x", 1) != 1)
++       printf("%s: preempt write error", s);
++     close(pfds[1]);
++-    for(;;)
+++    for (;;)
++       ;
++   }
++ 
++   close(pfds[1]);
++-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+++  if (read(pfds[0], buf, sizeof(buf)) != 1)
+++  {
++     printf("%s: preempt read error", s);
++     return;
++   }
++@@ -875,28 +982,34 @@ preempt(char *s)
++ }
++ 
++ // try to find any races between exit and wait
++-void
++-exitwait(char *s)
+++void exitwait(char *s)
++ {
++   int i, pid;
++ 
++-  for(i = 0; i < 100; i++){
+++  for (i = 0; i < 100; i++)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid){
+++    if (pid)
+++    {
++       int xstate;
++-      if(wait(&xstate) != pid){
+++      if (wait(&xstate) != pid)
+++      {
++         printf("%s: wait wrong pid\n", s);
++         exit(1);
++       }
++-      if(i != xstate) {
+++      if (i != xstate)
+++      {
++         printf("%s: wait wrong exit status\n", s);
++         exit(1);
++       }
++-    } else {
+++    }
+++    else
+++    {
++       exit(i);
++     }
++   }
++@@ -905,24 +1018,30 @@ exitwait(char *s)
++ // try to find races in the reparenting
++ // code that handles a parent exiting
++ // when it still has live children.
++-void
++-reparent(char *s)
+++void reparent(char *s)
++ {
++   int master_pid = getpid();
++-  for(int i = 0; i < 200; i++){
+++  for (int i = 0; i < 200; i++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid){
++-      if(wait(0) != pid){
+++    if (pid)
+++    {
+++      if (wait(0) != pid)
+++      {
++         printf("%s: wait wrong pid\n", s);
++         exit(1);
++       }
++-    } else {
+++    }
+++    else
+++    {
++       int pid2 = fork();
++-      if(pid2 < 0){
+++      if (pid2 < 0)
+++      {
++         kill(master_pid);
++         exit(1);
++       }
++@@ -933,26 +1052,34 @@ reparent(char *s)
++ }
++ 
++ // what if two children exit() at the same time?
++-void
++-twochildren(char *s)
+++void twochildren(char *s)
++ {
++-  for(int i = 0; i < 1000; i++){
+++  for (int i = 0; i < 1000; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid1 == 0){
+++    if (pid1 == 0)
+++    {
++       exit(0);
++-    } else {
+++    }
+++    else
+++    {
++       int pid2 = fork();
++-      if(pid2 < 0){
+++      if (pid2 < 0)
+++      {
++         printf("%s: fork failed\n", s);
++         exit(1);
++       }
++-      if(pid2 == 0){
+++      if (pid2 == 0)
+++      {
++         exit(0);
++-      } else {
+++      }
+++      else
+++      {
++         wait(0);
++         wait(0);
++       }
++@@ -961,24 +1088,32 @@ twochildren(char *s)
++ }
++ 
++ // concurrent forks to try to expose locking bugs.
++-void
++-forkfork(char *s)
+++void forkfork(char *s)
++ {
++-  enum { N=2 };
++-  
++-  for(int i = 0; i < N; i++){
+++  enum
+++  {
+++    N = 2
+++  };
+++
+++  for (int i = 0; i < N; i++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed", s);
++       exit(1);
++     }
++-    if(pid == 0){
++-      for(int j = 0; j < 200; j++){
+++    if (pid == 0)
+++    {
+++      for (int j = 0; j < 200; j++)
+++      {
++         int pid1 = fork();
++-        if(pid1 < 0){
+++        if (pid1 < 0)
+++        {
++           exit(1);
++         }
++-        if(pid1 == 0){
+++        if (pid1 == 0)
+++        {
++           exit(0);
++         }
++         wait(0);
++@@ -988,33 +1123,39 @@ forkfork(char *s)
++   }
++ 
++   int xstatus;
++-  for(int i = 0; i < N; i++){
+++  for (int i = 0; i < N; i++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0) {
+++    if (xstatus != 0)
+++    {
++       printf("%s: fork in child failed", s);
++       exit(1);
++     }
++   }
++ }
++ 
++-void
++-forkforkfork(char *s)
+++void forkforkfork(char *s)
++ {
++   unlink("stopforking");
++ 
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed", s);
++     exit(1);
++   }
++-  if(pid == 0){
++-    while(1){
+++  if (pid == 0)
+++  {
+++    while (1)
+++    {
++       int fd = open("stopforking", 0);
++-      if(fd >= 0){
+++      if (fd >= 0)
+++      {
++         exit(0);
++       }
++-      if(fork() < 0){
++-        close(open("stopforking", O_CREATE|O_RDWR));
+++      if (fork() < 0)
+++      {
+++        close(open("stopforking", O_CREATE | O_RDWR));
++       }
++     }
++ 
++@@ -1022,7 +1163,7 @@ forkforkfork(char *s)
++   }
++ 
++   sleep(20); // two seconds
++-  close(open("stopforking", O_CREATE|O_RDWR));
+++  close(open("stopforking", O_CREATE | O_RDWR));
++   wait(0);
++   sleep(10); // one second
++ }
++@@ -1032,16 +1173,18 @@ forkforkfork(char *s)
++ // deadlocks against init's wait()? also used to trigger a "panic:
++ // release" due to exit() releasing a different p->parent->lock than
++ // it acquired.
++-void
++-reparent2(char *s)
+++void reparent2(char *s)
++ {
++-  for(int i = 0; i < 800; i++){
+++  for (int i = 0; i < 800; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++     }
++-    if(pid1 == 0){
+++    if (pid1 == 0)
+++    {
++       fork();
++       fork();
++       exit(0);
++@@ -1053,34 +1196,40 @@ reparent2(char *s)
++ }
++ 
++ // allocate all mem, free it, and allocate again
++-void
++-mem(char *s)
+++void mem(char *s)
++ {
++   void *m1, *m2;
++   int pid;
++ 
++-  if((pid = fork()) == 0){
+++  if ((pid = fork()) == 0)
+++  {
++     m1 = 0;
++-    while((m2 = malloc(10001)) != 0){
++-      *(char**)m2 = m1;
+++    while ((m2 = malloc(10001)) != 0)
+++    {
+++      *(char **)m2 = m1;
++       m1 = m2;
++     }
++-    while(m1){
++-      m2 = *(char**)m1;
+++    while (m1)
+++    {
+++      m2 = *(char **)m1;
++       free(m1);
++       m1 = m2;
++     }
++-    m1 = malloc(1024*20);
++-    if(m1 == 0){
+++    m1 = malloc(1024 * 20);
+++    if (m1 == 0)
+++    {
++       printf("%s: couldn't allocate mem?!!\n", s);
++       exit(1);
++     }
++     free(m1);
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus == -1){
+++    if (xstatus == -1)
+++    {
++       // probably page fault, so might be lazy lab,
++       // so OK.
++       exit(0);
++@@ -1093,56 +1242,71 @@ mem(char *s)
++ 
++ // two processes write to the same file descriptor
++ // is the offset shared? does inode locking work?
++-void
++-sharedfd(char *s)
+++void sharedfd(char *s)
++ {
++   int fd, pid, i, n, nc, np;
++-  enum { N = 1000, SZ=10};
+++  enum
+++  {
+++    N = 1000,
+++    SZ = 10
+++  };
++   char buf[SZ];
++ 
++   unlink("sharedfd");
++-  fd = open("sharedfd", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("sharedfd", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open sharedfd for writing", s);
++     exit(1);
++   }
++   pid = fork();
++-  memset(buf, pid==0?'c':'p', sizeof(buf));
++-  for(i = 0; i < N; i++){
++-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+++  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
+++  for (i = 0; i < N; i++)
+++  {
+++    if (write(fd, buf, sizeof(buf)) != sizeof(buf))
+++    {
++       printf("%s: write sharedfd failed\n", s);
++       exit(1);
++     }
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(xstatus);
++   }
++-  
+++
++   close(fd);
++   fd = open("sharedfd", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open sharedfd for reading\n", s);
++     exit(1);
++   }
++   nc = np = 0;
++-  while((n = read(fd, buf, sizeof(buf))) > 0){
++-    for(i = 0; i < sizeof(buf); i++){
++-      if(buf[i] == 'c')
+++  while ((n = read(fd, buf, sizeof(buf))) > 0)
+++  {
+++    for (i = 0; i < sizeof(buf); i++)
+++    {
+++      if (buf[i] == 'c')
++         nc++;
++-      if(buf[i] == 'p')
+++      if (buf[i] == 'p')
++         np++;
++     }
++   }
++   close(fd);
++   unlink("sharedfd");
++-  if(nc == N*SZ && np == N*SZ){
+++  if (nc == N * SZ && np == N * SZ)
+++  {
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     printf("%s: nc/np test fails\n", s);
++     exit(1);
++   }
++@@ -1150,34 +1314,44 @@ sharedfd(char *s)
++ 
++ // four processes write different files at the same
++ // time, to test block allocation.
++-void
++-fourfiles(char *s)
+++void fourfiles(char *s)
++ {
++   int fd, pid, i, j, n, total, pi;
++-  char *names[] = { "f0", "f1", "f2", "f3" };
+++  char *names[] = {"f0", "f1", "f2", "f3"};
++   char *fname;
++-  enum { N=12, NCHILD=4, SZ=500 };
++-  
++-  for(pi = 0; pi < NCHILD; pi++){
+++  enum
+++  {
+++    N = 12,
+++    NCHILD = 4,
+++    SZ = 500
+++  };
+++
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     fname = names[pi];
++     unlink(fname);
++ 
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++ 
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       fd = open(fname, O_CREATE | O_RDWR);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("%s: create failed\n", s);
++         exit(1);
++       }
++ 
++-      memset(buf, '0'+pi, SZ);
++-      for(i = 0; i < N; i++){
++-        if((n = write(fd, buf, SZ)) != SZ){
+++      memset(buf, '0' + pi, SZ);
+++      for (i = 0; i < N; i++)
+++      {
+++        if ((n = write(fd, buf, SZ)) != SZ)
+++        {
++           printf("write failed %d\n", n);
++           exit(1);
++         }
++@@ -1187,19 +1361,24 @@ fourfiles(char *s)
++   }
++ 
++   int xstatus;
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(xstatus);
++   }
++ 
++-  for(i = 0; i < NCHILD; i++){
+++  for (i = 0; i < NCHILD; i++)
+++  {
++     fname = names[i];
++     fd = open(fname, 0);
++     total = 0;
++-    while((n = read(fd, buf, sizeof(buf))) > 0){
++-      for(j = 0; j < n; j++){
++-        if(buf[j] != '0'+i){
+++    while ((n = read(fd, buf, sizeof(buf))) > 0)
+++    {
+++      for (j = 0; j < n; j++)
+++      {
+++        if (buf[j] != '0' + i)
+++        {
++           printf("%s: wrong char\n", s);
++           exit(1);
++         }
++@@ -1207,7 +1386,8 @@ fourfiles(char *s)
++       total += n;
++     }
++     close(fd);
++-    if(total != N*SZ){
+++    if (total != N * SZ)
+++    {
++       printf("wrong length %d\n", total);
++       exit(1);
++     }
++@@ -1216,34 +1396,44 @@ fourfiles(char *s)
++ }
++ 
++ // four processes create and delete different files in same directory
++-void
++-createdelete(char *s)
+++void createdelete(char *s)
++ {
++-  enum { N = 20, NCHILD=4 };
+++  enum
+++  {
+++    N = 20,
+++    NCHILD = 4
+++  };
++   int pid, i, fd, pi;
++   char name[32];
++ 
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++ 
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       name[0] = 'p' + pi;
++       name[2] = '\0';
++-      for(i = 0; i < N; i++){
+++      for (i = 0; i < N; i++)
+++      {
++         name[1] = '0' + i;
++         fd = open(name, O_CREATE | O_RDWR);
++-        if(fd < 0){
+++        if (fd < 0)
+++        {
++           printf("%s: create failed\n", s);
++           exit(1);
++         }
++         close(fd);
++-        if(i > 0 && (i % 2 ) == 0){
+++        if (i > 0 && (i % 2) == 0)
+++        {
++           name[1] = '0' + (i / 2);
++-          if(unlink(name) < 0){
+++          if (unlink(name) < 0)
+++          {
++             printf("%s: unlink failed\n", s);
++             exit(1);
++           }
++@@ -1254,32 +1444,40 @@ createdelete(char *s)
++   }
++ 
++   int xstatus;
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(1);
++   }
++ 
++   name[0] = name[1] = name[2] = 0;
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < NCHILD; pi++){
+++  for (i = 0; i < N; i++)
+++  {
+++    for (pi = 0; pi < NCHILD; pi++)
+++    {
++       name[0] = 'p' + pi;
++       name[1] = '0' + i;
++       fd = open(name, 0);
++-      if((i == 0 || i >= N/2) && fd < 0){
+++      if ((i == 0 || i >= N / 2) && fd < 0)
+++      {
++         printf("%s: oops createdelete %s didn't exist\n", s, name);
++         exit(1);
++-      } else if((i >= 1 && i < N/2) && fd >= 0){
+++      }
+++      else if ((i >= 1 && i < N / 2) && fd >= 0)
+++      {
++         printf("%s: oops createdelete %s did exist\n", s, name);
++         exit(1);
++       }
++-      if(fd >= 0)
+++      if (fd >= 0)
++         close(fd);
++     }
++   }
++ 
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < NCHILD; pi++){
+++  for (i = 0; i < N; i++)
+++  {
+++    for (pi = 0; pi < NCHILD; pi++)
+++    {
++       name[0] = 'p' + pi;
++       name[1] = '0' + i;
++       unlink(name);
++@@ -1288,14 +1486,17 @@ createdelete(char *s)
++ }
++ 
++ // can I unlink a file and still read it?
++-void
++-unlinkread(char *s)
+++void unlinkread(char *s)
++ {
++-  enum { SZ = 5 };
+++  enum
+++  {
+++    SZ = 5
+++  };
++   int fd, fd1;
++ 
++   fd = open("unlinkread", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create unlinkread failed\n", s);
++     exit(1);
++   }
++@@ -1303,11 +1504,13 @@ unlinkread(char *s)
++   close(fd);
++ 
++   fd = open("unlinkread", O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open unlinkread failed\n", s);
++     exit(1);
++   }
++-  if(unlink("unlinkread") != 0){
+++  if (unlink("unlinkread") != 0)
+++  {
++     printf("%s: unlink unlinkread failed\n", s);
++     exit(1);
++   }
++@@ -1316,15 +1519,18 @@ unlinkread(char *s)
++   write(fd1, "yyy", 3);
++   close(fd1);
++ 
++-  if(read(fd, buf, sizeof(buf)) != SZ){
+++  if (read(fd, buf, sizeof(buf)) != SZ)
+++  {
++     printf("%s: unlinkread read failed", s);
++     exit(1);
++   }
++-  if(buf[0] != 'h'){
+++  if (buf[0] != 'h')
+++  {
++     printf("%s: unlinkread wrong data\n", s);
++     exit(1);
++   }
++-  if(write(fd, buf, 10) != 10){
+++  if (write(fd, buf, 10) != 10)
+++  {
++     printf("%s: unlinkread write failed\n", s);
++     exit(1);
++   }
++@@ -1332,102 +1538,126 @@ unlinkread(char *s)
++   unlink("unlinkread");
++ }
++ 
++-void
++-linktest(char *s)
+++void linktest(char *s)
++ {
++-  enum { SZ = 5 };
+++  enum
+++  {
+++    SZ = 5
+++  };
++   int fd;
++ 
++   unlink("lf1");
++   unlink("lf2");
++ 
++-  fd = open("lf1", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("lf1", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: create lf1 failed\n", s);
++     exit(1);
++   }
++-  if(write(fd, "hello", SZ) != SZ){
+++  if (write(fd, "hello", SZ) != SZ)
+++  {
++     printf("%s: write lf1 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(link("lf1", "lf2") < 0){
+++  if (link("lf1", "lf2") < 0)
+++  {
++     printf("%s: link lf1 lf2 failed\n", s);
++     exit(1);
++   }
++   unlink("lf1");
++ 
++-  if(open("lf1", 0) >= 0){
+++  if (open("lf1", 0) >= 0)
+++  {
++     printf("%s: unlinked lf1 but it is still there!\n", s);
++     exit(1);
++   }
++ 
++   fd = open("lf2", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open lf2 failed\n", s);
++     exit(1);
++   }
++-  if(read(fd, buf, sizeof(buf)) != SZ){
+++  if (read(fd, buf, sizeof(buf)) != SZ)
+++  {
++     printf("%s: read lf2 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(link("lf2", "lf2") >= 0){
+++  if (link("lf2", "lf2") >= 0)
+++  {
++     printf("%s: link lf2 lf2 succeeded! oops\n", s);
++     exit(1);
++   }
++ 
++   unlink("lf2");
++-  if(link("lf2", "lf1") >= 0){
+++  if (link("lf2", "lf1") >= 0)
+++  {
++     printf("%s: link non-existent succeeded! oops\n", s);
++     exit(1);
++   }
++ 
++-  if(link(".", "lf1") >= 0){
+++  if (link(".", "lf1") >= 0)
+++  {
++     printf("%s: link . lf1 succeeded! oops\n", s);
++     exit(1);
++   }
++ }
++ 
++ // test concurrent create/link/unlink of the same file
++-void
++-concreate(char *s)
+++void concreate(char *s)
++ {
++-  enum { N = 40 };
+++  enum
+++  {
+++    N = 40
+++  };
++   char file[3];
++   int i, pid, n, fd;
++   char fa[N];
++-  struct {
+++  struct
+++  {
++     ushort inum;
++     char name[DIRSIZ];
++   } de;
++ 
++   file[0] = 'C';
++   file[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     file[1] = '0' + i;
++     unlink(file);
++     pid = fork();
++-    if(pid && (i % 3) == 1){
+++    if (pid && (i % 3) == 1)
+++    {
++       link("C0", file);
++-    } else if(pid == 0 && (i % 5) == 1){
+++    }
+++    else if (pid == 0 && (i % 5) == 1)
+++    {
++       link("C0", file);
++-    } else {
+++    }
+++    else
+++    {
++       fd = open(file, O_CREATE | O_RDWR);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("concreate create %s failed\n", file);
++         exit(1);
++       }
++       close(fd);
++     }
++-    if(pid == 0) {
+++    if (pid == 0)
+++    {
++       exit(0);
++-    } else {
+++    }
+++    else
+++    {
++       int xstatus;
++       wait(&xstatus);
++-      if(xstatus != 0)
+++      if (xstatus != 0)
++         exit(1);
++     }
++   }
++@@ -1435,16 +1665,20 @@ concreate(char *s)
++   memset(fa, 0, sizeof(fa));
++   fd = open(".", 0);
++   n = 0;
++-  while(read(fd, &de, sizeof(de)) > 0){
++-    if(de.inum == 0)
+++  while (read(fd, &de, sizeof(de)) > 0)
+++  {
+++    if (de.inum == 0)
++       continue;
++-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+++    if (de.name[0] == 'C' && de.name[2] == '\0')
+++    {
++       i = de.name[1] - '0';
++-      if(i < 0 || i >= sizeof(fa)){
+++      if (i < 0 || i >= sizeof(fa))
+++      {
++         printf("%s: concreate weird file %s\n", s, de.name);
++         exit(1);
++       }
++-      if(fa[i]){
+++      if (fa[i])
+++      {
++         printf("%s: concreate duplicate file %s\n", s, de.name);
++         exit(1);
++       }
++@@ -1454,27 +1688,33 @@ concreate(char *s)
++   }
++   close(fd);
++ 
++-  if(n != N){
+++  if (n != N)
+++  {
++     printf("%s: concreate not enough files in directory listing\n", s);
++     exit(1);
++   }
++ 
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     file[1] = '0' + i;
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(((i % 3) == 0 && pid == 0) ||
++-       ((i % 3) == 1 && pid != 0)){
+++    if (((i % 3) == 0 && pid == 0) ||
+++        ((i % 3) == 1 && pid != 0))
+++    {
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++-    } else {
+++    }
+++    else
+++    {
++       unlink(file);
++       unlink(file);
++       unlink(file);
++@@ -1482,7 +1722,7 @@ concreate(char *s)
++       unlink(file);
++       unlink(file);
++     }
++-    if(pid == 0)
+++    if (pid == 0)
++       exit(0);
++     else
++       wait(0);
++@@ -1491,68 +1731,77 @@ concreate(char *s)
++ 
++ // another concurrent link/unlink/create test,
++ // to look for deadlocks.
++-void
++-linkunlink(char *s)
+++void linkunlink(char *s)
++ {
++   int pid, i;
++ 
++   unlink("x");
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++ 
++   unsigned int x = (pid ? 1 : 97);
++-  for(i = 0; i < 100; i++){
+++  for (i = 0; i < 100; i++)
+++  {
++     x = x * 1103515245 + 12345;
++-    if((x % 3) == 0){
+++    if ((x % 3) == 0)
+++    {
++       close(open("x", O_RDWR | O_CREATE));
++-    } else if((x % 3) == 1){
+++    }
+++    else if ((x % 3) == 1)
+++    {
++       link("cat", "x");
++-    } else {
+++    }
+++    else
+++    {
++       unlink("x");
++     }
++   }
++ 
++-  if(pid)
+++  if (pid)
++     wait(0);
++   else
++     exit(0);
++ }
++ 
++-
++-void
++-subdir(char *s)
+++void subdir(char *s)
++ {
++   int fd, cc;
++ 
++   unlink("ff");
++-  if(mkdir("dd") != 0){
+++  if (mkdir("dd") != 0)
+++  {
++     printf("%s: mkdir dd failed\n", s);
++     exit(1);
++   }
++ 
++   fd = open("dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dd/ff failed\n", s);
++     exit(1);
++   }
++   write(fd, "ff", 2);
++   close(fd);
++ 
++-  if(unlink("dd") >= 0){
+++  if (unlink("dd") >= 0)
+++  {
++     printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
++     exit(1);
++   }
++ 
++-  if(mkdir("/dd/dd") != 0){
+++  if (mkdir("/dd/dd") != 0)
+++  {
++     printf("%s: subdir mkdir dd/dd failed\n", s);
++     exit(1);
++   }
++ 
++   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dd/dd/ff failed\n", s);
++     exit(1);
++   }
++@@ -1560,164 +1809,199 @@ subdir(char *s)
++   close(fd);
++ 
++   fd = open("dd/dd/../ff", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open dd/dd/../ff failed\n", s);
++     exit(1);
++   }
++   cc = read(fd, buf, sizeof(buf));
++-  if(cc != 2 || buf[0] != 'f'){
+++  if (cc != 2 || buf[0] != 'f')
+++  {
++     printf("%s: dd/dd/../ff wrong content\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+++  if (link("dd/dd/ff", "dd/dd/ffff") != 0)
+++  {
++     printf("%s: link dd/dd/ff dd/dd/ffff failed\n", s);
++     exit(1);
++   }
++ 
++-  if(unlink("dd/dd/ff") != 0){
+++  if (unlink("dd/dd/ff") != 0)
+++  {
++     printf("%s: unlink dd/dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+++  if (open("dd/dd/ff", O_RDONLY) >= 0)
+++  {
++     printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
++     exit(1);
++   }
++ 
++-  if(chdir("dd") != 0){
+++  if (chdir("dd") != 0)
+++  {
++     printf("%s: chdir dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/../../dd") != 0){
+++  if (chdir("dd/../../dd") != 0)
+++  {
++     printf("%s: chdir dd/../../dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/../../../dd") != 0){
+++  if (chdir("dd/../../../dd") != 0)
+++  {
++     printf("%s: chdir dd/../../../dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("./..") != 0){
+++  if (chdir("./..") != 0)
+++  {
++     printf("%s: chdir ./.. failed\n", s);
++     exit(1);
++   }
++ 
++   fd = open("dd/dd/ffff", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open dd/dd/ffff failed\n", s);
++     exit(1);
++   }
++-  if(read(fd, buf, sizeof(buf)) != 2){
+++  if (read(fd, buf, sizeof(buf)) != 2)
+++  {
++     printf("%s: read dd/dd/ffff wrong len\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+++  if (open("dd/dd/ff", O_RDONLY) >= 0)
+++  {
++     printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
++     exit(1);
++   }
++ 
++-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+++  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0)
+++  {
++     printf("%s: create dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+++  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0)
+++  {
++     printf("%s: create dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_CREATE) >= 0){
+++  if (open("dd", O_CREATE) >= 0)
+++  {
++     printf("%s: create dd succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_RDWR) >= 0){
+++  if (open("dd", O_RDWR) >= 0)
+++  {
++     printf("%s: open dd rdwr succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_WRONLY) >= 0){
+++  if (open("dd", O_WRONLY) >= 0)
+++  {
++     printf("%s: open dd wronly succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+++  if (link("dd/ff/ff", "dd/dd/xx") == 0)
+++  {
++     printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+++  if (link("dd/xx/ff", "dd/dd/xx") == 0)
+++  {
++     printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/ff", "dd/dd/ffff") == 0){
+++  if (link("dd/ff", "dd/dd/ffff") == 0)
+++  {
++     printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/ff/ff") == 0){
+++  if (mkdir("dd/ff/ff") == 0)
+++  {
++     printf("%s: mkdir dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/xx/ff") == 0){
+++  if (mkdir("dd/xx/ff") == 0)
+++  {
++     printf("%s: mkdir dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/dd/ffff") == 0){
+++  if (mkdir("dd/dd/ffff") == 0)
+++  {
++     printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/xx/ff") == 0){
+++  if (unlink("dd/xx/ff") == 0)
+++  {
++     printf("%s: unlink dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/ff/ff") == 0){
+++  if (unlink("dd/ff/ff") == 0)
+++  {
++     printf("%s: unlink dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/ff") == 0){
+++  if (chdir("dd/ff") == 0)
+++  {
++     printf("%s: chdir dd/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/xx") == 0){
+++  if (chdir("dd/xx") == 0)
+++  {
++     printf("%s: chdir dd/xx succeeded!\n", s);
++     exit(1);
++   }
++ 
++-  if(unlink("dd/dd/ffff") != 0){
+++  if (unlink("dd/dd/ffff") != 0)
+++  {
++     printf("%s: unlink dd/dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/ff") != 0){
+++  if (unlink("dd/ff") != 0)
+++  {
++     printf("%s: unlink dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd") == 0){
+++  if (unlink("dd") == 0)
+++  {
++     printf("%s: unlink non-empty dd succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/dd") < 0){
+++  if (unlink("dd/dd") < 0)
+++  {
++     printf("%s: unlink dd/dd failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd") < 0){
+++  if (unlink("dd") < 0)
+++  {
++     printf("%s: unlink dd failed\n", s);
++     exit(1);
++   }
++ }
++ 
++ // test writes that are larger than the log.
++-void
++-bigwrite(char *s)
+++void bigwrite(char *s)
++ {
++   int fd, sz;
++ 
++   unlink("bigwrite");
++-  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+++  for (sz = 499; sz < (MAXOPBLOCKS + 2) * BSIZE; sz += 471)
+++  {
++     fd = open("bigwrite", O_CREATE | O_RDWR);
++-    if(fd < 0){
+++    if (fd < 0)
+++    {
++       printf("%s: cannot create bigwrite\n", s);
++       exit(1);
++     }
++     int i;
++-    for(i = 0; i < 2; i++){
+++    for (i = 0; i < 2; i++)
+++    {
++       int cc = write(fd, buf, sz);
++-      if(cc != sz){
+++      if (cc != sz)
+++      {
++         printf("%s: write(%d) ret %d\n", s, sz, cc);
++         exit(1);
++       }
++@@ -1727,22 +2011,27 @@ bigwrite(char *s)
++   }
++ }
++ 
++-
++-void
++-bigfile(char *s)
+++void bigfile(char *s)
++ {
++-  enum { N = 20, SZ=600 };
+++  enum
+++  {
+++    N = 20,
+++    SZ = 600
+++  };
++   int fd, i, total, cc;
++ 
++   unlink("bigfile.dat");
++   fd = open("bigfile.dat", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot create bigfile", s);
++     exit(1);
++   }
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     memset(buf, i, SZ);
++-    if(write(fd, buf, SZ) != SZ){
+++    if (write(fd, buf, SZ) != SZ)
+++    {
++       printf("%s: write bigfile failed\n", s);
++       exit(1);
++     }
++@@ -1750,70 +2039,81 @@ bigfile(char *s)
++   close(fd);
++ 
++   fd = open("bigfile.dat", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open bigfile\n", s);
++     exit(1);
++   }
++   total = 0;
++-  for(i = 0; ; i++){
++-    cc = read(fd, buf, SZ/2);
++-    if(cc < 0){
+++  for (i = 0;; i++)
+++  {
+++    cc = read(fd, buf, SZ / 2);
+++    if (cc < 0)
+++    {
++       printf("%s: read bigfile failed\n", s);
++       exit(1);
++     }
++-    if(cc == 0)
+++    if (cc == 0)
++       break;
++-    if(cc != SZ/2){
+++    if (cc != SZ / 2)
+++    {
++       printf("%s: short read bigfile\n", s);
++       exit(1);
++     }
++-    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
+++    if (buf[0] != i / 2 || buf[SZ / 2 - 1] != i / 2)
+++    {
++       printf("%s: read bigfile wrong data\n", s);
++       exit(1);
++     }
++     total += cc;
++   }
++   close(fd);
++-  if(total != N*SZ){
+++  if (total != N * SZ)
+++  {
++     printf("%s: read bigfile wrong total\n", s);
++     exit(1);
++   }
++   unlink("bigfile.dat");
++ }
++ 
++-void
++-fourteen(char *s)
+++void fourteen(char *s)
++ {
++   int fd;
++ 
++   // DIRSIZ is 14.
++ 
++-  if(mkdir("12345678901234") != 0){
+++  if (mkdir("12345678901234") != 0)
+++  {
++     printf("%s: mkdir 12345678901234 failed\n", s);
++     exit(1);
++   }
++-  if(mkdir("12345678901234/123456789012345") != 0){
+++  if (mkdir("12345678901234/123456789012345") != 0)
+++  {
++     printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
++     exit(1);
++   }
++   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++   fd = open("12345678901234/12345678901234/12345678901234", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  if(mkdir("12345678901234/12345678901234") == 0){
+++  if (mkdir("12345678901234/12345678901234") == 0)
+++  {
++     printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("123456789012345/12345678901234") == 0){
+++  if (mkdir("123456789012345/12345678901234") == 0)
+++  {
++     printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
++     exit(1);
++   }
++@@ -1827,92 +2127,108 @@ fourteen(char *s)
++   unlink("12345678901234");
++ }
++ 
++-void
++-rmdot(char *s)
+++void rmdot(char *s)
++ {
++-  if(mkdir("dots") != 0){
+++  if (mkdir("dots") != 0)
+++  {
++     printf("%s: mkdir dots failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dots") != 0){
+++  if (chdir("dots") != 0)
+++  {
++     printf("%s: chdir dots failed\n", s);
++     exit(1);
++   }
++-  if(unlink(".") == 0){
+++  if (unlink(".") == 0)
+++  {
++     printf("%s: rm . worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("..") == 0){
+++  if (unlink("..") == 0)
+++  {
++     printf("%s: rm .. worked!\n", s);
++     exit(1);
++   }
++-  if(chdir("/") != 0){
+++  if (chdir("/") != 0)
+++  {
++     printf("%s: chdir / failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dots/.") == 0){
+++  if (unlink("dots/.") == 0)
+++  {
++     printf("%s: unlink dots/. worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("dots/..") == 0){
+++  if (unlink("dots/..") == 0)
+++  {
++     printf("%s: unlink dots/.. worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("dots") != 0){
+++  if (unlink("dots") != 0)
+++  {
++     printf("%s: unlink dots failed!\n", s);
++     exit(1);
++   }
++ }
++ 
++-void
++-dirfile(char *s)
+++void dirfile(char *s)
++ {
++   int fd;
++ 
++   fd = open("dirfile", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dirfile failed\n", s);
++     exit(1);
++   }
++   close(fd);
++-  if(chdir("dirfile") == 0){
+++  if (chdir("dirfile") == 0)
+++  {
++     printf("%s: chdir dirfile succeeded!\n", s);
++     exit(1);
++   }
++   fd = open("dirfile/xx", 0);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: create dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++   fd = open("dirfile/xx", O_CREATE);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: create dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dirfile/xx") == 0){
+++  if (mkdir("dirfile/xx") == 0)
+++  {
++     printf("%s: mkdir dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dirfile/xx") == 0){
+++  if (unlink("dirfile/xx") == 0)
+++  {
++     printf("%s: unlink dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("README", "dirfile/xx") == 0){
+++  if (link("README", "dirfile/xx") == 0)
+++  {
++     printf("%s: link to dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dirfile") != 0){
+++  if (unlink("dirfile") != 0)
+++  {
++     printf("%s: unlink dirfile failed!\n", s);
++     exit(1);
++   }
++ 
++   fd = open(".", O_RDWR);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: open . for writing succeeded!\n", s);
++     exit(1);
++   }
++   fd = open(".", 0);
++-  if(write(fd, "x", 1) > 0){
+++  if (write(fd, "x", 1) > 0)
+++  {
++     printf("%s: write . succeeded!\n", s);
++     exit(1);
++   }
++@@ -1921,17 +2237,19 @@ dirfile(char *s)
++ 
++ // test that iput() is called at the end of _namei().
++ // also tests empty file names.
++-void
++-iref(char *s)
+++void iref(char *s)
++ {
++   int i, fd;
++ 
++-  for(i = 0; i < NINODE + 1; i++){
++-    if(mkdir("irefd") != 0){
+++  for (i = 0; i < NINODE + 1; i++)
+++  {
+++    if (mkdir("irefd") != 0)
+++    {
++       printf("%s: mkdir irefd failed\n", s);
++       exit(1);
++     }
++-    if(chdir("irefd") != 0){
+++    if (chdir("irefd") != 0)
+++    {
++       printf("%s: chdir irefd failed\n", s);
++       exit(1);
++     }
++@@ -1939,16 +2257,17 @@ iref(char *s)
++     mkdir("");
++     link("README", "");
++     fd = open("", O_CREATE);
++-    if(fd >= 0)
+++    if (fd >= 0)
++       close(fd);
++     fd = open("xx", O_CREATE);
++-    if(fd >= 0)
+++    if (fd >= 0)
++       close(fd);
++     unlink("xx");
++   }
++ 
++   // clean up
++-  for(i = 0; i < NINODE + 1; i++){
+++  for (i = 0; i < NINODE + 1; i++)
+++  {
++     chdir("..");
++     unlink("irefd");
++   }
++@@ -1959,67 +2278,81 @@ iref(char *s)
++ // test that fork fails gracefully
++ // the forktest binary also does this, but it runs out of proc entries first.
++ // inside the bigger usertests binary, we run out of memory first.
++-void
++-forktest(char *s)
+++void forktest(char *s)
++ {
++-  enum{ N = 1000 };
+++  enum
+++  {
+++    N = 1000
+++  };
++   int n, pid;
++ 
++-  for(n=0; n<N; n++){
+++  for (n = 0; n < N; n++)
+++  {
++     pid = fork();
++-    if(pid < 0)
+++    if (pid < 0)
++       break;
++-    if(pid == 0)
+++    if (pid == 0)
++       exit(0);
++   }
++ 
++-  if (n == 0) {
+++  if (n == 0)
+++  {
++     printf("%s: no fork at all!\n", s);
++     exit(1);
++   }
++ 
++-  if(n == N){
+++  if (n == N)
+++  {
++     printf("%s: fork claimed to work 1000 times!\n", s);
++     exit(1);
++   }
++ 
++-  for(; n > 0; n--){
++-    if(wait(0) < 0){
+++  for (; n > 0; n--)
+++  {
+++    if (wait(0) < 0)
+++    {
++       printf("%s: wait stopped early\n", s);
++       exit(1);
++     }
++   }
++ 
++-  if(wait(0) != -1){
+++  if (wait(0) != -1)
+++  {
++     printf("%s: wait got too many\n", s);
++     exit(1);
++   }
++ }
++ 
++-void
++-sbrkbasic(char *s)
+++void sbrkbasic(char *s)
++ {
++-  enum { TOOMUCH=1024*1024*1024};
+++  enum
+++  {
+++    TOOMUCH = 1024 * 1024 * 1024
+++  };
++   int i, pid, xstatus;
++   char *c, *a, *b;
++ 
++   // does sbrk() return the expected failure value?
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed in sbrkbasic\n");
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     a = sbrk(TOOMUCH);
++-    if(a == (char*)0xffffffffffffffffL){
+++    if (a == (char *)0xffffffffffffffffL)
+++    {
++       // it's OK if this fails.
++       exit(0);
++     }
++-    
++-    for(b = a; b < a+TOOMUCH; b += 4096){
+++
+++    for (b = a; b < a + TOOMUCH; b += 4096)
+++    {
++       *b = 99;
++     }
++-    
+++
++     // we should not get here! either sbrk(TOOMUCH)
++     // should have failed, or (with lazy allocation)
++     // a pagefault should have killed this process.
++@@ -2027,16 +2360,19 @@ sbrkbasic(char *s)
++   }
++ 
++   wait(&xstatus);
++-  if(xstatus == 1){
+++  if (xstatus == 1)
+++  {
++     printf("%s: too much memory allocated!\n", s);
++     exit(1);
++   }
++ 
++   // can one sbrk() less than a page?
++   a = sbrk(0);
++-  for(i = 0; i < 5000; i++){
+++  for (i = 0; i < 5000; i++)
+++  {
++     b = sbrk(1);
++-    if(b != a){
+++    if (b != a)
+++    {
++       printf("%s: sbrk test failed %d %p %p\n", s, i, a, b);
++       exit(1);
++     }
++@@ -2044,26 +2380,30 @@ sbrkbasic(char *s)
++     a = b + 1;
++   }
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: sbrk test fork failed\n", s);
++     exit(1);
++   }
++   c = sbrk(1);
++   c = sbrk(1);
++-  if(c != a + 1){
+++  if (c != a + 1)
+++  {
++     printf("%s: sbrk test failed post-fork\n", s);
++     exit(1);
++   }
++-  if(pid == 0)
+++  if (pid == 0)
++     exit(0);
++   wait(&xstatus);
++   exit(xstatus);
++ }
++ 
++-void
++-sbrkmuch(char *s)
+++void sbrkmuch(char *s)
++ {
++-  enum { BIG=100*1024*1024 };
+++  enum
+++  {
+++    BIG = 100 * 1024 * 1024
+++  };
++   char *c, *oldbrk, *a, *lastaddr, *p;
++   uint64 amt;
++ 
++@@ -2073,28 +2413,31 @@ sbrkmuch(char *s)
++   a = sbrk(0);
++   amt = BIG - (uint64)a;
++   p = sbrk(amt);
++-  if (p != a) {
+++  if (p != a)
+++  {
++     printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
++     exit(1);
++   }
++ 
++   // touch each page to make sure it exists.
++   char *eee = sbrk(0);
++-  for(char *pp = a; pp < eee; pp += 4096)
+++  for (char *pp = a; pp < eee; pp += 4096)
++     *pp = 1;
++ 
++-  lastaddr = (char*) (BIG-1);
+++  lastaddr = (char *)(BIG - 1);
++   *lastaddr = 99;
++ 
++   // can one de-allocate?
++   a = sbrk(0);
++   c = sbrk(-PGSIZE);
++-  if(c == (char*)0xffffffffffffffffL){
+++  if (c == (char *)0xffffffffffffffffL)
+++  {
++     printf("%s: sbrk could not deallocate\n", s);
++     exit(1);
++   }
++   c = sbrk(0);
++-  if(c != a - PGSIZE){
+++  if (c != a - PGSIZE)
+++  {
++     printf("%s: sbrk deallocation produced wrong address, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++@@ -2102,11 +2445,13 @@ sbrkmuch(char *s)
++   // can one re-allocate that page?
++   a = sbrk(0);
++   c = sbrk(PGSIZE);
++-  if(c != a || sbrk(0) != a + PGSIZE){
+++  if (c != a || sbrk(0) != a + PGSIZE)
+++  {
++     printf("%s: sbrk re-allocation failed, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++-  if(*lastaddr == 99){
+++  if (*lastaddr == 99)
+++  {
++     // should be zero
++     printf("%s: sbrk de-allocation didn't really deallocate\n", s);
++     exit(1);
++@@ -2114,118 +2459,134 @@ sbrkmuch(char *s)
++ 
++   a = sbrk(0);
++   c = sbrk(-(sbrk(0) - oldbrk));
++-  if(c != a){
+++  if (c != a)
+++  {
++     printf("%s: sbrk downsize failed, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++ }
++ 
++ // can we read the kernel's memory?
++-void
++-kernmem(char *s)
+++void kernmem(char *s)
++ {
++   char *a;
++   int pid;
++ 
++-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+++  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       printf("%s: oops could read %p = %x\n", s, a, *a);
++       exit(1);
++     }
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != -1)  // did kernel kill child?
+++    if (xstatus != -1) // did kernel kill child?
++       exit(1);
++   }
++ }
++ 
++ // user code should not be able to write to addresses above MAXVA.
++-void
++-MAXVAplus(char *s)
+++void MAXVAplus(char *s)
++ {
++   volatile uint64 a = MAXVA;
++-  for( ; a != 0; a <<= 1){
+++  for (; a != 0; a <<= 1)
+++  {
++     int pid;
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid == 0){
++-      *(char*)a = 99;
++-      printf("%s: oops wrote %p\n", s, (void*)a);
+++    if (pid == 0)
+++    {
+++      *(char *)a = 99;
+++      printf("%s: oops wrote %p\n", s, (void *)a);
++       exit(1);
++     }
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != -1)  // did kernel kill child?
+++    if (xstatus != -1) // did kernel kill child?
++       exit(1);
++   }
++ }
++ 
++ // if we run the system out of memory, does it clean up the last
++ // failed allocation?
++-void
++-sbrkfail(char *s)
+++void sbrkfail(char *s)
++ {
++-  enum { BIG=100*1024*1024 };
+++  enum
+++  {
+++    BIG = 100 * 1024 * 1024
+++  };
++   int i, xstatus;
++   int fds[2];
++   char scratch;
++   char *c, *a;
++   int pids[10];
++   int pid;
++- 
++-  if(pipe(fds) != 0){
+++
+++  if (pipe(fds) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++   }
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if((pids[i] = fork()) == 0){
+++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+++  {
+++    if ((pids[i] = fork()) == 0)
+++    {
++       // allocate a lot of memory
++       sbrk(BIG - (uint64)sbrk(0));
++       write(fds[1], "x", 1);
++       // sit around until killed
++-      for(;;) sleep(1000);
+++      for (;;)
+++        sleep(1000);
++     }
++-    if(pids[i] != -1)
+++    if (pids[i] != -1)
++       read(fds[0], &scratch, 1);
++   }
++ 
++   // if those failed allocations freed up the pages they did allocate,
++   // we'll be able to allocate here
++   c = sbrk(PGSIZE);
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if(pids[i] == -1)
+++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+++  {
+++    if (pids[i] == -1)
++       continue;
++     kill(pids[i]);
++     wait(0);
++   }
++-  if(c == (char*)0xffffffffffffffffL){
+++  if (c == (char *)0xffffffffffffffffL)
+++  {
++     printf("%s: failed sbrk leaked memory\n", s);
++     exit(1);
++   }
++ 
++-  // test running fork with the above allocated page 
+++  // test running fork with the above allocated page
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     // allocate a lot of memory.
++     // this should produce a page fault,
++     // and thus not complete.
++     a = sbrk(0);
++-    sbrk(10*BIG);
+++    sbrk(10 * BIG);
++     int n = 0;
++-    for (i = 0; i < 10*BIG; i += PGSIZE) {
++-      n += *(a+i);
+++    for (i = 0; i < 10 * BIG; i += PGSIZE)
+++    {
+++      n += *(a + i);
++     }
++     // print n so the compiler doesn't optimize away
++     // the for loop.
++@@ -2233,26 +2594,26 @@ sbrkfail(char *s)
++     exit(1);
++   }
++   wait(&xstatus);
++-  if(xstatus != -1 && xstatus != 2)
+++  if (xstatus != -1 && xstatus != 2)
++     exit(1);
++ }
++ 
++-  
++ // test reads/writes from/to allocated memory
++-void
++-sbrkarg(char *s)
+++void sbrkarg(char *s)
++ {
++   char *a;
++   int fd, n;
++ 
++   a = sbrk(PGSIZE);
++-  fd = open("sbrk", O_CREATE|O_WRONLY);
+++  fd = open("sbrk", O_CREATE | O_WRONLY);
++   unlink("sbrk");
++-  if(fd < 0)  {
+++  if (fd < 0)
+++  {
++     printf("%s: open sbrk failed\n", s);
++     exit(1);
++   }
++-  if ((n = write(fd, a, PGSIZE)) < 0) {
+++  if ((n = write(fd, a, PGSIZE)) < 0)
+++  {
++     printf("%s: write sbrk failed\n", s);
++     exit(1);
++   }
++@@ -2260,22 +2621,24 @@ sbrkarg(char *s)
++ 
++   // test writes to allocated memory
++   a = sbrk(PGSIZE);
++-  if(pipe((int *) a) != 0){
+++  if (pipe((int *)a) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++-  } 
+++  }
++ }
++ 
++-void
++-validatetest(char *s)
+++void validatetest(char *s)
++ {
++   int hi;
++   uint64 p;
++ 
++-  hi = 1100*1024;
++-  for(p = 0; p <= (uint)hi; p += PGSIZE){
+++  hi = 1100 * 1024;
+++  for (p = 0; p <= (uint)hi; p += PGSIZE)
+++  {
++     // try to crash the kernel by passing in a bad string pointer
++-    if(link("nosuchfile", (char*)p) != -1){
+++    if (link("nosuchfile", (char *)p) != -1)
+++    {
++       printf("%s: link should not succeed\n", s);
++       exit(1);
++     }
++@@ -2284,13 +2647,14 @@ validatetest(char *s)
++ 
++ // does uninitialized data start out zero?
++ char uninit[10000];
++-void
++-bsstest(char *s)
+++void bsstest(char *s)
++ {
++   int i;
++ 
++-  for(i = 0; i < sizeof(uninit); i++){
++-    if(uninit[i] != '\0'){
+++  for (i = 0; i < sizeof(uninit); i++)
+++  {
+++    if (uninit[i] != '\0')
+++    {
++       printf("%s: bss test failed\n", s);
++       exit(1);
++     }
++@@ -2300,38 +2664,41 @@ bsstest(char *s)
++ // does exec return an error if the arguments
++ // are larger than a page? or does it write
++ // below the stack and wreck the instructions/data?
++-void
++-bigargtest(char *s)
+++void bigargtest(char *s)
++ {
++   int pid, fd, xstatus;
++ 
++   unlink("bigarg-ok");
++   pid = fork();
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     static char *args[MAXARG];
++     int i;
++     char big[400];
++     memset(big, ' ', sizeof(big));
++-    big[sizeof(big)-1] = '\0';
++-    for(i = 0; i < MAXARG-1; i++)
+++    big[sizeof(big) - 1] = '\0';
+++    for (i = 0; i < MAXARG - 1; i++)
++       args[i] = big;
++-    args[MAXARG-1] = 0;
+++    args[MAXARG - 1] = 0;
++     // this exec() should fail (and return) because the
++     // arguments are too large.
++     exec("echo", args);
++     fd = open("bigarg-ok", O_CREATE);
++     close(fd);
++     exit(0);
++-  } else if(pid < 0){
+++  }
+++  else if (pid < 0)
+++  {
++     printf("%s: bigargtest: fork failed\n", s);
++     exit(1);
++   }
++-  
+++
++   wait(&xstatus);
++-  if(xstatus != 0)
+++  if (xstatus != 0)
++     exit(xstatus);
++   fd = open("bigarg-ok", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: bigarg test failed!\n", s);
++     exit(1);
++   }
++@@ -2340,15 +2707,15 @@ bigargtest(char *s)
++ 
++ // what happens when the file system runs out of blocks?
++ // answer: balloc panics, so this test is not useful.
++-void
++-fsfull()
+++void fsfull()
++ {
++   int nfiles;
++   int fsblocks = 0;
++ 
++   printf("fsfull test\n");
++ 
++-  for(nfiles = 0; ; nfiles++){
+++  for (nfiles = 0;; nfiles++)
+++  {
++     char name[64];
++     name[0] = 'f';
++     name[1] = '0' + nfiles / 1000;
++@@ -2357,26 +2724,29 @@ fsfull()
++     name[4] = '0' + (nfiles % 10);
++     name[5] = '\0';
++     printf("writing %s\n", name);
++-    int fd = open(name, O_CREATE|O_RDWR);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR);
+++    if (fd < 0)
+++    {
++       printf("open %s failed\n", name);
++       break;
++     }
++     int total = 0;
++-    while(1){
+++    while (1)
+++    {
++       int cc = write(fd, buf, BSIZE);
++-      if(cc < BSIZE)
+++      if (cc < BSIZE)
++         break;
++       total += cc;
++       fsblocks++;
++     }
++     printf("wrote %d bytes\n", total);
++     close(fd);
++-    if(total == 0)
+++    if (total == 0)
++       break;
++   }
++ 
++-  while(nfiles >= 0){
+++  while (nfiles >= 0)
+++  {
++     char name[64];
++     name[0] = 'f';
++     name[1] = '0' + nfiles / 1000;
++@@ -2395,7 +2765,8 @@ void argptest(char *s)
++ {
++   int fd;
++   fd = open("init", O_RDONLY);
++-  if (fd < 0) {
+++  if (fd < 0)
+++  {
++     printf("%s: open failed\n", s);
++     exit(1);
++   }
++@@ -2405,25 +2776,27 @@ void argptest(char *s)
++ 
++ // check that there's an invalid page beneath
++ // the user stack, to catch stack overflow.
++-void
++-stacktest(char *s)
+++void stacktest(char *s)
++ {
++   int pid;
++   int xstatus;
++-  
+++
++   pid = fork();
++-  if(pid == 0) {
++-    char *sp = (char *) r_sp();
++-    sp -= USERSTACK*PGSIZE;
+++  if (pid == 0)
+++  {
+++    char *sp = (char *)r_sp();
+++    sp -= USERSTACK * PGSIZE;
++     // the *sp should cause a trap.
++     printf("%s: stacktest: read below stack %d\n", s, *sp);
++     exit(1);
++-  } else if(pid < 0){
+++  }
+++  else if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++   wait(&xstatus);
++-  if(xstatus == -1)  // kernel killed child?
+++  if (xstatus == -1) // kernel killed child?
++     exit(0);
++   else
++     exit(xstatus);
++@@ -2431,27 +2804,31 @@ stacktest(char *s)
++ 
++ // check that writes to a few forbidden addresses
++ // cause a fault, e.g. process's text and TRAMPOLINE.
++-void
++-nowrite(char *s)
+++void nowrite(char *s)
++ {
++   int pid;
++   int xstatus;
++-  uint64 addrs[] = { 0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
++-  
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  uint64 addrs[] = {0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
+++
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     pid = fork();
++-    if(pid == 0) {
++-      volatile int *addr = (int *) addrs[ai];
+++    if (pid == 0)
+++    {
+++      volatile int *addr = (int *)addrs[ai];
++       *addr = 10;
++       printf("%s: write to %p did not fail!\n", s, addr);
++       exit(0);
++-    } else if(pid < 0){
+++    }
+++    else if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++     wait(&xstatus);
++-    if(xstatus == 0){
+++    if (xstatus == 0)
+++    {
++       // kernel did not kill child!
++       exit(1);
++     }
++@@ -2462,9 +2839,8 @@ nowrite(char *s)
++ // regression test. copyin(), copyout(), and copyinstr() used to cast
++ // the virtual page address to uint, which (with certain wild system
++ // call arguments) resulted in a kernel page faults.
++-void *big = (void*) 0xeaeb0b5b00002f5e;
++-void
++-pgbug(char *s)
+++void *big = (void *)0xeaeb0b5b00002f5e;
+++void pgbug(char *s)
++ {
++   char *argv[1];
++   argv[0] = 0;
++@@ -2477,16 +2853,17 @@ pgbug(char *s)
++ // regression test. does the kernel panic if a process sbrk()s its
++ // size to be less than a page, or zero, or reduces the break by an
++ // amount too small to cause a page to be freed?
++-void
++-sbrkbugs(char *s)
+++void sbrkbugs(char *s)
++ {
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    int sz = (uint64) sbrk(0);
+++  if (pid == 0)
+++  {
+++    int sz = (uint64)sbrk(0);
++     // free all user memory; there used to be a bug that
++     // would not adjust p->sz correctly in this case,
++     // causing exit() to panic.
++@@ -2497,12 +2874,14 @@ sbrkbugs(char *s)
++   wait(0);
++ 
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    int sz = (uint64) sbrk(0);
+++  if (pid == 0)
+++  {
+++    int sz = (uint64)sbrk(0);
++     // set the break to somewhere in the very first
++     // page; there used to be a bug that would incorrectly
++     // free the first page.
++@@ -2512,13 +2891,15 @@ sbrkbugs(char *s)
++   wait(0);
++ 
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     // set the break in the middle of a page.
++-    sbrk((10*4096 + 2048) - (uint64)sbrk(0));
+++    sbrk((10 * 4096 + 2048) - (uint64)sbrk(0));
++ 
++     // reduce the break a bit, but not enough to
++     // cause a page to be freed. this used to cause
++@@ -2535,123 +2916,119 @@ sbrkbugs(char *s)
++ // if process size was somewhat more than a page boundary, and then
++ // shrunk to be somewhat less than that page boundary, can the kernel
++ // still copyin() from addresses in the last page?
++-void
++-sbrklast(char *s)
+++void sbrklast(char *s)
++ {
++-  uint64 top = (uint64) sbrk(0);
++-  if((top % 4096) != 0)
+++  uint64 top = (uint64)sbrk(0);
+++  if ((top % 4096) != 0)
++     sbrk(4096 - (top % 4096));
++   sbrk(4096);
++   sbrk(10);
++   sbrk(-20);
++-  top = (uint64) sbrk(0);
++-  char *p = (char *) (top - 64);
+++  top = (uint64)sbrk(0);
+++  char *p = (char *)(top - 64);
++   p[0] = 'x';
++   p[1] = '\0';
++-  int fd = open(p, O_RDWR|O_CREATE);
+++  int fd = open(p, O_RDWR | O_CREATE);
++   write(fd, p, 1);
++   close(fd);
++   fd = open(p, O_RDWR);
++   p[0] = '\0';
++   read(fd, p, 1);
++-  if(p[0] != 'x')
+++  if (p[0] != 'x')
++     exit(1);
++ }
++ 
++-
++ // does sbrk handle signed int32 wrap-around with
++ // negative arguments?
++-void
++-sbrk8000(char *s)
+++void sbrk8000(char *s)
++ {
++   sbrk(0x80000004);
++   volatile char *top = sbrk(0);
++-  *(top-1) = *(top-1) + 1;
+++  *(top - 1) = *(top - 1) + 1;
++ }
++ 
++-
++-
++ // regression test. test whether exec() leaks memory if one of the
++ // arguments is invalid. the test passes if the kernel doesn't panic.
++-void
++-badarg(char *s)
+++void badarg(char *s)
++ {
++-  for(int i = 0; i < 50000; i++){
+++  for (int i = 0; i < 50000; i++)
+++  {
++     char *argv[2];
++-    argv[0] = (char*)0xffffffff;
+++    argv[0] = (char *)0xffffffff;
++     argv[1] = 0;
++     exec("echo", argv);
++   }
++-  
+++
++   exit(0);
++ }
++ 
++-struct test {
+++struct test
+++{
++   void (*f)(char *);
++   char *s;
++ } quicktests[] = {
++-  {copyin, "copyin"},
++-  {copyout, "copyout"},
++-  {copyinstr1, "copyinstr1"},
++-  {copyinstr2, "copyinstr2"},
++-  {copyinstr3, "copyinstr3"},
++-  {rwsbrk, "rwsbrk" },
++-  {truncate1, "truncate1"},
++-  {truncate2, "truncate2"},
++-  {truncate3, "truncate3"},
++-  {openiputtest, "openiput"},
++-  {exitiputtest, "exitiput"},
++-  {iputtest, "iput"},
++-  {opentest, "opentest"},
++-  {writetest, "writetest"},
++-  {writebig, "writebig"},
++-  {createtest, "createtest"},
++-  {dirtest, "dirtest"},
++-  {exectest, "exectest"},
++-  {pipe1, "pipe1"},
++-  {killstatus, "killstatus"},
++-  {preempt, "preempt"},
++-  {exitwait, "exitwait"},
++-  {reparent, "reparent" },
++-  {twochildren, "twochildren"},
++-  {forkfork, "forkfork"},
++-  {forkforkfork, "forkforkfork"},
++-  {reparent2, "reparent2"},
++-  {mem, "mem"},
++-  {sharedfd, "sharedfd"},
++-  {fourfiles, "fourfiles"},
++-  {createdelete, "createdelete"},
++-  {unlinkread, "unlinkread"},
++-  {linktest, "linktest"},
++-  {concreate, "concreate"},
++-  {linkunlink, "linkunlink"},
++-  {subdir, "subdir"},
++-  {bigwrite, "bigwrite"},
++-  {bigfile, "bigfile"},
++-  {fourteen, "fourteen"},
++-  {rmdot, "rmdot"},
++-  {dirfile, "dirfile"},
++-  {iref, "iref"},
++-  {forktest, "forktest"},
++-  {sbrkbasic, "sbrkbasic"},
++-  {sbrkmuch, "sbrkmuch"},
++-  {kernmem, "kernmem"},
++-  {MAXVAplus, "MAXVAplus"},
++-  {sbrkfail, "sbrkfail"},
++-  {sbrkarg, "sbrkarg"},
++-  {validatetest, "validatetest"},
++-  {bsstest, "bsstest"},
++-  {bigargtest, "bigargtest"},
++-  {argptest, "argptest"},
++-  {stacktest, "stacktest"},
++-  {nowrite, "nowrite"},
++-  {pgbug, "pgbug" },
++-  {sbrkbugs, "sbrkbugs" },
++-  {sbrklast, "sbrklast"},
++-  {sbrk8000, "sbrk8000"},
++-  {badarg, "badarg" },
++-
++-  { 0, 0},
+++    {copyin, "copyin"},
+++    {copyout, "copyout"},
+++    {copyinstr1, "copyinstr1"},
+++    {copyinstr2, "copyinstr2"},
+++    {copyinstr3, "copyinstr3"},
+++    {rwsbrk, "rwsbrk"},
+++    {truncate1, "truncate1"},
+++    {truncate2, "truncate2"},
+++    {truncate3, "truncate3"},
+++    {openiputtest, "openiput"},
+++    {exitiputtest, "exitiput"},
+++    {iputtest, "iput"},
+++    {opentest, "opentest"},
+++    {writetest, "writetest"},
+++    {writebig, "writebig"},
+++    {createtest, "createtest"},
+++    {dirtest, "dirtest"},
+++    {exectest, "exectest"},
+++    {pipe1, "pipe1"},
+++    {killstatus, "killstatus"},
+++    {preempt, "preempt"},
+++    {exitwait, "exitwait"},
+++    {reparent, "reparent"},
+++    {twochildren, "twochildren"},
+++    {forkfork, "forkfork"},
+++    {forkforkfork, "forkforkfork"},
+++    {reparent2, "reparent2"},
+++    {mem, "mem"},
+++    {sharedfd, "sharedfd"},
+++    {fourfiles, "fourfiles"},
+++    {createdelete, "createdelete"},
+++    {unlinkread, "unlinkread"},
+++    {linktest, "linktest"},
+++    {concreate, "concreate"},
+++    {linkunlink, "linkunlink"},
+++    {subdir, "subdir"},
+++    {bigwrite, "bigwrite"},
+++    {bigfile, "bigfile"},
+++    {fourteen, "fourteen"},
+++    {rmdot, "rmdot"},
+++    {dirfile, "dirfile"},
+++    {iref, "iref"},
+++    {forktest, "forktest"},
+++    {sbrkbasic, "sbrkbasic"},
+++    {sbrkmuch, "sbrkmuch"},
+++    {kernmem, "kernmem"},
+++    {MAXVAplus, "MAXVAplus"},
+++    {sbrkfail, "sbrkfail"},
+++    {sbrkarg, "sbrkarg"},
+++    {validatetest, "validatetest"},
+++    {bsstest, "bsstest"},
+++    {bigargtest, "bigargtest"},
+++    {argptest, "argptest"},
+++    {stacktest, "stacktest"},
+++    {nowrite, "nowrite"},
+++    {pgbug, "pgbug"},
+++    {sbrkbugs, "sbrkbugs"},
+++    {sbrklast, "sbrklast"},
+++    {sbrk8000, "sbrk8000"},
+++    {badarg, "badarg"},
+++
+++    {0, 0},
++ };
++ 
++ //
++@@ -2659,40 +3036,47 @@ struct test {
++ //
++ 
++ // directory that uses indirect blocks
++-void
++-bigdir(char *s)
+++void bigdir(char *s)
++ {
++-  enum { N = 500 };
+++  enum
+++  {
+++    N = 500
+++  };
++   int i, fd;
++   char name[10];
++ 
++   unlink("bd");
++ 
++   fd = open("bd", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: bigdir create failed\n", s);
++     exit(1);
++   }
++   close(fd);
++ 
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[0] = 'x';
++     name[1] = '0' + (i / 64);
++     name[2] = '0' + (i % 64);
++     name[3] = '\0';
++-    if(link("bd", name) != 0){
+++    if (link("bd", name) != 0)
+++    {
++       printf("%s: bigdir i=%d link(bd, %s) failed\n", s, i, name);
++       exit(1);
++     }
++   }
++ 
++   unlink("bd");
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[0] = 'x';
++     name[1] = '0' + (i / 64);
++     name[2] = '0' + (i % 64);
++     name[3] = '\0';
++-    if(unlink(name) != 0){
+++    if (unlink(name) != 0)
+++    {
++       printf("%s: bigdir unlink failed", s);
++       exit(1);
++     }
++@@ -2701,36 +3085,42 @@ bigdir(char *s)
++ 
++ // concurrent writes to try to provoke deadlock in the virtio disk
++ // driver.
++-void
++-manywrites(char *s)
+++void manywrites(char *s)
++ {
++   int nchildren = 4;
++   int howmany = 30; // increase to look for deadlock
++-  
++-  for(int ci = 0; ci < nchildren; ci++){
+++
+++  for (int ci = 0; ci < nchildren; ci++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++     }
++ 
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       char name[3];
++       name[0] = 'b';
++       name[1] = 'a' + ci;
++       name[2] = '\0';
++       unlink(name);
++-      
++-      for(int iters = 0; iters < howmany; iters++){
++-        for(int i = 0; i < ci+1; i++){
+++
+++      for (int iters = 0; iters < howmany; iters++)
+++      {
+++        for (int i = 0; i < ci + 1; i++)
+++        {
++           int fd = open(name, O_CREATE | O_RDWR);
++-          if(fd < 0){
+++          if (fd < 0)
+++          {
++             printf("%s: cannot create %s\n", s, name);
++             exit(1);
++           }
++           int sz = sizeof(buf);
++           int cc = write(fd, buf, sz);
++-          if(cc != sz){
+++          if (cc != sz)
+++          {
++             printf("%s: write(%d) ret %d\n", s, sz, cc);
++             exit(1);
++           }
++@@ -2744,10 +3134,11 @@ manywrites(char *s)
++     }
++   }
++ 
++-  for(int ci = 0; ci < nchildren; ci++){
+++  for (int ci = 0; ci < nchildren; ci++)
+++  {
++     int st = 0;
++     wait(&st);
++-    if(st != 0)
+++    if (st != 0)
++       exit(st);
++   }
++   exit(0);
++@@ -2758,29 +3149,32 @@ manywrites(char *s)
++ // file is deleted? if the kernel has this bug, it will panic: balloc:
++ // out of blocks. assumed_free may need to be raised to be more than
++ // the number of free blocks. this test takes a long time.
++-void
++-badwrite(char *s)
+++void badwrite(char *s)
++ {
++   int assumed_free = 600;
++-  
+++
++   unlink("junk");
++-  for(int i = 0; i < assumed_free; i++){
++-    int fd = open("junk", O_CREATE|O_WRONLY);
++-    if(fd < 0){
+++  for (int i = 0; i < assumed_free; i++)
+++  {
+++    int fd = open("junk", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("open junk failed\n");
++       exit(1);
++     }
++-    write(fd, (char*)0xffffffffffL, 1);
+++    write(fd, (char *)0xffffffffffL, 1);
++     close(fd);
++     unlink("junk");
++   }
++ 
++-  int fd = open("junk", O_CREATE|O_WRONLY);
++-  if(fd < 0){
+++  int fd = open("junk", O_CREATE | O_WRONLY);
+++  if (fd < 0)
+++  {
++     printf("open junk failed\n");
++     exit(1);
++   }
++-  if(write(fd, "x", 1) != 1){
+++  if (write(fd, "x", 1) != 1)
+++  {
++     printf("write failed\n");
++     exit(1);
++   }
++@@ -2793,34 +3187,40 @@ badwrite(char *s)
++ // test the exec() code that cleans up if it runs out
++ // of memory. it's really a test that such a condition
++ // doesn't cause a panic.
++-void
++-execout(char *s)
+++void execout(char *s)
++ {
++-  for(int avail = 0; avail < 15; avail++){
+++  for (int avail = 0; avail < 15; avail++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++-    } else if(pid == 0){
+++    }
+++    else if (pid == 0)
+++    {
++       // allocate all of memory.
++-      while(1){
++-        uint64 a = (uint64) sbrk(4096);
++-        if(a == 0xffffffffffffffffLL)
+++      while (1)
+++      {
+++        uint64 a = (uint64)sbrk(4096);
+++        if (a == 0xffffffffffffffffLL)
++           break;
++-        *(char*)(a + 4096 - 1) = 1;
+++        *(char *)(a + 4096 - 1) = 1;
++       }
++ 
++       // free a few pages, in order to let exec() make some
++       // progress.
++-      for(int i = 0; i < avail; i++)
+++      for (int i = 0; i < avail; i++)
++         sbrk(-4096);
++-      
+++
++       close(1);
++-      char *args[] = { "echo", "x", 0 };
+++      char *args[] = {"echo", "x", 0};
++       exec("echo", args);
++       exit(0);
++-    } else {
++-      wait((int*)0);
+++    }
+++    else
+++    {
+++      wait((int *)0);
++     }
++   }
++ 
++@@ -2828,15 +3228,15 @@ execout(char *s)
++ }
++ 
++ // can the kernel tolerate running out of disk space?
++-void
++-diskfull(char *s)
+++void diskfull(char *s)
++ {
++   int fi;
++   int done = 0;
++ 
++   unlink("diskfulldir");
++-  
++-  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
+++
+++  for (fi = 0; done == 0 && '0' + fi < 0177; fi++)
+++  {
++     char name[32];
++     name[0] = 'b';
++     name[1] = 'i';
++@@ -2844,16 +3244,19 @@ diskfull(char *s)
++     name[3] = '0' + fi;
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
+++    {
++       // oops, ran out of inodes before running out of blocks.
++       printf("%s: could not create file %s\n", s, name);
++       done = 1;
++       break;
++     }
++-    for(int i = 0; i < MAXFILE; i++){
+++    for (int i = 0; i < MAXFILE; i++)
+++    {
++       char buf[BSIZE];
++-      if(write(fd, buf, BSIZE) != BSIZE){
+++      if (write(fd, buf, BSIZE) != BSIZE)
+++      {
++         done = 1;
++         close(fd);
++         break;
++@@ -2867,7 +3270,8 @@ diskfull(char *s)
++   // directory content. one of these file creations
++   // is expected to fail.
++   int nzz = 128;
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2875,19 +3279,20 @@ diskfull(char *s)
++     name[3] = '0' + (i % 32);
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0)
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
++       break;
++     close(fd);
++   }
++ 
++   // this mkdir() is expected to fail.
++-  if(mkdir("diskfulldir") == 0)
+++  if (mkdir("diskfulldir") == 0)
++     printf("%s: mkdir(diskfulldir) unexpectedly succeeded!\n", s);
++ 
++   unlink("diskfulldir");
++ 
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2897,7 +3302,8 @@ diskfull(char *s)
++     unlink(name);
++   }
++ 
++-  for(int i = 0; '0' + i < 0177; i++){
+++  for (int i = 0; '0' + i < 0177; i++)
+++  {
++     char name[32];
++     name[0] = 'b';
++     name[1] = 'i';
++@@ -2908,11 +3314,11 @@ diskfull(char *s)
++   }
++ }
++ 
++-void
++-outofinodes(char *s)
+++void outofinodes(char *s)
++ {
++-  int nzz = 32*32;
++-  for(int i = 0; i < nzz; i++){
+++  int nzz = 32 * 32;
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2920,15 +3326,17 @@ outofinodes(char *s)
++     name[3] = '0' + (i % 32);
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
+++    {
++       // failure is eventually expected.
++       break;
++     }
++     close(fd);
++   }
++ 
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2940,14 +3348,14 @@ outofinodes(char *s)
++ }
++ 
++ struct test slowtests[] = {
++-  {bigdir, "bigdir"},
++-  {manywrites, "manywrites"},
++-  {badwrite, "badwrite" },
++-  {execout, "execout"},
++-  {diskfull, "diskfull"},
++-  {outofinodes, "outofinodes"},
++-    
++-  { 0, 0},
+++    {bigdir, "bigdir"},
+++    {manywrites, "manywrites"},
+++    {badwrite, "badwrite"},
+++    {execout, "execout"},
+++    {diskfull, "diskfull"},
+++    {outofinodes, "outofinodes"},
+++
+++    {0, 0},
++ };
++ 
++ //
++@@ -2956,22 +3364,26 @@ struct test slowtests[] = {
++ 
++ // run each test in its own process. run returns 1 if child's exit()
++ // indicates success.
++-int
++-run(void f(char *), char *s) {
+++int run(void f(char *), char *s)
+++{
++   int pid;
++   int xstatus;
++ 
++   printf("test %s: ", s);
++-  if((pid = fork()) < 0) {
+++  if ((pid = fork()) < 0)
+++  {
++     printf("runtest: fork error\n");
++     exit(1);
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     f(s);
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0) 
+++    if (xstatus != 0)
++       printf("FAILED\n");
++     else
++       printf("OK\n");
++@@ -2979,12 +3391,16 @@ run(void f(char *), char *s) {
++   }
++ }
++ 
++-int
++-runtests(struct test *tests, char *justone, int continuous) {
++-  for (struct test *t = tests; t->s != 0; t++) {
++-    if((justone == 0) || strcmp(t->s, justone) == 0) {
++-      if(!run(t->f, t->s)){
++-        if(continuous != 2){
+++int runtests(struct test *tests, char *justone, int continuous)
+++{
+++  for (struct test *t = tests; t->s != 0; t++)
+++  {
+++    if ((justone == 0) || strcmp(t->s, justone) == 0)
+++    {
+++      if (!run(t->f, t->s))
+++      {
+++        if (continuous != 2)
+++        {
++           printf("SOME TESTS FAILED\n");
++           return 1;
++         }
++@@ -2994,36 +3410,39 @@ runtests(struct test *tests, char *justone, int continuous) {
++   return 0;
++ }
++ 
++-
++ //
++ // use sbrk() to count how many free physical memory pages there are.
++ // touches the pages to force allocation.
++ // because out of memory with lazy allocation results in the process
++ // taking a fault and being killed, fork and report back.
++ //
++-int
++-countfree()
+++int countfree()
++ {
++   int fds[2];
++ 
++-  if(pipe(fds) < 0){
+++  if (pipe(fds) < 0)
+++  {
++     printf("pipe() failed in countfree()\n");
++     exit(1);
++   }
++-  
+++
++   int pid = fork();
++ 
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed in countfree()\n");
++     exit(1);
++   }
++ 
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     close(fds[0]);
++-    
++-    while(1){
++-      uint64 a = (uint64) sbrk(4096);
++-      if(a == 0xffffffffffffffff){
+++
+++    while (1)
+++    {
+++      uint64 a = (uint64)sbrk(4096);
+++      if (a == 0xffffffffffffffff)
+++      {
++         break;
++       }
++ 
++@@ -3031,7 +3450,8 @@ countfree()
++       *(char *)(a + 4096 - 1) = 1;
++ 
++       // report back one more page.
++-      if(write(fds[1], "x", 1) != 1){
+++      if (write(fds[1], "x", 1) != 1)
+++      {
++         printf("write() failed in countfree()\n");
++         exit(1);
++       }
++@@ -3043,74 +3463,93 @@ countfree()
++   close(fds[1]);
++ 
++   int n = 0;
++-  while(1){
+++  while (1)
+++  {
++     char c;
++     int cc = read(fds[0], &c, 1);
++-    if(cc < 0){
+++    if (cc < 0)
+++    {
++       printf("read() failed in countfree()\n");
++       exit(1);
++     }
++-    if(cc == 0)
+++    if (cc == 0)
++       break;
++     n += 1;
++   }
++ 
++   close(fds[0]);
++-  wait((int*)0);
++-  
+++  wait((int *)0);
+++
++   return n;
++ }
++ 
++-int
++-drivetests(int quick, int continuous, char *justone) {
++-  do {
+++int drivetests(int quick, int continuous, char *justone)
+++{
+++  do
+++  {
++     printf("usertests starting\n");
++     int free0 = countfree();
++     int free1 = 0;
++-    if (runtests(quicktests, justone, continuous)) {
++-      if(continuous != 2) {
+++    if (runtests(quicktests, justone, continuous))
+++    {
+++      if (continuous != 2)
+++      {
++         return 1;
++       }
++     }
++-    if(!quick) {
+++    if (!quick)
+++    {
++       if (justone == 0)
++         printf("usertests slow tests starting\n");
++-      if (runtests(slowtests, justone, continuous)) {
++-        if(continuous != 2) {
+++      if (runtests(slowtests, justone, continuous))
+++      {
+++        if (continuous != 2)
+++        {
++           return 1;
++         }
++       }
++     }
++-    if((free1 = countfree()) < free0) {
+++    if ((free1 = countfree()) < free0)
+++    {
++       printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
++-      if(continuous != 2) {
+++      if (continuous != 2)
+++      {
++         return 1;
++       }
++     }
++-  } while(continuous);
+++  } while (continuous);
++   return 0;
++ }
++ 
++-int
++-main(int argc, char *argv[])
+++int main(int argc, char *argv[])
++ {
++   int continuous = 0;
++   int quick = 0;
++   char *justone = 0;
++ 
++-  if(argc == 2 && strcmp(argv[1], "-q") == 0){
+++  if (argc == 2 && strcmp(argv[1], "-q") == 0)
+++  {
++     quick = 1;
++-  } else if(argc == 2 && strcmp(argv[1], "-c") == 0){
+++  }
+++  else if (argc == 2 && strcmp(argv[1], "-c") == 0)
+++  {
++     continuous = 1;
++-  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
+++  }
+++  else if (argc == 2 && strcmp(argv[1], "-C") == 0)
+++  {
++     continuous = 2;
++-  } else if(argc == 2 && argv[1][0] != '-'){
+++  }
+++  else if (argc == 2 && argv[1][0] != '-')
+++  {
++     justone = argv[1];
++-  } else if(argc > 1){
+++  }
+++  else if (argc > 1)
+++  {
++     printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
++     exit(1);
++   }
++-  if (drivetests(quick, continuous, justone)) {
+++  if (drivetests(quick, continuous, justone))
+++  {
++     exit(1);
++   }
++   printf("ALL TESTS PASSED\n");
++diff --git a/offline_2/xv6-riscv-riscv/user/usys.pl b/offline_2/xv6-riscv-riscv/user/usys.pl
++index 01e426e..9d54e5b 100755
++--- a/offline_2/xv6-riscv-riscv/user/usys.pl
+++++ b/offline_2/xv6-riscv-riscv/user/usys.pl
++@@ -36,3 +36,4 @@ entry("getpid");
++ entry("sbrk");
++ entry("sleep");
++ entry("uptime");
+++entry("history");
+diff --git a/offline_2/xv6-riscv-riscv/task1.patch b/offline_2/xv6-riscv-riscv/task1.patch
+new file mode 100644
+index 0000000..adab613
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/task1.patch
+@@ -0,0 +1,4730 @@
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
++new file mode 100644
++index 0000000..c2098a2
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/c_cpp_properties.json
++@@ -0,0 +1,18 @@
+++{
+++  "configurations": [
+++    {
+++      "name": "linux-gcc-x64",
+++      "includePath": [
+++        "${workspaceFolder}/**"
+++      ],
+++      "compilerPath": "/usr/bin/gcc",
+++      "cStandard": "${default}",
+++      "cppStandard": "${default}",
+++      "intelliSenseMode": "linux-gcc-x64",
+++      "compilerArgs": [
+++        ""
+++      ]
+++    }
+++  ],
+++  "version": 4
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/launch.json b/offline_2/xv6-riscv-riscv/.vscode/launch.json
++new file mode 100644
++index 0000000..cc00405
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/launch.json
++@@ -0,0 +1,24 @@
+++{
+++  "version": "0.2.0",
+++  "configurations": [
+++    {
+++      "name": "C/C++ Runner: Debug Session",
+++      "type": "cppdbg",
+++      "request": "launch",
+++      "args": [],
+++      "stopAtEntry": false,
+++      "externalConsole": false,
+++      "cwd": ".",
+++      "program": "build/Debug/outDebug",
+++      "MIMode": "gdb",
+++      "miDebuggerPath": "gdb",
+++      "setupCommands": [
+++        {
+++          "description": "Enable pretty-printing for gdb",
+++          "text": "-enable-pretty-printing",
+++          "ignoreFailures": true
+++        }
+++      ]
+++    }
+++  ]
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/.vscode/settings.json b/offline_2/xv6-riscv-riscv/.vscode/settings.json
++new file mode 100644
++index 0000000..bb879da
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/.vscode/settings.json
++@@ -0,0 +1,59 @@
+++{
+++  "C_Cpp_Runner.cCompilerPath": "gcc",
+++  "C_Cpp_Runner.cppCompilerPath": "g++",
+++  "C_Cpp_Runner.debuggerPath": "gdb",
+++  "C_Cpp_Runner.cStandard": "",
+++  "C_Cpp_Runner.cppStandard": "",
+++  "C_Cpp_Runner.msvcBatchPath": "C:/Program Files/Microsoft Visual Studio/VR_NR/Community/VC/Auxiliary/Build/vcvarsall.bat",
+++  "C_Cpp_Runner.useMsvc": false,
+++  "C_Cpp_Runner.warnings": [
+++    "-Wall",
+++    "-Wextra",
+++    "-Wpedantic",
+++    "-Wshadow",
+++    "-Wformat=2",
+++    "-Wcast-align",
+++    "-Wconversion",
+++    "-Wsign-conversion",
+++    "-Wnull-dereference"
+++  ],
+++  "C_Cpp_Runner.msvcWarnings": [
+++    "/W4",
+++    "/permissive-",
+++    "/w14242",
+++    "/w14287",
+++    "/w14296",
+++    "/w14311",
+++    "/w14826",
+++    "/w44062",
+++    "/w44242",
+++    "/w14905",
+++    "/w14906",
+++    "/w14263",
+++    "/w44265",
+++    "/w14928"
+++  ],
+++  "C_Cpp_Runner.enableWarnings": true,
+++  "C_Cpp_Runner.warningsAsError": false,
+++  "C_Cpp_Runner.compilerArgs": [],
+++  "C_Cpp_Runner.linkerArgs": [],
+++  "C_Cpp_Runner.includePaths": [],
+++  "C_Cpp_Runner.includeSearch": [
+++    "*",
+++    "**/*"
+++  ],
+++  "C_Cpp_Runner.excludeSearch": [
+++    "**/build",
+++    "**/build/**",
+++    "**/.*",
+++    "**/.*/**",
+++    "**/.vscode",
+++    "**/.vscode/**"
+++  ],
+++  "C_Cpp_Runner.useAddressSanitizer": false,
+++  "C_Cpp_Runner.useUndefinedSanitizer": false,
+++  "C_Cpp_Runner.useLeakSanitizer": false,
+++  "C_Cpp_Runner.showCompilationTime": false,
+++  "C_Cpp_Runner.useLinkTimeOptimization": false,
+++  "C_Cpp_Runner.msvcSecureNoWarnings": false
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/Makefile b/offline_2/xv6-riscv-riscv/Makefile
++index f8c820e..546ecf9 100644
++--- a/offline_2/xv6-riscv-riscv/Makefile
+++++ b/offline_2/xv6-riscv-riscv/Makefile
++@@ -139,6 +139,8 @@ UPROGS=\
++	$U/_grind\
++	$U/_wc\
++	$U/_zombie\
+++	$U/_history\
+++
++
++ fs.img: mkfs/mkfs README $(UPROGS)
++	mkfs/mkfs fs.img README $(UPROGS)
++diff --git a/offline_2/xv6-riscv-riscv/kernel/main.c b/offline_2/xv6-riscv-riscv/kernel/main.c
++index f0d3171..d62bd0a 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/main.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/main.c
++@@ -3,43 +3,86 @@
++ #include "memlayout.h"
++ #include "riscv.h"
++ #include "defs.h"
++-
+++#include "syscall.h"
+++#include "syscall_stat.h"
+++#include "spinlock.h"
++ volatile static int started = 0;
++
+++// struct syscall_stat syscall_stats[50];
+++
+++const char *syscall_names[] = {
+++    [SYS_fork] "fork",
+++    [SYS_exit] "exit",
+++    [SYS_wait] "wait",
+++    [SYS_pipe] "pipe",
+++    [SYS_read] "read",
+++    [SYS_kill] "kill",
+++    [SYS_exec] "exec",
+++    [SYS_fstat] "fstat",
+++    [SYS_chdir] "chdir",
+++    [SYS_dup] "dup",
+++    [SYS_getpid] "getpid",
+++    [SYS_sbrk] "sbrk",
+++    [SYS_sleep] "sleep",
+++    [SYS_uptime] "uptime",
+++    [SYS_open] "open",
+++    [SYS_write] "write",
+++    [SYS_mknod] "mknod",
+++    [SYS_unlink] "unlink",
+++    [SYS_link] "link",
+++    [SYS_mkdir] "mkdir",
+++    [SYS_close] "close",
+++    [SYS_history] "history",
+++};
++ // start() jumps here in supervisor mode on all CPUs.
++-void
++-main()
+++
+++void initialize_sys_call_stat()
++ {
++-  if(cpuid() == 0){
+++  for (int i = 1; i < NELEM(syscall_names); i++)
+++  {
+++    initlock(&syscall_stats[i].syscall_stat_lock, "syscall_stat_lock");
+++    strncpy(syscall_stats[i].syscall_name, syscall_names[i], sizeof(syscall_stats[i].syscall_name));
+++    syscall_stats[i].count = 0;
+++    syscall_stats[i].accum_time = 0;
+++  }
+++}
+++
+++void main()
+++{
+++  if (cpuid() == 0)
+++  {
++     consoleinit();
++     printfinit();
++     printf("\n");
++     printf("xv6 kernel is booting\n");
++     printf("\n");
++-    kinit();         // physical page allocator
++-    kvminit();       // create kernel page table
++-    kvminithart();   // turn on paging
++-    procinit();      // process table
++-    trapinit();      // trap vectors
++-    trapinithart();  // install kernel trap vector
++-    plicinit();      // set up interrupt controller
++-    plicinithart();  // ask PLIC for device interrupts
++-    binit();         // buffer cache
++-    iinit();         // inode table
++-    fileinit();      // file table
+++    kinit();            // physical page allocator
+++    kvminit();          // create kernel page table
+++    kvminithart();      // turn on paging
+++    procinit();         // process table
+++    trapinit();         // trap vectors
+++    trapinithart();     // install kernel trap vector
+++    plicinit();         // set up interrupt controller
+++    plicinithart();     // ask PLIC for device interrupts
+++    binit();            // buffer cache
+++    iinit();            // inode table
+++    fileinit();         // file table
++     virtio_disk_init(); // emulated hard disk
++-    userinit();      // first user process
+++    initialize_sys_call_stat();
+++    userinit();         // first user process
++     __sync_synchronize();
++     started = 1;
++-  } else {
++-    while(started == 0)
+++  }
+++  else
+++  {
+++    while (started == 0)
++       ;
++     __sync_synchronize();
++     printf("hart %d starting\n", cpuid());
++-    kvminithart();    // turn on paging
++-    trapinithart();   // install kernel trap vector
++-    plicinithart();   // ask PLIC for device interrupts
+++    kvminithart();  // turn on paging
+++    trapinithart(); // install kernel trap vector
+++    plicinithart(); // ask PLIC for device interrupts
++   }
++-
++-  scheduler();
+++
+++  scheduler();
++ }
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.c b/offline_2/xv6-riscv-riscv/kernel/syscall.c
++index ed65409..35b9ff0 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.c
++@@ -6,6 +6,7 @@
++ #include "proc.h"
++ #include "syscall.h"
++ #include "defs.h"
+++#include "syscall_stat.h"
++
++ // Fetch the uint64 at addr from the current process.
++ int
++@@ -101,7 +102,8 @@ extern uint64 sys_unlink(void);
++ extern uint64 sys_link(void);
++ extern uint64 sys_mkdir(void);
++ extern uint64 sys_close(void);
++-
+++extern uint64 sys_history(void);
+++extern uint ticks;
++ // An array mapping syscall numbers from syscall.h
++ // to the function that handles the system call.
++ static uint64 (*syscalls[])(void) = {
++@@ -126,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
++ [SYS_link]    sys_link,
++ [SYS_mkdir]   sys_mkdir,
++ [SYS_close]   sys_close,
+++[SYS_history] sys_history,
++ };
++
++ void
++@@ -133,15 +136,23 @@ syscall(void)
++ {
++   int num;
++   struct proc *p = myproc();
++-
+++  uint start_ticks = ticks;
++   num = p->trapframe->a7;
++   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
++     // Use num to lookup the system call function for num, call it,
++     // and store its return value in p->trapframe->a0
+++
+++    //update the syscall statistics
++     p->trapframe->a0 = syscalls[num]();
++   } else {
++     printf("%d %s: unknown sys call %d\n",
++             p->pid, p->name, num);
++     p->trapframe->a0 = -1;
++   }
+++  uint end_ticks = ticks;
+++  // Update syscall statistics
+++  acquire(&syscall_stats[num].syscall_stat_lock);
+++  syscall_stats[num].count++;
+++  syscall_stats[num].accum_time += (end_ticks - start_ticks);
+++  release(&syscall_stats[num].syscall_stat_lock);
++ }
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall.h b/offline_2/xv6-riscv-riscv/kernel/syscall.h
++index bc5f356..3b56b8f 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/syscall.h
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall.h
++@@ -20,3 +20,4 @@
++ #define SYS_link   19
++ #define SYS_mkdir  20
++ #define SYS_close  21
+++#define SYS_history 22
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
++new file mode 100644
++index 0000000..7066b76
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/kernel/syscall_stat.h
++@@ -0,0 +1,10 @@
+++#include "spinlock.h"
+++
+++struct syscall_stat {
+++    char syscall_name[16];
+++    int count;
+++    int accum_time;
+++    struct spinlock syscall_stat_lock;
+++};
+++
+++extern struct syscall_stat syscall_stats[50];
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/kernel/sysproc.c b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++index 3b4d5bd..10b0e2c 100644
++--- a/offline_2/xv6-riscv-riscv/kernel/sysproc.c
+++++ b/offline_2/xv6-riscv-riscv/kernel/sysproc.c
++@@ -5,6 +5,8 @@
++ #include "memlayout.h"
++ #include "spinlock.h"
++ #include "proc.h"
+++#include "syscall.h"
+++#include "syscall_stat.h"
++
++ uint64
++ sys_exit(void)
++@@ -12,7 +14,7 @@ sys_exit(void)
++   int n;
++   argint(0, &n);
++   exit(n);
++-  return 0;  // not reached
+++  return 0; // not reached
++ }
++
++ uint64
++@@ -43,7 +45,7 @@ sys_sbrk(void)
++
++   argint(0, &n);
++   addr = myproc()->sz;
++-  if(growproc(n) < 0)
+++  if (growproc(n) < 0)
++     return -1;
++   return addr;
++ }
++@@ -55,12 +57,14 @@ sys_sleep(void)
++   uint ticks0;
++
++   argint(0, &n);
++-  if(n < 0)
+++  if (n < 0)
++     n = 0;
++   acquire(&tickslock);
++   ticks0 = ticks;
++-  while(ticks - ticks0 < n){
++-    if(killed(myproc())){
+++  while (ticks - ticks0 < n)
+++  {
+++    if (killed(myproc()))
+++    {
++       release(&tickslock);
++       return -1;
++     }
++@@ -91,3 +95,37 @@ sys_uptime(void)
++   release(&tickslock);
++   return xticks;
++ }
+++
+++uint64
+++sys_history(void)
+++{
+++  int syscall_num;
+++  uint64 userspace_struct_address;
+++
+++  argint(0, &syscall_num);
+++  argaddr(1, &userspace_struct_address);
+++  if (syscall_num < 0 || syscall_num >= NELEM(syscall_stats))
+++  {
+++    return -1;
+++  }
+++  struct syscall_stat temp_stat;
+++  // acquire lock
+++  acquire(&syscall_stats[syscall_num].syscall_stat_lock);
+++  // temp_stat = syscall_stats[syscall_num];
+++  memmove(&temp_stat, &syscall_stats[syscall_num], sizeof(temp_stat));
+++  release(&syscall_stats[syscall_num].syscall_stat_lock);
+++  // Ensure the syscall name is null-terminated
+++  temp_stat.syscall_name[sizeof(temp_stat.syscall_name) - 1] = '\0';
+++  // Check if the userspace address is valid
+++  if (userspace_struct_address + sizeof(temp_stat) >= MAXVA)
+++  {
+++    return -1;
+++  }
+++  // Copy the syscall statistics to user space
+++  int ret_val = copyout(myproc()->pagetable, userspace_struct_address, (char *)&temp_stat, sizeof(temp_stat));
+++  if (ret_val < 0)
+++  {
+++    return -1;
+++  }
+++  return 0;
+++}
++diff --git a/offline_2/xv6-riscv-riscv/user/history.c b/offline_2/xv6-riscv-riscv/user/history.c
++new file mode 100644
++index 0000000..54e980a
++--- /dev/null
+++++ b/offline_2/xv6-riscv-riscv/user/history.c
++@@ -0,0 +1,47 @@
+++#include "kernel/types.h"
+++#include "kernel/stat.h"
+++#include "user/user.h"
+++#include "kernel/syscall.h"
+++#include "kernel/syscall_stat.h"
+++
+++void print_history(int syscall_num)
+++{
+++    struct syscall_stat s_stat;
+++
+++    if (history(syscall_num, &s_stat) == 0)
+++    {
+++        printf("%d: syscall: %s, #: %d, time: %d\n",
+++               syscall_num,
+++               s_stat.syscall_name,
+++               s_stat.count,
+++               s_stat.accum_time);
+++    }
+++    else
+++    {
+++        printf("Error fetching history for syscall %d\n", syscall_num);
+++    }
+++}
+++
+++int main(int argc, char *argv[])
+++{
+++    if (argc < 2)
+++    {
+++        // No arguments, print all
+++        for (int i = 1; i <= 24; i++)
+++            print_history(i);
+++    }
+++    else
+++    {
+++        int syscall_num = atoi(argv[1]);
+++        if (syscall_num > 0)
+++        {
+++            print_history(syscall_num);
+++        }
+++        else
+++        {
+++            printf("Invalid syscall number.\n");
+++        }
+++    }
+++
+++    exit(0);
+++}
++\ No newline at end of file
++diff --git a/offline_2/xv6-riscv-riscv/user/user.h b/offline_2/xv6-riscv-riscv/user/user.h
++index f16fe27..1cb3ac8 100644
++--- a/offline_2/xv6-riscv-riscv/user/user.h
+++++ b/offline_2/xv6-riscv-riscv/user/user.h
++@@ -1,5 +1,5 @@
++ struct stat;
++-
+++struct syscall_stat;
++ // system calls
++ int fork(void);
++ int exit(int) __attribute__((noreturn));
++@@ -22,6 +22,7 @@ int getpid(void);
++ char* sbrk(int);
++ int sleep(int);
++ int uptime(void);
+++int history(int, struct syscall_stat*);
++
++ // ulib.c
++ int stat(const char*, struct stat*);
++diff --git a/offline_2/xv6-riscv-riscv/user/usertests.c b/offline_2/xv6-riscv-riscv/user/usertests.c
++index 28b53f9..4273164 100644
++--- a/offline_2/xv6-riscv-riscv/user/usertests.c
+++++ b/offline_2/xv6-riscv-riscv/user/usertests.c
++@@ -17,7 +17,7 @@
++ // prints "OK".
++ //
++
++-#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
+++#define BUFSZ ((MAXOPBLOCKS + 2) * BSIZE)
++
++ char buf[BUFSZ];
++
++@@ -29,42 +29,47 @@ char buf[BUFSZ];
++
++ // what if you pass ridiculous pointers to system calls
++ // that read user memory with copyin?
++-void
++-copyin(char *s)
+++void copyin(char *s)
++ {
++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++-
++-    int fd = open("copyin1", O_CREATE|O_WRONLY);
++-    if(fd < 0){
+++
+++    int fd = open("copyin1", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("open(copyin1) failed\n");
++       exit(1);
++     }
++-    int n = write(fd, (void*)addr, 8192);
++-    if(n >= 0){
++-      printf("write(fd, %p, 8192) returned %d, not -1\n", (void*)addr, n);
+++    int n = write(fd, (void *)addr, 8192);
+++    if (n >= 0)
+++    {
+++      printf("write(fd, %p, 8192) returned %d, not -1\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fd);
++     unlink("copyin1");
++-
++-    n = write(1, (char*)addr, 8192);
++-    if(n > 0){
++-      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++
+++    n = write(1, (char *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++-
+++
++     int fds[2];
++-    if(pipe(fds) < 0){
+++    if (pipe(fds) < 0)
+++    {
++       printf("pipe() failed\n");
++       exit(1);
++     }
++-    n = write(fds[1], (char*)addr, 8192);
++-    if(n > 0){
++-      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    n = write(fds[1], (char *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fds[0]);
++@@ -74,40 +79,45 @@ copyin(char *s)
++
++ // what if you pass ridiculous pointers to system calls
++ // that write user memory with copyout?
++-void
++-copyout(char *s)
+++void copyout(char *s)
++ {
++-  uint64 addrs[] = { 0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++
++     int fd = open("README", 0);
++-    if(fd < 0){
+++    if (fd < 0)
+++    {
++       printf("open(README) failed\n");
++       exit(1);
++     }
++-    int n = read(fd, (void*)addr, 8192);
++-    if(n > 0){
++-      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    int n = read(fd, (void *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fd);
++
++     int fds[2];
++-    if(pipe(fds) < 0){
+++    if (pipe(fds) < 0)
+++    {
++       printf("pipe() failed\n");
++       exit(1);
++     }
++     n = write(fds[1], "x", 1);
++-    if(n != 1){
+++    if (n != 1)
+++    {
++       printf("pipe write failed\n");
++       exit(1);
++     }
++-    n = read(fds[0], (void*)addr, 8192);
++-    if(n > 0){
++-      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+++    n = read(fds[0], (void *)addr, 8192);
+++    if (n > 0)
+++    {
+++      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
++       exit(1);
++     }
++     close(fds[0]);
++@@ -116,18 +126,19 @@ copyout(char *s)
++ }
++
++ // what if you pass ridiculous string pointers to system calls?
++-void
++-copyinstr1(char *s)
+++void copyinstr1(char *s)
++ {
++-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
+++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
++
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     uint64 addr = addrs[ai];
++
++-    int fd = open((char *)addr, O_CREATE|O_WRONLY);
++-    if(fd >= 0){
++-      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
+++    int fd = open((char *)addr, O_CREATE | O_WRONLY);
+++    if (fd >= 0)
+++    {
+++      printf("open(%p) returned %d, not -1\n", (void *)addr, fd);
++       exit(1);
++     }
++   }
++@@ -136,53 +147,59 @@ copyinstr1(char *s)
++ // what if a string system call argument is exactly the size
++ // of the kernel buffer it is copied into, so that the null
++ // would fall just beyond the end of the kernel buffer?
++-void
++-copyinstr2(char *s)
+++void copyinstr2(char *s)
++ {
++-  char b[MAXPATH+1];
+++  char b[MAXPATH + 1];
++
++-  for(int i = 0; i < MAXPATH; i++)
+++  for (int i = 0; i < MAXPATH; i++)
++     b[i] = 'x';
++   b[MAXPATH] = '\0';
++-
+++
++   int ret = unlink(b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("unlink(%s) returned %d, not -1\n", b, ret);
++     exit(1);
++   }
++
++   int fd = open(b, O_CREATE | O_WRONLY);
++-  if(fd != -1){
+++  if (fd != -1)
+++  {
++     printf("open(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++
++   ret = link(b, b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
++     exit(1);
++   }
++
++-  char *args[] = { "xx", 0 };
+++  char *args[] = {"xx", 0};
++   ret = exec(b, args);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("exec(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    static char big[PGSIZE+1];
++-    for(int i = 0; i < PGSIZE; i++)
+++  if (pid == 0)
+++  {
+++    static char big[PGSIZE + 1];
+++    for (int i = 0; i < PGSIZE; i++)
++       big[i] = 'x';
++     big[PGSIZE] = '\0';
++-    char *args2[] = { big, big, big, 0 };
+++    char *args2[] = {big, big, big, 0};
++     ret = exec("echo", args2);
++-    if(ret != -1){
+++    if (ret != -1)
+++    {
++       printf("exec(echo, BIG) returned %d, not -1\n", fd);
++       exit(1);
++     }
++@@ -191,51 +208,57 @@ copyinstr2(char *s)
++
++   int st = 0;
++   wait(&st);
++-  if(st != 747){
+++  if (st != 747)
+++  {
++     printf("exec(echo, BIG) succeeded, should have failed\n");
++     exit(1);
++   }
++ }
++
++ // what if a string argument crosses over the end of last user page?
++-void
++-copyinstr3(char *s)
+++void copyinstr3(char *s)
++ {
++   sbrk(8192);
++-  uint64 top = (uint64) sbrk(0);
++-  if((top % PGSIZE) != 0){
+++  uint64 top = (uint64)sbrk(0);
+++  if ((top % PGSIZE) != 0)
+++  {
++     sbrk(PGSIZE - (top % PGSIZE));
++   }
++-  top = (uint64) sbrk(0);
++-  if(top % PGSIZE){
+++  top = (uint64)sbrk(0);
+++  if (top % PGSIZE)
+++  {
++     printf("oops\n");
++     exit(1);
++   }
++
++-  char *b = (char *) (top - 1);
+++  char *b = (char *)(top - 1);
++   *b = 'x';
++
++   int ret = unlink(b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("unlink(%s) returned %d, not -1\n", b, ret);
++     exit(1);
++   }
++
++   int fd = open(b, O_CREATE | O_WRONLY);
++-  if(fd != -1){
+++  if (fd != -1)
+++  {
++     printf("open(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++
++   ret = link(b, b);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
++     exit(1);
++   }
++
++-  char *args[] = { "xx", 0 };
+++  char *args[] = {"xx", 0};
++   ret = exec(b, args);
++-  if(ret != -1){
+++  if (ret != -1)
+++  {
++     printf("exec(%s) returned %d, not -1\n", b, fd);
++     exit(1);
++   }
++@@ -243,96 +266,105 @@ copyinstr3(char *s)
++
++ // See if the kernel refuses to read/write user memory that the
++ // application doesn't have anymore, because it returned it.
++-void
++-rwsbrk()
+++void rwsbrk(char *)
++ {
++   int fd, n;
++-
++-  uint64 a = (uint64) sbrk(8192);
++
++-  if(a == 0xffffffffffffffffLL) {
+++  uint64 a = (uint64)sbrk(8192);
+++
+++  if (a == 0xffffffffffffffffLL)
+++  {
++     printf("sbrk(rwsbrk) failed\n");
++     exit(1);
++   }
++-
++-  if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
+++
+++  if ((uint64)sbrk(-8192) == 0xffffffffffffffffLL)
+++  {
++     printf("sbrk(rwsbrk) shrink failed\n");
++     exit(1);
++   }
++
++-  fd = open("rwsbrk", O_CREATE|O_WRONLY);
++-  if(fd < 0){
+++  fd = open("rwsbrk", O_CREATE | O_WRONLY);
+++  if (fd < 0)
+++  {
++     printf("open(rwsbrk) failed\n");
++     exit(1);
++   }
++-  n = write(fd, (void*)(a+4096), 1024);
++-  if(n >= 0){
++-    printf("write(fd, %p, 1024) returned %d, not -1\n", (void*)a+4096, n);
+++  n = write(fd, (void *)(a + 4096), 1024);
+++  if (n >= 0)
+++  {
+++    printf("write(fd, %p, 1024) returned %d, not -1\n", (void *)a + 4096, n);
++     exit(1);
++   }
++   close(fd);
++   unlink("rwsbrk");
++
++   fd = open("README", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("open(rwsbrk) failed\n");
++     exit(1);
++   }
++-  n = read(fd, (void*)(a+4096), 10);
++-  if(n >= 0){
++-    printf("read(fd, %p, 10) returned %d, not -1\n", (void*)a+4096, n);
+++  n = read(fd, (void *)(a + 4096), 10);
+++  if (n >= 0)
+++  {
+++    printf("read(fd, %p, 10) returned %d, not -1\n", (void *)a + 4096, n);
++     exit(1);
++   }
++   close(fd);
++-
+++
++   exit(0);
++ }
++
++ // test O_TRUNC.
++-void
++-truncate1(char *s)
+++void truncate1(char *s)
++ {
++   char buf[32];
++-
+++
++   unlink("truncfile");
++-  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+++  int fd1 = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
++   write(fd1, "abcd", 4);
++   close(fd1);
++
++   int fd2 = open("truncfile", O_RDONLY);
++   int n = read(fd2, buf, sizeof(buf));
++-  if(n != 4){
+++  if (n != 4)
+++  {
++     printf("%s: read %d bytes, wanted 4\n", s, n);
++     exit(1);
++   }
++
++-  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
+++  fd1 = open("truncfile", O_WRONLY | O_TRUNC);
++
++   int fd3 = open("truncfile", O_RDONLY);
++   n = read(fd3, buf, sizeof(buf));
++-  if(n != 0){
+++  if (n != 0)
+++  {
++     printf("aaa fd3=%d\n", fd3);
++     printf("%s: read %d bytes, wanted 0\n", s, n);
++     exit(1);
++   }
++
++   n = read(fd2, buf, sizeof(buf));
++-  if(n != 0){
+++  if (n != 0)
+++  {
++     printf("bbb fd2=%d\n", fd2);
++     printf("%s: read %d bytes, wanted 0\n", s, n);
++     exit(1);
++   }
++-
+++
++   write(fd1, "abcdef", 6);
++
++   n = read(fd3, buf, sizeof(buf));
++-  if(n != 6){
+++  if (n != 6)
+++  {
++     printf("%s: read %d bytes, wanted 6\n", s, n);
++     exit(1);
++   }
++
++   n = read(fd2, buf, sizeof(buf));
++-  if(n != 2){
+++  if (n != 2)
+++  {
++     printf("%s: read %d bytes, wanted 2\n", s, n);
++     exit(1);
++   }
++@@ -348,18 +380,18 @@ truncate1(char *s)
++ // this causes a write at an offset beyond the end of the file.
++ // such writes fail on xv6 (unlike POSIX) but at least
++ // they don't crash.
++-void
++-truncate2(char *s)
+++void truncate2(char *s)
++ {
++   unlink("truncfile");
++
++-  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
+++  int fd1 = open("truncfile", O_CREATE | O_TRUNC | O_WRONLY);
++   write(fd1, "abcd", 4);
++
++-  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
+++  int fd2 = open("truncfile", O_TRUNC | O_WRONLY);
++
++   int n = write(fd1, "x", 1);
++-  if(n != -1){
+++  if (n != -1)
+++  {
++     printf("%s: write returned %d, expected -1\n", s, n);
++     exit(1);
++   }
++@@ -369,29 +401,33 @@ truncate2(char *s)
++   close(fd2);
++ }
++
++-void
++-truncate3(char *s)
+++void truncate3(char *s)
++ {
++   int pid, xstatus;
++
++-  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
++-
+++  close(open("truncfile", O_CREATE | O_TRUNC | O_WRONLY));
+++
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++
++-  if(pid == 0){
++-    for(int i = 0; i < 100; i++){
+++  if (pid == 0)
+++  {
+++    for (int i = 0; i < 100; i++)
+++    {
++       char buf[32];
++       int fd = open("truncfile", O_WRONLY);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("%s: open failed\n", s);
++         exit(1);
++       }
++       int n = write(fd, "1234567890", 10);
++-      if(n != 10){
+++      if (n != 10)
+++      {
++         printf("%s: write got %d, expected 10\n", s, n);
++         exit(1);
++       }
++@@ -403,14 +439,17 @@ truncate3(char *s)
++     exit(0);
++   }
++
++-  for(int i = 0; i < 150; i++){
++-    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
++-    if(fd < 0){
+++  for (int i = 0; i < 150; i++)
+++  {
+++    int fd = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
+++    if (fd < 0)
+++    {
++       printf("%s: open failed\n", s);
++       exit(1);
++     }
++     int n = write(fd, "xxx", 3);
++-    if(n != 3){
+++    if (n != 3)
+++    {
++       printf("%s: write got %d, expected 3\n", s, n);
++       exit(1);
++     }
++@@ -421,51 +460,57 @@ truncate3(char *s)
++   unlink("truncfile");
++   exit(xstatus);
++ }
++-
++
++ // does chdir() call iput(p->cwd) in a transaction?
++-void
++-iputtest(char *s)
+++void iputtest(char *s)
++ {
++-  if(mkdir("iputdir") < 0){
+++  if (mkdir("iputdir") < 0)
+++  {
++     printf("%s: mkdir failed\n", s);
++     exit(1);
++   }
++-  if(chdir("iputdir") < 0){
+++  if (chdir("iputdir") < 0)
+++  {
++     printf("%s: chdir iputdir failed\n", s);
++     exit(1);
++   }
++-  if(unlink("../iputdir") < 0){
+++  if (unlink("../iputdir") < 0)
+++  {
++     printf("%s: unlink ../iputdir failed\n", s);
++     exit(1);
++   }
++-  if(chdir("/") < 0){
+++  if (chdir("/") < 0)
+++  {
++     printf("%s: chdir / failed\n", s);
++     exit(1);
++   }
++ }
++
++ // does exit() call iput(p->cwd) in a transaction?
++-void
++-exitiputtest(char *s)
+++void exitiputtest(char *s)
++ {
++   int pid, xstatus;
++
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
++-    if(mkdir("iputdir") < 0){
+++  if (pid == 0)
+++  {
+++    if (mkdir("iputdir") < 0)
+++    {
++       printf("%s: mkdir failed\n", s);
++       exit(1);
++     }
++-    if(chdir("iputdir") < 0){
+++    if (chdir("iputdir") < 0)
+++    {
++       printf("%s: child chdir failed\n", s);
++       exit(1);
++     }
++-    if(unlink("../iputdir") < 0){
+++    if (unlink("../iputdir") < 0)
+++    {
++       printf("%s: unlink ../iputdir failed\n", s);
++       exit(1);
++     }
++@@ -486,30 +531,34 @@ exitiputtest(char *s)
++ //      for(i = 0; i < 10000; i++)
++ //        yield();
++ //    }
++-void
++-openiputtest(char *s)
+++void openiputtest(char *s)
++ {
++   int pid, xstatus;
++
++-  if(mkdir("oidir") < 0){
+++  if (mkdir("oidir") < 0)
+++  {
++     printf("%s: mkdir oidir failed\n", s);
++     exit(1);
++   }
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     int fd = open("oidir", O_RDWR);
++-    if(fd >= 0){
+++    if (fd >= 0)
+++    {
++       printf("%s: open directory for write succeeded\n", s);
++       exit(1);
++     }
++     exit(0);
++   }
++   sleep(1);
++-  if(unlink("oidir") != 0){
+++  if (unlink("oidir") != 0)
+++  {
++     printf("%s: unlink failed\n", s);
++     exit(1);
++   }
++@@ -519,79 +568,92 @@ openiputtest(char *s)
++
++ // simple file system tests
++
++-void
++-opentest(char *s)
+++void opentest(char *s)
++ {
++   int fd;
++
++   fd = open("echo", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open echo failed!\n", s);
++     exit(1);
++   }
++   close(fd);
++   fd = open("doesnotexist", 0);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: open doesnotexist succeeded!\n", s);
++     exit(1);
++   }
++ }
++
++-void
++-writetest(char *s)
+++void writetest(char *s)
++ {
++   int fd;
++   int i;
++-  enum { N=100, SZ=10 };
++-
++-  fd = open("small", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  enum
+++  {
+++    N = 100,
+++    SZ = 10
+++  };
+++
+++  fd = open("small", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: error: creat small failed!\n", s);
++     exit(1);
++   }
++-  for(i = 0; i < N; i++){
++-    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
+++  for (i = 0; i < N; i++)
+++  {
+++    if (write(fd, "aaaaaaaaaa", SZ) != SZ)
+++    {
++       printf("%s: error: write aa %d new file failed\n", s, i);
++       exit(1);
++     }
++-    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
+++    if (write(fd, "bbbbbbbbbb", SZ) != SZ)
+++    {
++       printf("%s: error: write bb %d new file failed\n", s, i);
++       exit(1);
++     }
++   }
++   close(fd);
++   fd = open("small", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: error: open small failed!\n", s);
++     exit(1);
++   }
++-  i = read(fd, buf, N*SZ*2);
++-  if(i != N*SZ*2){
+++  i = read(fd, buf, N * SZ * 2);
+++  if (i != N * SZ * 2)
+++  {
++     printf("%s: read failed\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(unlink("small") < 0){
+++  if (unlink("small") < 0)
+++  {
++     printf("%s: unlink small failed\n", s);
++     exit(1);
++   }
++ }
++
++-void
++-writebig(char *s)
+++void writebig(char *s)
++ {
++   int i, fd, n;
++
++-  fd = open("big", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("big", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: error: creat big failed!\n", s);
++     exit(1);
++   }
++
++-  for(i = 0; i < MAXFILE; i++){
++-    ((int*)buf)[0] = i;
++-    if(write(fd, buf, BSIZE) != BSIZE){
+++  for (i = 0; i < MAXFILE; i++)
+++  {
+++    ((int *)buf)[0] = i;
+++    if (write(fd, buf, BSIZE) != BSIZE)
+++    {
++       printf("%s: error: write big file failed i=%d\n", s, i);
++       exit(1);
++     }
++@@ -600,56 +662,68 @@ writebig(char *s)
++   close(fd);
++
++   fd = open("big", O_RDONLY);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: error: open big failed!\n", s);
++     exit(1);
++   }
++
++   n = 0;
++-  for(;;){
+++  for (;;)
+++  {
++     i = read(fd, buf, BSIZE);
++-    if(i == 0){
++-      if(n != MAXFILE){
+++    if (i == 0)
+++    {
+++      if (n != MAXFILE)
+++      {
++         printf("%s: read only %d blocks from big", s, n);
++         exit(1);
++       }
++       break;
++-    } else if(i != BSIZE){
+++    }
+++    else if (i != BSIZE)
+++    {
++       printf("%s: read failed %d\n", s, i);
++       exit(1);
++     }
++-    if(((int*)buf)[0] != n){
+++    if (((int *)buf)[0] != n)
+++    {
++       printf("%s: read content of block %d is %d\n", s,
++-             n, ((int*)buf)[0]);
+++             n, ((int *)buf)[0]);
++       exit(1);
++     }
++     n++;
++   }
++   close(fd);
++-  if(unlink("big") < 0){
+++  if (unlink("big") < 0)
+++  {
++     printf("%s: unlink big failed\n", s);
++     exit(1);
++   }
++ }
++
++ // many creates, followed by unlink test
++-void
++-createtest(char *s)
+++void createtest(char *s)
++ {
++   int i, fd;
++-  enum { N=52 };
+++  enum
+++  {
+++    N = 52
+++  };
++
++   char name[3];
++   name[0] = 'a';
++   name[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[1] = '0' + i;
++-    fd = open(name, O_CREATE|O_RDWR);
+++    fd = open(name, O_CREATE | O_RDWR);
++     close(fd);
++   }
++   name[0] = 'a';
++   name[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[1] = '0' + i;
++     unlink(name);
++   }
++@@ -657,152 +731,180 @@ createtest(char *s)
++
++ void dirtest(char *s)
++ {
++-  if(mkdir("dir0") < 0){
+++  if (mkdir("dir0") < 0)
+++  {
++     printf("%s: mkdir failed\n", s);
++     exit(1);
++   }
++
++-  if(chdir("dir0") < 0){
+++  if (chdir("dir0") < 0)
+++  {
++     printf("%s: chdir dir0 failed\n", s);
++     exit(1);
++   }
++
++-  if(chdir("..") < 0){
+++  if (chdir("..") < 0)
+++  {
++     printf("%s: chdir .. failed\n", s);
++     exit(1);
++   }
++
++-  if(unlink("dir0") < 0){
+++  if (unlink("dir0") < 0)
+++  {
++     printf("%s: unlink dir0 failed\n", s);
++     exit(1);
++   }
++ }
++
++-void
++-exectest(char *s)
+++void exectest(char *s)
++ {
++   int fd, xstatus, pid;
++-  char *echoargv[] = { "echo", "OK", 0 };
+++  char *echoargv[] = {"echo", "OK", 0};
++   char buf[3];
++
++   unlink("echo-ok");
++   pid = fork();
++-  if(pid < 0) {
++-     printf("%s: fork failed\n", s);
++-     exit(1);
+++  if (pid < 0)
+++  {
+++    printf("%s: fork failed\n", s);
+++    exit(1);
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     close(1);
++-    fd = open("echo-ok", O_CREATE|O_WRONLY);
++-    if(fd < 0) {
+++    fd = open("echo-ok", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("%s: create failed\n", s);
++       exit(1);
++     }
++-    if(fd != 1) {
+++    if (fd != 1)
+++    {
++       printf("%s: wrong fd\n", s);
++       exit(1);
++     }
++-    if(exec("echo", echoargv) < 0){
+++    if (exec("echo", echoargv) < 0)
+++    {
++       printf("%s: exec echo failed\n", s);
++       exit(1);
++     }
++     // won't get to here
++   }
++-  if (wait(&xstatus) != pid) {
+++  if (wait(&xstatus) != pid)
+++  {
++     printf("%s: wait failed!\n", s);
++   }
++-  if(xstatus != 0)
+++  if (xstatus != 0)
++     exit(xstatus);
++
++   fd = open("echo-ok", O_RDONLY);
++-  if(fd < 0) {
+++  if (fd < 0)
+++  {
++     printf("%s: open failed\n", s);
++     exit(1);
++   }
++-  if (read(fd, buf, 2) != 2) {
+++  if (read(fd, buf, 2) != 2)
+++  {
++     printf("%s: read failed\n", s);
++     exit(1);
++   }
++   unlink("echo-ok");
++-  if(buf[0] == 'O' && buf[1] == 'K')
+++  if (buf[0] == 'O' && buf[1] == 'K')
++     exit(0);
++-  else {
+++  else
+++  {
++     printf("%s: wrong output\n", s);
++     exit(1);
++   }
++-
++ }
++
++ // simple fork and pipe read/write
++
++-void
++-pipe1(char *s)
+++void pipe1(char *s)
++ {
++   int fds[2], pid, xstatus;
++   int seq, i, n, cc, total;
++-  enum { N=5, SZ=1033 };
++-
++-  if(pipe(fds) != 0){
+++  enum
+++  {
+++    N = 5,
+++    SZ = 1033
+++  };
+++
+++  if (pipe(fds) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++   }
++   pid = fork();
++   seq = 0;
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     close(fds[0]);
++-    for(n = 0; n < N; n++){
++-      for(i = 0; i < SZ; i++)
+++    for (n = 0; n < N; n++)
+++    {
+++      for (i = 0; i < SZ; i++)
++         buf[i] = seq++;
++-      if(write(fds[1], buf, SZ) != SZ){
+++      if (write(fds[1], buf, SZ) != SZ)
+++      {
++         printf("%s: pipe1 oops 1\n", s);
++         exit(1);
++       }
++     }
++     exit(0);
++-  } else if(pid > 0){
+++  }
+++  else if (pid > 0)
+++  {
++     close(fds[1]);
++     total = 0;
++     cc = 1;
++-    while((n = read(fds[0], buf, cc)) > 0){
++-      for(i = 0; i < n; i++){
++-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+++    while ((n = read(fds[0], buf, cc)) > 0)
+++    {
+++      for (i = 0; i < n; i++)
+++      {
+++        if ((buf[i] & 0xff) != (seq++ & 0xff))
+++        {
++           printf("%s: pipe1 oops 2\n", s);
++           return;
++         }
++       }
++       total += n;
++       cc = cc * 2;
++-      if(cc > sizeof(buf))
+++      if (cc > sizeof(buf))
++         cc = sizeof(buf);
++     }
++-    if(total != N * SZ){
+++    if (total != N * SZ)
+++    {
++       printf("%s: pipe1 oops 3 total %d\n", s, total);
++       exit(1);
++     }
++     close(fds[0]);
++     wait(&xstatus);
++     exit(xstatus);
++-  } else {
+++  }
+++  else
+++  {
++     printf("%s: fork() failed\n", s);
++     exit(1);
++   }
++ }
++
++-
++ // test if child is killed (status = -1)
++-void
++-killstatus(char *s)
+++void killstatus(char *s)
++ {
++   int xst;
++-
++-  for(int i = 0; i < 100; i++){
+++
+++  for (int i = 0; i < 100; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid1 == 0){
++-      while(1) {
+++    if (pid1 == 0)
+++    {
+++      while (1)
+++      {
++         getpid();
++       }
++       exit(0);
++@@ -810,56 +912,61 @@ killstatus(char *s)
++     sleep(1);
++     kill(pid1);
++     wait(&xst);
++-    if(xst != -1) {
++-       printf("%s: status should be -1\n", s);
++-       exit(1);
+++    if (xst != -1)
+++    {
+++      printf("%s: status should be -1\n", s);
+++      exit(1);
++     }
++   }
++   exit(0);
++ }
++
++ // meant to be run w/ at most two CPUs
++-void
++-preempt(char *s)
+++void preempt(char *s)
++ {
++   int pid1, pid2, pid3;
++   int pfds[2];
++
++   pid1 = fork();
++-  if(pid1 < 0) {
+++  if (pid1 < 0)
+++  {
++     printf("%s: fork failed", s);
++     exit(1);
++   }
++-  if(pid1 == 0)
++-    for(;;)
+++  if (pid1 == 0)
+++    for (;;)
++       ;
++
++   pid2 = fork();
++-  if(pid2 < 0) {
+++  if (pid2 < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid2 == 0)
++-    for(;;)
+++  if (pid2 == 0)
+++    for (;;)
++       ;
++
++   pipe(pfds);
++   pid3 = fork();
++-  if(pid3 < 0) {
++-     printf("%s: fork failed\n", s);
++-     exit(1);
+++  if (pid3 < 0)
+++  {
+++    printf("%s: fork failed\n", s);
+++    exit(1);
++   }
++-  if(pid3 == 0){
+++  if (pid3 == 0)
+++  {
++     close(pfds[0]);
++-    if(write(pfds[1], "x", 1) != 1)
+++    if (write(pfds[1], "x", 1) != 1)
++       printf("%s: preempt write error", s);
++     close(pfds[1]);
++-    for(;;)
+++    for (;;)
++       ;
++   }
++
++   close(pfds[1]);
++-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+++  if (read(pfds[0], buf, sizeof(buf)) != 1)
+++  {
++     printf("%s: preempt read error", s);
++     return;
++   }
++@@ -875,28 +982,34 @@ preempt(char *s)
++ }
++
++ // try to find any races between exit and wait
++-void
++-exitwait(char *s)
+++void exitwait(char *s)
++ {
++   int i, pid;
++
++-  for(i = 0; i < 100; i++){
+++  for (i = 0; i < 100; i++)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid){
+++    if (pid)
+++    {
++       int xstate;
++-      if(wait(&xstate) != pid){
+++      if (wait(&xstate) != pid)
+++      {
++         printf("%s: wait wrong pid\n", s);
++         exit(1);
++       }
++-      if(i != xstate) {
+++      if (i != xstate)
+++      {
++         printf("%s: wait wrong exit status\n", s);
++         exit(1);
++       }
++-    } else {
+++    }
+++    else
+++    {
++       exit(i);
++     }
++   }
++@@ -905,24 +1018,30 @@ exitwait(char *s)
++ // try to find races in the reparenting
++ // code that handles a parent exiting
++ // when it still has live children.
++-void
++-reparent(char *s)
+++void reparent(char *s)
++ {
++   int master_pid = getpid();
++-  for(int i = 0; i < 200; i++){
+++  for (int i = 0; i < 200; i++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid){
++-      if(wait(0) != pid){
+++    if (pid)
+++    {
+++      if (wait(0) != pid)
+++      {
++         printf("%s: wait wrong pid\n", s);
++         exit(1);
++       }
++-    } else {
+++    }
+++    else
+++    {
++       int pid2 = fork();
++-      if(pid2 < 0){
+++      if (pid2 < 0)
+++      {
++         kill(master_pid);
++         exit(1);
++       }
++@@ -933,26 +1052,34 @@ reparent(char *s)
++ }
++
++ // what if two children exit() at the same time?
++-void
++-twochildren(char *s)
+++void twochildren(char *s)
++ {
++-  for(int i = 0; i < 1000; i++){
+++  for (int i = 0; i < 1000; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid1 == 0){
+++    if (pid1 == 0)
+++    {
++       exit(0);
++-    } else {
+++    }
+++    else
+++    {
++       int pid2 = fork();
++-      if(pid2 < 0){
+++      if (pid2 < 0)
+++      {
++         printf("%s: fork failed\n", s);
++         exit(1);
++       }
++-      if(pid2 == 0){
+++      if (pid2 == 0)
+++      {
++         exit(0);
++-      } else {
+++      }
+++      else
+++      {
++         wait(0);
++         wait(0);
++       }
++@@ -961,24 +1088,32 @@ twochildren(char *s)
++ }
++
++ // concurrent forks to try to expose locking bugs.
++-void
++-forkfork(char *s)
+++void forkfork(char *s)
++ {
++-  enum { N=2 };
++-
++-  for(int i = 0; i < N; i++){
+++  enum
+++  {
+++    N = 2
+++  };
+++
+++  for (int i = 0; i < N; i++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed", s);
++       exit(1);
++     }
++-    if(pid == 0){
++-      for(int j = 0; j < 200; j++){
+++    if (pid == 0)
+++    {
+++      for (int j = 0; j < 200; j++)
+++      {
++         int pid1 = fork();
++-        if(pid1 < 0){
+++        if (pid1 < 0)
+++        {
++           exit(1);
++         }
++-        if(pid1 == 0){
+++        if (pid1 == 0)
+++        {
++           exit(0);
++         }
++         wait(0);
++@@ -988,33 +1123,39 @@ forkfork(char *s)
++   }
++
++   int xstatus;
++-  for(int i = 0; i < N; i++){
+++  for (int i = 0; i < N; i++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0) {
+++    if (xstatus != 0)
+++    {
++       printf("%s: fork in child failed", s);
++       exit(1);
++     }
++   }
++ }
++
++-void
++-forkforkfork(char *s)
+++void forkforkfork(char *s)
++ {
++   unlink("stopforking");
++
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed", s);
++     exit(1);
++   }
++-  if(pid == 0){
++-    while(1){
+++  if (pid == 0)
+++  {
+++    while (1)
+++    {
++       int fd = open("stopforking", 0);
++-      if(fd >= 0){
+++      if (fd >= 0)
+++      {
++         exit(0);
++       }
++-      if(fork() < 0){
++-        close(open("stopforking", O_CREATE|O_RDWR));
+++      if (fork() < 0)
+++      {
+++        close(open("stopforking", O_CREATE | O_RDWR));
++       }
++     }
++
++@@ -1022,7 +1163,7 @@ forkforkfork(char *s)
++   }
++
++   sleep(20); // two seconds
++-  close(open("stopforking", O_CREATE|O_RDWR));
+++  close(open("stopforking", O_CREATE | O_RDWR));
++   wait(0);
++   sleep(10); // one second
++ }
++@@ -1032,16 +1173,18 @@ forkforkfork(char *s)
++ // deadlocks against init's wait()? also used to trigger a "panic:
++ // release" due to exit() releasing a different p->parent->lock than
++ // it acquired.
++-void
++-reparent2(char *s)
+++void reparent2(char *s)
++ {
++-  for(int i = 0; i < 800; i++){
+++  for (int i = 0; i < 800; i++)
+++  {
++     int pid1 = fork();
++-    if(pid1 < 0){
+++    if (pid1 < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++     }
++-    if(pid1 == 0){
+++    if (pid1 == 0)
+++    {
++       fork();
++       fork();
++       exit(0);
++@@ -1053,34 +1196,40 @@ reparent2(char *s)
++ }
++
++ // allocate all mem, free it, and allocate again
++-void
++-mem(char *s)
+++void mem(char *s)
++ {
++   void *m1, *m2;
++   int pid;
++
++-  if((pid = fork()) == 0){
+++  if ((pid = fork()) == 0)
+++  {
++     m1 = 0;
++-    while((m2 = malloc(10001)) != 0){
++-      *(char**)m2 = m1;
+++    while ((m2 = malloc(10001)) != 0)
+++    {
+++      *(char **)m2 = m1;
++       m1 = m2;
++     }
++-    while(m1){
++-      m2 = *(char**)m1;
+++    while (m1)
+++    {
+++      m2 = *(char **)m1;
++       free(m1);
++       m1 = m2;
++     }
++-    m1 = malloc(1024*20);
++-    if(m1 == 0){
+++    m1 = malloc(1024 * 20);
+++    if (m1 == 0)
+++    {
++       printf("%s: couldn't allocate mem?!!\n", s);
++       exit(1);
++     }
++     free(m1);
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus == -1){
+++    if (xstatus == -1)
+++    {
++       // probably page fault, so might be lazy lab,
++       // so OK.
++       exit(0);
++@@ -1093,56 +1242,71 @@ mem(char *s)
++
++ // two processes write to the same file descriptor
++ // is the offset shared? does inode locking work?
++-void
++-sharedfd(char *s)
+++void sharedfd(char *s)
++ {
++   int fd, pid, i, n, nc, np;
++-  enum { N = 1000, SZ=10};
+++  enum
+++  {
+++    N = 1000,
+++    SZ = 10
+++  };
++   char buf[SZ];
++
++   unlink("sharedfd");
++-  fd = open("sharedfd", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("sharedfd", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open sharedfd for writing", s);
++     exit(1);
++   }
++   pid = fork();
++-  memset(buf, pid==0?'c':'p', sizeof(buf));
++-  for(i = 0; i < N; i++){
++-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+++  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
+++  for (i = 0; i < N; i++)
+++  {
+++    if (write(fd, buf, sizeof(buf)) != sizeof(buf))
+++    {
++       printf("%s: write sharedfd failed\n", s);
++       exit(1);
++     }
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(xstatus);
++   }
++-
+++
++   close(fd);
++   fd = open("sharedfd", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open sharedfd for reading\n", s);
++     exit(1);
++   }
++   nc = np = 0;
++-  while((n = read(fd, buf, sizeof(buf))) > 0){
++-    for(i = 0; i < sizeof(buf); i++){
++-      if(buf[i] == 'c')
+++  while ((n = read(fd, buf, sizeof(buf))) > 0)
+++  {
+++    for (i = 0; i < sizeof(buf); i++)
+++    {
+++      if (buf[i] == 'c')
++         nc++;
++-      if(buf[i] == 'p')
+++      if (buf[i] == 'p')
++         np++;
++     }
++   }
++   close(fd);
++   unlink("sharedfd");
++-  if(nc == N*SZ && np == N*SZ){
+++  if (nc == N * SZ && np == N * SZ)
+++  {
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     printf("%s: nc/np test fails\n", s);
++     exit(1);
++   }
++@@ -1150,34 +1314,44 @@ sharedfd(char *s)
++
++ // four processes write different files at the same
++ // time, to test block allocation.
++-void
++-fourfiles(char *s)
+++void fourfiles(char *s)
++ {
++   int fd, pid, i, j, n, total, pi;
++-  char *names[] = { "f0", "f1", "f2", "f3" };
+++  char *names[] = {"f0", "f1", "f2", "f3"};
++   char *fname;
++-  enum { N=12, NCHILD=4, SZ=500 };
++-
++-  for(pi = 0; pi < NCHILD; pi++){
+++  enum
+++  {
+++    N = 12,
+++    NCHILD = 4,
+++    SZ = 500
+++  };
+++
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     fname = names[pi];
++     unlink(fname);
++
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       fd = open(fname, O_CREATE | O_RDWR);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("%s: create failed\n", s);
++         exit(1);
++       }
++
++-      memset(buf, '0'+pi, SZ);
++-      for(i = 0; i < N; i++){
++-        if((n = write(fd, buf, SZ)) != SZ){
+++      memset(buf, '0' + pi, SZ);
+++      for (i = 0; i < N; i++)
+++      {
+++        if ((n = write(fd, buf, SZ)) != SZ)
+++        {
++           printf("write failed %d\n", n);
++           exit(1);
++         }
++@@ -1187,19 +1361,24 @@ fourfiles(char *s)
++   }
++
++   int xstatus;
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(xstatus);
++   }
++
++-  for(i = 0; i < NCHILD; i++){
+++  for (i = 0; i < NCHILD; i++)
+++  {
++     fname = names[i];
++     fd = open(fname, 0);
++     total = 0;
++-    while((n = read(fd, buf, sizeof(buf))) > 0){
++-      for(j = 0; j < n; j++){
++-        if(buf[j] != '0'+i){
+++    while ((n = read(fd, buf, sizeof(buf))) > 0)
+++    {
+++      for (j = 0; j < n; j++)
+++      {
+++        if (buf[j] != '0' + i)
+++        {
++           printf("%s: wrong char\n", s);
++           exit(1);
++         }
++@@ -1207,7 +1386,8 @@ fourfiles(char *s)
++       total += n;
++     }
++     close(fd);
++-    if(total != N*SZ){
+++    if (total != N * SZ)
+++    {
++       printf("wrong length %d\n", total);
++       exit(1);
++     }
++@@ -1216,34 +1396,44 @@ fourfiles(char *s)
++ }
++
++ // four processes create and delete different files in same directory
++-void
++-createdelete(char *s)
+++void createdelete(char *s)
++ {
++-  enum { N = 20, NCHILD=4 };
+++  enum
+++  {
+++    N = 20,
+++    NCHILD = 4
+++  };
++   int pid, i, fd, pi;
++   char name[32];
++
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       name[0] = 'p' + pi;
++       name[2] = '\0';
++-      for(i = 0; i < N; i++){
+++      for (i = 0; i < N; i++)
+++      {
++         name[1] = '0' + i;
++         fd = open(name, O_CREATE | O_RDWR);
++-        if(fd < 0){
+++        if (fd < 0)
+++        {
++           printf("%s: create failed\n", s);
++           exit(1);
++         }
++         close(fd);
++-        if(i > 0 && (i % 2 ) == 0){
+++        if (i > 0 && (i % 2) == 0)
+++        {
++           name[1] = '0' + (i / 2);
++-          if(unlink(name) < 0){
+++          if (unlink(name) < 0)
+++          {
++             printf("%s: unlink failed\n", s);
++             exit(1);
++           }
++@@ -1254,32 +1444,40 @@ createdelete(char *s)
++   }
++
++   int xstatus;
++-  for(pi = 0; pi < NCHILD; pi++){
+++  for (pi = 0; pi < NCHILD; pi++)
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       exit(1);
++   }
++
++   name[0] = name[1] = name[2] = 0;
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < NCHILD; pi++){
+++  for (i = 0; i < N; i++)
+++  {
+++    for (pi = 0; pi < NCHILD; pi++)
+++    {
++       name[0] = 'p' + pi;
++       name[1] = '0' + i;
++       fd = open(name, 0);
++-      if((i == 0 || i >= N/2) && fd < 0){
+++      if ((i == 0 || i >= N / 2) && fd < 0)
+++      {
++         printf("%s: oops createdelete %s didn't exist\n", s, name);
++         exit(1);
++-      } else if((i >= 1 && i < N/2) && fd >= 0){
+++      }
+++      else if ((i >= 1 && i < N / 2) && fd >= 0)
+++      {
++         printf("%s: oops createdelete %s did exist\n", s, name);
++         exit(1);
++       }
++-      if(fd >= 0)
+++      if (fd >= 0)
++         close(fd);
++     }
++   }
++
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < NCHILD; pi++){
+++  for (i = 0; i < N; i++)
+++  {
+++    for (pi = 0; pi < NCHILD; pi++)
+++    {
++       name[0] = 'p' + pi;
++       name[1] = '0' + i;
++       unlink(name);
++@@ -1288,14 +1486,17 @@ createdelete(char *s)
++ }
++
++ // can I unlink a file and still read it?
++-void
++-unlinkread(char *s)
+++void unlinkread(char *s)
++ {
++-  enum { SZ = 5 };
+++  enum
+++  {
+++    SZ = 5
+++  };
++   int fd, fd1;
++
++   fd = open("unlinkread", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create unlinkread failed\n", s);
++     exit(1);
++   }
++@@ -1303,11 +1504,13 @@ unlinkread(char *s)
++   close(fd);
++
++   fd = open("unlinkread", O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open unlinkread failed\n", s);
++     exit(1);
++   }
++-  if(unlink("unlinkread") != 0){
+++  if (unlink("unlinkread") != 0)
+++  {
++     printf("%s: unlink unlinkread failed\n", s);
++     exit(1);
++   }
++@@ -1316,15 +1519,18 @@ unlinkread(char *s)
++   write(fd1, "yyy", 3);
++   close(fd1);
++
++-  if(read(fd, buf, sizeof(buf)) != SZ){
+++  if (read(fd, buf, sizeof(buf)) != SZ)
+++  {
++     printf("%s: unlinkread read failed", s);
++     exit(1);
++   }
++-  if(buf[0] != 'h'){
+++  if (buf[0] != 'h')
+++  {
++     printf("%s: unlinkread wrong data\n", s);
++     exit(1);
++   }
++-  if(write(fd, buf, 10) != 10){
+++  if (write(fd, buf, 10) != 10)
+++  {
++     printf("%s: unlinkread write failed\n", s);
++     exit(1);
++   }
++@@ -1332,102 +1538,126 @@ unlinkread(char *s)
++   unlink("unlinkread");
++ }
++
++-void
++-linktest(char *s)
+++void linktest(char *s)
++ {
++-  enum { SZ = 5 };
+++  enum
+++  {
+++    SZ = 5
+++  };
++   int fd;
++
++   unlink("lf1");
++   unlink("lf2");
++
++-  fd = open("lf1", O_CREATE|O_RDWR);
++-  if(fd < 0){
+++  fd = open("lf1", O_CREATE | O_RDWR);
+++  if (fd < 0)
+++  {
++     printf("%s: create lf1 failed\n", s);
++     exit(1);
++   }
++-  if(write(fd, "hello", SZ) != SZ){
+++  if (write(fd, "hello", SZ) != SZ)
+++  {
++     printf("%s: write lf1 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(link("lf1", "lf2") < 0){
+++  if (link("lf1", "lf2") < 0)
+++  {
++     printf("%s: link lf1 lf2 failed\n", s);
++     exit(1);
++   }
++   unlink("lf1");
++
++-  if(open("lf1", 0) >= 0){
+++  if (open("lf1", 0) >= 0)
+++  {
++     printf("%s: unlinked lf1 but it is still there!\n", s);
++     exit(1);
++   }
++
++   fd = open("lf2", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open lf2 failed\n", s);
++     exit(1);
++   }
++-  if(read(fd, buf, sizeof(buf)) != SZ){
+++  if (read(fd, buf, sizeof(buf)) != SZ)
+++  {
++     printf("%s: read lf2 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(link("lf2", "lf2") >= 0){
+++  if (link("lf2", "lf2") >= 0)
+++  {
++     printf("%s: link lf2 lf2 succeeded! oops\n", s);
++     exit(1);
++   }
++
++   unlink("lf2");
++-  if(link("lf2", "lf1") >= 0){
+++  if (link("lf2", "lf1") >= 0)
+++  {
++     printf("%s: link non-existent succeeded! oops\n", s);
++     exit(1);
++   }
++
++-  if(link(".", "lf1") >= 0){
+++  if (link(".", "lf1") >= 0)
+++  {
++     printf("%s: link . lf1 succeeded! oops\n", s);
++     exit(1);
++   }
++ }
++
++ // test concurrent create/link/unlink of the same file
++-void
++-concreate(char *s)
+++void concreate(char *s)
++ {
++-  enum { N = 40 };
+++  enum
+++  {
+++    N = 40
+++  };
++   char file[3];
++   int i, pid, n, fd;
++   char fa[N];
++-  struct {
+++  struct
+++  {
++     ushort inum;
++     char name[DIRSIZ];
++   } de;
++
++   file[0] = 'C';
++   file[2] = '\0';
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     file[1] = '0' + i;
++     unlink(file);
++     pid = fork();
++-    if(pid && (i % 3) == 1){
+++    if (pid && (i % 3) == 1)
+++    {
++       link("C0", file);
++-    } else if(pid == 0 && (i % 5) == 1){
+++    }
+++    else if (pid == 0 && (i % 5) == 1)
+++    {
++       link("C0", file);
++-    } else {
+++    }
+++    else
+++    {
++       fd = open(file, O_CREATE | O_RDWR);
++-      if(fd < 0){
+++      if (fd < 0)
+++      {
++         printf("concreate create %s failed\n", file);
++         exit(1);
++       }
++       close(fd);
++     }
++-    if(pid == 0) {
+++    if (pid == 0)
+++    {
++       exit(0);
++-    } else {
+++    }
+++    else
+++    {
++       int xstatus;
++       wait(&xstatus);
++-      if(xstatus != 0)
+++      if (xstatus != 0)
++         exit(1);
++     }
++   }
++@@ -1435,16 +1665,20 @@ concreate(char *s)
++   memset(fa, 0, sizeof(fa));
++   fd = open(".", 0);
++   n = 0;
++-  while(read(fd, &de, sizeof(de)) > 0){
++-    if(de.inum == 0)
+++  while (read(fd, &de, sizeof(de)) > 0)
+++  {
+++    if (de.inum == 0)
++       continue;
++-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+++    if (de.name[0] == 'C' && de.name[2] == '\0')
+++    {
++       i = de.name[1] - '0';
++-      if(i < 0 || i >= sizeof(fa)){
+++      if (i < 0 || i >= sizeof(fa))
+++      {
++         printf("%s: concreate weird file %s\n", s, de.name);
++         exit(1);
++       }
++-      if(fa[i]){
+++      if (fa[i])
+++      {
++         printf("%s: concreate duplicate file %s\n", s, de.name);
++         exit(1);
++       }
++@@ -1454,27 +1688,33 @@ concreate(char *s)
++   }
++   close(fd);
++
++-  if(n != N){
+++  if (n != N)
+++  {
++     printf("%s: concreate not enough files in directory listing\n", s);
++     exit(1);
++   }
++
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     file[1] = '0' + i;
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(((i % 3) == 0 && pid == 0) ||
++-       ((i % 3) == 1 && pid != 0)){
+++    if (((i % 3) == 0 && pid == 0) ||
+++        ((i % 3) == 1 && pid != 0))
+++    {
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++       close(open(file, 0));
++-    } else {
+++    }
+++    else
+++    {
++       unlink(file);
++       unlink(file);
++       unlink(file);
++@@ -1482,7 +1722,7 @@ concreate(char *s)
++       unlink(file);
++       unlink(file);
++     }
++-    if(pid == 0)
+++    if (pid == 0)
++       exit(0);
++     else
++       wait(0);
++@@ -1491,68 +1731,77 @@ concreate(char *s)
++
++ // another concurrent link/unlink/create test,
++ // to look for deadlocks.
++-void
++-linkunlink(char *s)
+++void linkunlink(char *s)
++ {
++   int pid, i;
++
++   unlink("x");
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++
++   unsigned int x = (pid ? 1 : 97);
++-  for(i = 0; i < 100; i++){
+++  for (i = 0; i < 100; i++)
+++  {
++     x = x * 1103515245 + 12345;
++-    if((x % 3) == 0){
+++    if ((x % 3) == 0)
+++    {
++       close(open("x", O_RDWR | O_CREATE));
++-    } else if((x % 3) == 1){
+++    }
+++    else if ((x % 3) == 1)
+++    {
++       link("cat", "x");
++-    } else {
+++    }
+++    else
+++    {
++       unlink("x");
++     }
++   }
++
++-  if(pid)
+++  if (pid)
++     wait(0);
++   else
++     exit(0);
++ }
++
++-
++-void
++-subdir(char *s)
+++void subdir(char *s)
++ {
++   int fd, cc;
++
++   unlink("ff");
++-  if(mkdir("dd") != 0){
+++  if (mkdir("dd") != 0)
+++  {
++     printf("%s: mkdir dd failed\n", s);
++     exit(1);
++   }
++
++   fd = open("dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dd/ff failed\n", s);
++     exit(1);
++   }
++   write(fd, "ff", 2);
++   close(fd);
++
++-  if(unlink("dd") >= 0){
+++  if (unlink("dd") >= 0)
+++  {
++     printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
++     exit(1);
++   }
++
++-  if(mkdir("/dd/dd") != 0){
+++  if (mkdir("/dd/dd") != 0)
+++  {
++     printf("%s: subdir mkdir dd/dd failed\n", s);
++     exit(1);
++   }
++
++   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dd/dd/ff failed\n", s);
++     exit(1);
++   }
++@@ -1560,164 +1809,199 @@ subdir(char *s)
++   close(fd);
++
++   fd = open("dd/dd/../ff", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open dd/dd/../ff failed\n", s);
++     exit(1);
++   }
++   cc = read(fd, buf, sizeof(buf));
++-  if(cc != 2 || buf[0] != 'f'){
+++  if (cc != 2 || buf[0] != 'f')
+++  {
++     printf("%s: dd/dd/../ff wrong content\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+++  if (link("dd/dd/ff", "dd/dd/ffff") != 0)
+++  {
++     printf("%s: link dd/dd/ff dd/dd/ffff failed\n", s);
++     exit(1);
++   }
++
++-  if(unlink("dd/dd/ff") != 0){
+++  if (unlink("dd/dd/ff") != 0)
+++  {
++     printf("%s: unlink dd/dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+++  if (open("dd/dd/ff", O_RDONLY) >= 0)
+++  {
++     printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
++     exit(1);
++   }
++
++-  if(chdir("dd") != 0){
+++  if (chdir("dd") != 0)
+++  {
++     printf("%s: chdir dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/../../dd") != 0){
+++  if (chdir("dd/../../dd") != 0)
+++  {
++     printf("%s: chdir dd/../../dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/../../../dd") != 0){
+++  if (chdir("dd/../../../dd") != 0)
+++  {
++     printf("%s: chdir dd/../../../dd failed\n", s);
++     exit(1);
++   }
++-  if(chdir("./..") != 0){
+++  if (chdir("./..") != 0)
+++  {
++     printf("%s: chdir ./.. failed\n", s);
++     exit(1);
++   }
++
++   fd = open("dd/dd/ffff", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open dd/dd/ffff failed\n", s);
++     exit(1);
++   }
++-  if(read(fd, buf, sizeof(buf)) != 2){
+++  if (read(fd, buf, sizeof(buf)) != 2)
+++  {
++     printf("%s: read dd/dd/ffff wrong len\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+++  if (open("dd/dd/ff", O_RDONLY) >= 0)
+++  {
++     printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
++     exit(1);
++   }
++
++-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+++  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0)
+++  {
++     printf("%s: create dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+++  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0)
+++  {
++     printf("%s: create dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_CREATE) >= 0){
+++  if (open("dd", O_CREATE) >= 0)
+++  {
++     printf("%s: create dd succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_RDWR) >= 0){
+++  if (open("dd", O_RDWR) >= 0)
+++  {
++     printf("%s: open dd rdwr succeeded!\n", s);
++     exit(1);
++   }
++-  if(open("dd", O_WRONLY) >= 0){
+++  if (open("dd", O_WRONLY) >= 0)
+++  {
++     printf("%s: open dd wronly succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+++  if (link("dd/ff/ff", "dd/dd/xx") == 0)
+++  {
++     printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+++  if (link("dd/xx/ff", "dd/dd/xx") == 0)
+++  {
++     printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("dd/ff", "dd/dd/ffff") == 0){
+++  if (link("dd/ff", "dd/dd/ffff") == 0)
+++  {
++     printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/ff/ff") == 0){
+++  if (mkdir("dd/ff/ff") == 0)
+++  {
++     printf("%s: mkdir dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/xx/ff") == 0){
+++  if (mkdir("dd/xx/ff") == 0)
+++  {
++     printf("%s: mkdir dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dd/dd/ffff") == 0){
+++  if (mkdir("dd/dd/ffff") == 0)
+++  {
++     printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/xx/ff") == 0){
+++  if (unlink("dd/xx/ff") == 0)
+++  {
++     printf("%s: unlink dd/xx/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/ff/ff") == 0){
+++  if (unlink("dd/ff/ff") == 0)
+++  {
++     printf("%s: unlink dd/ff/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/ff") == 0){
+++  if (chdir("dd/ff") == 0)
+++  {
++     printf("%s: chdir dd/ff succeeded!\n", s);
++     exit(1);
++   }
++-  if(chdir("dd/xx") == 0){
+++  if (chdir("dd/xx") == 0)
+++  {
++     printf("%s: chdir dd/xx succeeded!\n", s);
++     exit(1);
++   }
++
++-  if(unlink("dd/dd/ffff") != 0){
+++  if (unlink("dd/dd/ffff") != 0)
+++  {
++     printf("%s: unlink dd/dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/ff") != 0){
+++  if (unlink("dd/ff") != 0)
+++  {
++     printf("%s: unlink dd/ff failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd") == 0){
+++  if (unlink("dd") == 0)
+++  {
++     printf("%s: unlink non-empty dd succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dd/dd") < 0){
+++  if (unlink("dd/dd") < 0)
+++  {
++     printf("%s: unlink dd/dd failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dd") < 0){
+++  if (unlink("dd") < 0)
+++  {
++     printf("%s: unlink dd failed\n", s);
++     exit(1);
++   }
++ }
++
++ // test writes that are larger than the log.
++-void
++-bigwrite(char *s)
+++void bigwrite(char *s)
++ {
++   int fd, sz;
++
++   unlink("bigwrite");
++-  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+++  for (sz = 499; sz < (MAXOPBLOCKS + 2) * BSIZE; sz += 471)
+++  {
++     fd = open("bigwrite", O_CREATE | O_RDWR);
++-    if(fd < 0){
+++    if (fd < 0)
+++    {
++       printf("%s: cannot create bigwrite\n", s);
++       exit(1);
++     }
++     int i;
++-    for(i = 0; i < 2; i++){
+++    for (i = 0; i < 2; i++)
+++    {
++       int cc = write(fd, buf, sz);
++-      if(cc != sz){
+++      if (cc != sz)
+++      {
++         printf("%s: write(%d) ret %d\n", s, sz, cc);
++         exit(1);
++       }
++@@ -1727,22 +2011,27 @@ bigwrite(char *s)
++   }
++ }
++
++-
++-void
++-bigfile(char *s)
+++void bigfile(char *s)
++ {
++-  enum { N = 20, SZ=600 };
+++  enum
+++  {
+++    N = 20,
+++    SZ = 600
+++  };
++   int fd, i, total, cc;
++
++   unlink("bigfile.dat");
++   fd = open("bigfile.dat", O_CREATE | O_RDWR);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot create bigfile", s);
++     exit(1);
++   }
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     memset(buf, i, SZ);
++-    if(write(fd, buf, SZ) != SZ){
+++    if (write(fd, buf, SZ) != SZ)
+++    {
++       printf("%s: write bigfile failed\n", s);
++       exit(1);
++     }
++@@ -1750,70 +2039,81 @@ bigfile(char *s)
++   close(fd);
++
++   fd = open("bigfile.dat", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: cannot open bigfile\n", s);
++     exit(1);
++   }
++   total = 0;
++-  for(i = 0; ; i++){
++-    cc = read(fd, buf, SZ/2);
++-    if(cc < 0){
+++  for (i = 0;; i++)
+++  {
+++    cc = read(fd, buf, SZ / 2);
+++    if (cc < 0)
+++    {
++       printf("%s: read bigfile failed\n", s);
++       exit(1);
++     }
++-    if(cc == 0)
+++    if (cc == 0)
++       break;
++-    if(cc != SZ/2){
+++    if (cc != SZ / 2)
+++    {
++       printf("%s: short read bigfile\n", s);
++       exit(1);
++     }
++-    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
+++    if (buf[0] != i / 2 || buf[SZ / 2 - 1] != i / 2)
+++    {
++       printf("%s: read bigfile wrong data\n", s);
++       exit(1);
++     }
++     total += cc;
++   }
++   close(fd);
++-  if(total != N*SZ){
+++  if (total != N * SZ)
+++  {
++     printf("%s: read bigfile wrong total\n", s);
++     exit(1);
++   }
++   unlink("bigfile.dat");
++ }
++
++-void
++-fourteen(char *s)
+++void fourteen(char *s)
++ {
++   int fd;
++
++   // DIRSIZ is 14.
++
++-  if(mkdir("12345678901234") != 0){
+++  if (mkdir("12345678901234") != 0)
+++  {
++     printf("%s: mkdir 12345678901234 failed\n", s);
++     exit(1);
++   }
++-  if(mkdir("12345678901234/123456789012345") != 0){
+++  if (mkdir("12345678901234/123456789012345") != 0)
+++  {
++     printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
++     exit(1);
++   }
++   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++   fd = open("12345678901234/12345678901234/12345678901234", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  if(mkdir("12345678901234/12345678901234") == 0){
+++  if (mkdir("12345678901234/12345678901234") == 0)
+++  {
++     printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("123456789012345/12345678901234") == 0){
+++  if (mkdir("123456789012345/12345678901234") == 0)
+++  {
++     printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
++     exit(1);
++   }
++@@ -1827,92 +2127,108 @@ fourteen(char *s)
++   unlink("12345678901234");
++ }
++
++-void
++-rmdot(char *s)
+++void rmdot(char *s)
++ {
++-  if(mkdir("dots") != 0){
+++  if (mkdir("dots") != 0)
+++  {
++     printf("%s: mkdir dots failed\n", s);
++     exit(1);
++   }
++-  if(chdir("dots") != 0){
+++  if (chdir("dots") != 0)
+++  {
++     printf("%s: chdir dots failed\n", s);
++     exit(1);
++   }
++-  if(unlink(".") == 0){
+++  if (unlink(".") == 0)
+++  {
++     printf("%s: rm . worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("..") == 0){
+++  if (unlink("..") == 0)
+++  {
++     printf("%s: rm .. worked!\n", s);
++     exit(1);
++   }
++-  if(chdir("/") != 0){
+++  if (chdir("/") != 0)
+++  {
++     printf("%s: chdir / failed\n", s);
++     exit(1);
++   }
++-  if(unlink("dots/.") == 0){
+++  if (unlink("dots/.") == 0)
+++  {
++     printf("%s: unlink dots/. worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("dots/..") == 0){
+++  if (unlink("dots/..") == 0)
+++  {
++     printf("%s: unlink dots/.. worked!\n", s);
++     exit(1);
++   }
++-  if(unlink("dots") != 0){
+++  if (unlink("dots") != 0)
+++  {
++     printf("%s: unlink dots failed!\n", s);
++     exit(1);
++   }
++ }
++
++-void
++-dirfile(char *s)
+++void dirfile(char *s)
++ {
++   int fd;
++
++   fd = open("dirfile", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: create dirfile failed\n", s);
++     exit(1);
++   }
++   close(fd);
++-  if(chdir("dirfile") == 0){
+++  if (chdir("dirfile") == 0)
+++  {
++     printf("%s: chdir dirfile succeeded!\n", s);
++     exit(1);
++   }
++   fd = open("dirfile/xx", 0);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: create dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++   fd = open("dirfile/xx", O_CREATE);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: create dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(mkdir("dirfile/xx") == 0){
+++  if (mkdir("dirfile/xx") == 0)
+++  {
++     printf("%s: mkdir dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dirfile/xx") == 0){
+++  if (unlink("dirfile/xx") == 0)
+++  {
++     printf("%s: unlink dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(link("README", "dirfile/xx") == 0){
+++  if (link("README", "dirfile/xx") == 0)
+++  {
++     printf("%s: link to dirfile/xx succeeded!\n", s);
++     exit(1);
++   }
++-  if(unlink("dirfile") != 0){
+++  if (unlink("dirfile") != 0)
+++  {
++     printf("%s: unlink dirfile failed!\n", s);
++     exit(1);
++   }
++
++   fd = open(".", O_RDWR);
++-  if(fd >= 0){
+++  if (fd >= 0)
+++  {
++     printf("%s: open . for writing succeeded!\n", s);
++     exit(1);
++   }
++   fd = open(".", 0);
++-  if(write(fd, "x", 1) > 0){
+++  if (write(fd, "x", 1) > 0)
+++  {
++     printf("%s: write . succeeded!\n", s);
++     exit(1);
++   }
++@@ -1921,17 +2237,19 @@ dirfile(char *s)
++
++ // test that iput() is called at the end of _namei().
++ // also tests empty file names.
++-void
++-iref(char *s)
+++void iref(char *s)
++ {
++   int i, fd;
++
++-  for(i = 0; i < NINODE + 1; i++){
++-    if(mkdir("irefd") != 0){
+++  for (i = 0; i < NINODE + 1; i++)
+++  {
+++    if (mkdir("irefd") != 0)
+++    {
++       printf("%s: mkdir irefd failed\n", s);
++       exit(1);
++     }
++-    if(chdir("irefd") != 0){
+++    if (chdir("irefd") != 0)
+++    {
++       printf("%s: chdir irefd failed\n", s);
++       exit(1);
++     }
++@@ -1939,16 +2257,17 @@ iref(char *s)
++     mkdir("");
++     link("README", "");
++     fd = open("", O_CREATE);
++-    if(fd >= 0)
+++    if (fd >= 0)
++       close(fd);
++     fd = open("xx", O_CREATE);
++-    if(fd >= 0)
+++    if (fd >= 0)
++       close(fd);
++     unlink("xx");
++   }
++
++   // clean up
++-  for(i = 0; i < NINODE + 1; i++){
+++  for (i = 0; i < NINODE + 1; i++)
+++  {
++     chdir("..");
++     unlink("irefd");
++   }
++@@ -1959,67 +2278,81 @@ iref(char *s)
++ // test that fork fails gracefully
++ // the forktest binary also does this, but it runs out of proc entries first.
++ // inside the bigger usertests binary, we run out of memory first.
++-void
++-forktest(char *s)
+++void forktest(char *s)
++ {
++-  enum{ N = 1000 };
+++  enum
+++  {
+++    N = 1000
+++  };
++   int n, pid;
++
++-  for(n=0; n<N; n++){
+++  for (n = 0; n < N; n++)
+++  {
++     pid = fork();
++-    if(pid < 0)
+++    if (pid < 0)
++       break;
++-    if(pid == 0)
+++    if (pid == 0)
++       exit(0);
++   }
++
++-  if (n == 0) {
+++  if (n == 0)
+++  {
++     printf("%s: no fork at all!\n", s);
++     exit(1);
++   }
++
++-  if(n == N){
+++  if (n == N)
+++  {
++     printf("%s: fork claimed to work 1000 times!\n", s);
++     exit(1);
++   }
++
++-  for(; n > 0; n--){
++-    if(wait(0) < 0){
+++  for (; n > 0; n--)
+++  {
+++    if (wait(0) < 0)
+++    {
++       printf("%s: wait stopped early\n", s);
++       exit(1);
++     }
++   }
++
++-  if(wait(0) != -1){
+++  if (wait(0) != -1)
+++  {
++     printf("%s: wait got too many\n", s);
++     exit(1);
++   }
++ }
++
++-void
++-sbrkbasic(char *s)
+++void sbrkbasic(char *s)
++ {
++-  enum { TOOMUCH=1024*1024*1024};
+++  enum
+++  {
+++    TOOMUCH = 1024 * 1024 * 1024
+++  };
++   int i, pid, xstatus;
++   char *c, *a, *b;
++
++   // does sbrk() return the expected failure value?
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed in sbrkbasic\n");
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     a = sbrk(TOOMUCH);
++-    if(a == (char*)0xffffffffffffffffL){
+++    if (a == (char *)0xffffffffffffffffL)
+++    {
++       // it's OK if this fails.
++       exit(0);
++     }
++-
++-    for(b = a; b < a+TOOMUCH; b += 4096){
+++
+++    for (b = a; b < a + TOOMUCH; b += 4096)
+++    {
++       *b = 99;
++     }
++-
+++
++     // we should not get here! either sbrk(TOOMUCH)
++     // should have failed, or (with lazy allocation)
++     // a pagefault should have killed this process.
++@@ -2027,16 +2360,19 @@ sbrkbasic(char *s)
++   }
++
++   wait(&xstatus);
++-  if(xstatus == 1){
+++  if (xstatus == 1)
+++  {
++     printf("%s: too much memory allocated!\n", s);
++     exit(1);
++   }
++
++   // can one sbrk() less than a page?
++   a = sbrk(0);
++-  for(i = 0; i < 5000; i++){
+++  for (i = 0; i < 5000; i++)
+++  {
++     b = sbrk(1);
++-    if(b != a){
+++    if (b != a)
+++    {
++       printf("%s: sbrk test failed %d %p %p\n", s, i, a, b);
++       exit(1);
++     }
++@@ -2044,26 +2380,30 @@ sbrkbasic(char *s)
++     a = b + 1;
++   }
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: sbrk test fork failed\n", s);
++     exit(1);
++   }
++   c = sbrk(1);
++   c = sbrk(1);
++-  if(c != a + 1){
+++  if (c != a + 1)
+++  {
++     printf("%s: sbrk test failed post-fork\n", s);
++     exit(1);
++   }
++-  if(pid == 0)
+++  if (pid == 0)
++     exit(0);
++   wait(&xstatus);
++   exit(xstatus);
++ }
++
++-void
++-sbrkmuch(char *s)
+++void sbrkmuch(char *s)
++ {
++-  enum { BIG=100*1024*1024 };
+++  enum
+++  {
+++    BIG = 100 * 1024 * 1024
+++  };
++   char *c, *oldbrk, *a, *lastaddr, *p;
++   uint64 amt;
++
++@@ -2073,28 +2413,31 @@ sbrkmuch(char *s)
++   a = sbrk(0);
++   amt = BIG - (uint64)a;
++   p = sbrk(amt);
++-  if (p != a) {
+++  if (p != a)
+++  {
++     printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
++     exit(1);
++   }
++
++   // touch each page to make sure it exists.
++   char *eee = sbrk(0);
++-  for(char *pp = a; pp < eee; pp += 4096)
+++  for (char *pp = a; pp < eee; pp += 4096)
++     *pp = 1;
++
++-  lastaddr = (char*) (BIG-1);
+++  lastaddr = (char *)(BIG - 1);
++   *lastaddr = 99;
++
++   // can one de-allocate?
++   a = sbrk(0);
++   c = sbrk(-PGSIZE);
++-  if(c == (char*)0xffffffffffffffffL){
+++  if (c == (char *)0xffffffffffffffffL)
+++  {
++     printf("%s: sbrk could not deallocate\n", s);
++     exit(1);
++   }
++   c = sbrk(0);
++-  if(c != a - PGSIZE){
+++  if (c != a - PGSIZE)
+++  {
++     printf("%s: sbrk deallocation produced wrong address, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++@@ -2102,11 +2445,13 @@ sbrkmuch(char *s)
++   // can one re-allocate that page?
++   a = sbrk(0);
++   c = sbrk(PGSIZE);
++-  if(c != a || sbrk(0) != a + PGSIZE){
+++  if (c != a || sbrk(0) != a + PGSIZE)
+++  {
++     printf("%s: sbrk re-allocation failed, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++-  if(*lastaddr == 99){
+++  if (*lastaddr == 99)
+++  {
++     // should be zero
++     printf("%s: sbrk de-allocation didn't really deallocate\n", s);
++     exit(1);
++@@ -2114,118 +2459,134 @@ sbrkmuch(char *s)
++
++   a = sbrk(0);
++   c = sbrk(-(sbrk(0) - oldbrk));
++-  if(c != a){
+++  if (c != a)
+++  {
++     printf("%s: sbrk downsize failed, a %p c %p\n", s, a, c);
++     exit(1);
++   }
++ }
++
++ // can we read the kernel's memory?
++-void
++-kernmem(char *s)
+++void kernmem(char *s)
++ {
++   char *a;
++   int pid;
++
++-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+++  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000)
+++  {
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       printf("%s: oops could read %p = %x\n", s, a, *a);
++       exit(1);
++     }
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != -1)  // did kernel kill child?
+++    if (xstatus != -1) // did kernel kill child?
++       exit(1);
++   }
++ }
++
++ // user code should not be able to write to addresses above MAXVA.
++-void
++-MAXVAplus(char *s)
+++void MAXVAplus(char *s)
++ {
++   volatile uint64 a = MAXVA;
++-  for( ; a != 0; a <<= 1){
+++  for (; a != 0; a <<= 1)
+++  {
++     int pid;
++     pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++-    if(pid == 0){
++-      *(char*)a = 99;
++-      printf("%s: oops wrote %p\n", s, (void*)a);
+++    if (pid == 0)
+++    {
+++      *(char *)a = 99;
+++      printf("%s: oops wrote %p\n", s, (void *)a);
++       exit(1);
++     }
++     int xstatus;
++     wait(&xstatus);
++-    if(xstatus != -1)  // did kernel kill child?
+++    if (xstatus != -1) // did kernel kill child?
++       exit(1);
++   }
++ }
++
++ // if we run the system out of memory, does it clean up the last
++ // failed allocation?
++-void
++-sbrkfail(char *s)
+++void sbrkfail(char *s)
++ {
++-  enum { BIG=100*1024*1024 };
+++  enum
+++  {
+++    BIG = 100 * 1024 * 1024
+++  };
++   int i, xstatus;
++   int fds[2];
++   char scratch;
++   char *c, *a;
++   int pids[10];
++   int pid;
++-
++-  if(pipe(fds) != 0){
+++
+++  if (pipe(fds) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++   }
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if((pids[i] = fork()) == 0){
+++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+++  {
+++    if ((pids[i] = fork()) == 0)
+++    {
++       // allocate a lot of memory
++       sbrk(BIG - (uint64)sbrk(0));
++       write(fds[1], "x", 1);
++       // sit around until killed
++-      for(;;) sleep(1000);
+++      for (;;)
+++        sleep(1000);
++     }
++-    if(pids[i] != -1)
+++    if (pids[i] != -1)
++       read(fds[0], &scratch, 1);
++   }
++
++   // if those failed allocations freed up the pages they did allocate,
++   // we'll be able to allocate here
++   c = sbrk(PGSIZE);
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if(pids[i] == -1)
+++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+++  {
+++    if (pids[i] == -1)
++       continue;
++     kill(pids[i]);
++     wait(0);
++   }
++-  if(c == (char*)0xffffffffffffffffL){
+++  if (c == (char *)0xffffffffffffffffL)
+++  {
++     printf("%s: failed sbrk leaked memory\n", s);
++     exit(1);
++   }
++
++-  // test running fork with the above allocated page
+++  // test running fork with the above allocated page
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     // allocate a lot of memory.
++     // this should produce a page fault,
++     // and thus not complete.
++     a = sbrk(0);
++-    sbrk(10*BIG);
+++    sbrk(10 * BIG);
++     int n = 0;
++-    for (i = 0; i < 10*BIG; i += PGSIZE) {
++-      n += *(a+i);
+++    for (i = 0; i < 10 * BIG; i += PGSIZE)
+++    {
+++      n += *(a + i);
++     }
++     // print n so the compiler doesn't optimize away
++     // the for loop.
++@@ -2233,26 +2594,26 @@ sbrkfail(char *s)
++     exit(1);
++   }
++   wait(&xstatus);
++-  if(xstatus != -1 && xstatus != 2)
+++  if (xstatus != -1 && xstatus != 2)
++     exit(1);
++ }
++
++-
++ // test reads/writes from/to allocated memory
++-void
++-sbrkarg(char *s)
+++void sbrkarg(char *s)
++ {
++   char *a;
++   int fd, n;
++
++   a = sbrk(PGSIZE);
++-  fd = open("sbrk", O_CREATE|O_WRONLY);
+++  fd = open("sbrk", O_CREATE | O_WRONLY);
++   unlink("sbrk");
++-  if(fd < 0)  {
+++  if (fd < 0)
+++  {
++     printf("%s: open sbrk failed\n", s);
++     exit(1);
++   }
++-  if ((n = write(fd, a, PGSIZE)) < 0) {
+++  if ((n = write(fd, a, PGSIZE)) < 0)
+++  {
++     printf("%s: write sbrk failed\n", s);
++     exit(1);
++   }
++@@ -2260,22 +2621,24 @@ sbrkarg(char *s)
++
++   // test writes to allocated memory
++   a = sbrk(PGSIZE);
++-  if(pipe((int *) a) != 0){
+++  if (pipe((int *)a) != 0)
+++  {
++     printf("%s: pipe() failed\n", s);
++     exit(1);
++-  }
+++  }
++ }
++
++-void
++-validatetest(char *s)
+++void validatetest(char *s)
++ {
++   int hi;
++   uint64 p;
++
++-  hi = 1100*1024;
++-  for(p = 0; p <= (uint)hi; p += PGSIZE){
+++  hi = 1100 * 1024;
+++  for (p = 0; p <= (uint)hi; p += PGSIZE)
+++  {
++     // try to crash the kernel by passing in a bad string pointer
++-    if(link("nosuchfile", (char*)p) != -1){
+++    if (link("nosuchfile", (char *)p) != -1)
+++    {
++       printf("%s: link should not succeed\n", s);
++       exit(1);
++     }
++@@ -2284,13 +2647,14 @@ validatetest(char *s)
++
++ // does uninitialized data start out zero?
++ char uninit[10000];
++-void
++-bsstest(char *s)
+++void bsstest(char *s)
++ {
++   int i;
++
++-  for(i = 0; i < sizeof(uninit); i++){
++-    if(uninit[i] != '\0'){
+++  for (i = 0; i < sizeof(uninit); i++)
+++  {
+++    if (uninit[i] != '\0')
+++    {
++       printf("%s: bss test failed\n", s);
++       exit(1);
++     }
++@@ -2300,38 +2664,41 @@ bsstest(char *s)
++ // does exec return an error if the arguments
++ // are larger than a page? or does it write
++ // below the stack and wreck the instructions/data?
++-void
++-bigargtest(char *s)
+++void bigargtest(char *s)
++ {
++   int pid, fd, xstatus;
++
++   unlink("bigarg-ok");
++   pid = fork();
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     static char *args[MAXARG];
++     int i;
++     char big[400];
++     memset(big, ' ', sizeof(big));
++-    big[sizeof(big)-1] = '\0';
++-    for(i = 0; i < MAXARG-1; i++)
+++    big[sizeof(big) - 1] = '\0';
+++    for (i = 0; i < MAXARG - 1; i++)
++       args[i] = big;
++-    args[MAXARG-1] = 0;
+++    args[MAXARG - 1] = 0;
++     // this exec() should fail (and return) because the
++     // arguments are too large.
++     exec("echo", args);
++     fd = open("bigarg-ok", O_CREATE);
++     close(fd);
++     exit(0);
++-  } else if(pid < 0){
+++  }
+++  else if (pid < 0)
+++  {
++     printf("%s: bigargtest: fork failed\n", s);
++     exit(1);
++   }
++-
+++
++   wait(&xstatus);
++-  if(xstatus != 0)
+++  if (xstatus != 0)
++     exit(xstatus);
++   fd = open("bigarg-ok", 0);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: bigarg test failed!\n", s);
++     exit(1);
++   }
++@@ -2340,15 +2707,15 @@ bigargtest(char *s)
++
++ // what happens when the file system runs out of blocks?
++ // answer: balloc panics, so this test is not useful.
++-void
++-fsfull()
+++void fsfull()
++ {
++   int nfiles;
++   int fsblocks = 0;
++
++   printf("fsfull test\n");
++
++-  for(nfiles = 0; ; nfiles++){
+++  for (nfiles = 0;; nfiles++)
+++  {
++     char name[64];
++     name[0] = 'f';
++     name[1] = '0' + nfiles / 1000;
++@@ -2357,26 +2724,29 @@ fsfull()
++     name[4] = '0' + (nfiles % 10);
++     name[5] = '\0';
++     printf("writing %s\n", name);
++-    int fd = open(name, O_CREATE|O_RDWR);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR);
+++    if (fd < 0)
+++    {
++       printf("open %s failed\n", name);
++       break;
++     }
++     int total = 0;
++-    while(1){
+++    while (1)
+++    {
++       int cc = write(fd, buf, BSIZE);
++-      if(cc < BSIZE)
+++      if (cc < BSIZE)
++         break;
++       total += cc;
++       fsblocks++;
++     }
++     printf("wrote %d bytes\n", total);
++     close(fd);
++-    if(total == 0)
+++    if (total == 0)
++       break;
++   }
++
++-  while(nfiles >= 0){
+++  while (nfiles >= 0)
+++  {
++     char name[64];
++     name[0] = 'f';
++     name[1] = '0' + nfiles / 1000;
++@@ -2395,7 +2765,8 @@ void argptest(char *s)
++ {
++   int fd;
++   fd = open("init", O_RDONLY);
++-  if (fd < 0) {
+++  if (fd < 0)
+++  {
++     printf("%s: open failed\n", s);
++     exit(1);
++   }
++@@ -2405,25 +2776,27 @@ void argptest(char *s)
++
++ // check that there's an invalid page beneath
++ // the user stack, to catch stack overflow.
++-void
++-stacktest(char *s)
+++void stacktest(char *s)
++ {
++   int pid;
++   int xstatus;
++-
+++
++   pid = fork();
++-  if(pid == 0) {
++-    char *sp = (char *) r_sp();
++-    sp -= USERSTACK*PGSIZE;
+++  if (pid == 0)
+++  {
+++    char *sp = (char *)r_sp();
+++    sp -= USERSTACK * PGSIZE;
++     // the *sp should cause a trap.
++     printf("%s: stacktest: read below stack %d\n", s, *sp);
++     exit(1);
++-  } else if(pid < 0){
+++  }
+++  else if (pid < 0)
+++  {
++     printf("%s: fork failed\n", s);
++     exit(1);
++   }
++   wait(&xstatus);
++-  if(xstatus == -1)  // kernel killed child?
+++  if (xstatus == -1) // kernel killed child?
++     exit(0);
++   else
++     exit(xstatus);
++@@ -2431,27 +2804,31 @@ stacktest(char *s)
++
++ // check that writes to a few forbidden addresses
++ // cause a fault, e.g. process's text and TRAMPOLINE.
++-void
++-nowrite(char *s)
+++void nowrite(char *s)
++ {
++   int pid;
++   int xstatus;
++-  uint64 addrs[] = { 0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++-                     0xffffffffffffffff };
++-
++-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+++  uint64 addrs[] = {0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+++                    0xffffffffffffffff};
+++
+++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
+++  {
++     pid = fork();
++-    if(pid == 0) {
++-      volatile int *addr = (int *) addrs[ai];
+++    if (pid == 0)
+++    {
+++      volatile int *addr = (int *)addrs[ai];
++       *addr = 10;
++       printf("%s: write to %p did not fail!\n", s, addr);
++       exit(0);
++-    } else if(pid < 0){
+++    }
+++    else if (pid < 0)
+++    {
++       printf("%s: fork failed\n", s);
++       exit(1);
++     }
++     wait(&xstatus);
++-    if(xstatus == 0){
+++    if (xstatus == 0)
+++    {
++       // kernel did not kill child!
++       exit(1);
++     }
++@@ -2462,9 +2839,8 @@ nowrite(char *s)
++ // regression test. copyin(), copyout(), and copyinstr() used to cast
++ // the virtual page address to uint, which (with certain wild system
++ // call arguments) resulted in a kernel page faults.
++-void *big = (void*) 0xeaeb0b5b00002f5e;
++-void
++-pgbug(char *s)
+++void *big = (void *)0xeaeb0b5b00002f5e;
+++void pgbug(char *s)
++ {
++   char *argv[1];
++   argv[0] = 0;
++@@ -2477,16 +2853,17 @@ pgbug(char *s)
++ // regression test. does the kernel panic if a process sbrk()s its
++ // size to be less than a page, or zero, or reduces the break by an
++ // amount too small to cause a page to be freed?
++-void
++-sbrkbugs(char *s)
+++void sbrkbugs(char *s)
++ {
++   int pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    int sz = (uint64) sbrk(0);
+++  if (pid == 0)
+++  {
+++    int sz = (uint64)sbrk(0);
++     // free all user memory; there used to be a bug that
++     // would not adjust p->sz correctly in this case,
++     // causing exit() to panic.
++@@ -2497,12 +2874,14 @@ sbrkbugs(char *s)
++   wait(0);
++
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
++-    int sz = (uint64) sbrk(0);
+++  if (pid == 0)
+++  {
+++    int sz = (uint64)sbrk(0);
++     // set the break to somewhere in the very first
++     // page; there used to be a bug that would incorrectly
++     // free the first page.
++@@ -2512,13 +2891,15 @@ sbrkbugs(char *s)
++   wait(0);
++
++   pid = fork();
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed\n");
++     exit(1);
++   }
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     // set the break in the middle of a page.
++-    sbrk((10*4096 + 2048) - (uint64)sbrk(0));
+++    sbrk((10 * 4096 + 2048) - (uint64)sbrk(0));
++
++     // reduce the break a bit, but not enough to
++     // cause a page to be freed. this used to cause
++@@ -2535,123 +2916,119 @@ sbrkbugs(char *s)
++ // if process size was somewhat more than a page boundary, and then
++ // shrunk to be somewhat less than that page boundary, can the kernel
++ // still copyin() from addresses in the last page?
++-void
++-sbrklast(char *s)
+++void sbrklast(char *s)
++ {
++-  uint64 top = (uint64) sbrk(0);
++-  if((top % 4096) != 0)
+++  uint64 top = (uint64)sbrk(0);
+++  if ((top % 4096) != 0)
++     sbrk(4096 - (top % 4096));
++   sbrk(4096);
++   sbrk(10);
++   sbrk(-20);
++-  top = (uint64) sbrk(0);
++-  char *p = (char *) (top - 64);
+++  top = (uint64)sbrk(0);
+++  char *p = (char *)(top - 64);
++   p[0] = 'x';
++   p[1] = '\0';
++-  int fd = open(p, O_RDWR|O_CREATE);
+++  int fd = open(p, O_RDWR | O_CREATE);
++   write(fd, p, 1);
++   close(fd);
++   fd = open(p, O_RDWR);
++   p[0] = '\0';
++   read(fd, p, 1);
++-  if(p[0] != 'x')
+++  if (p[0] != 'x')
++     exit(1);
++ }
++
++-
++ // does sbrk handle signed int32 wrap-around with
++ // negative arguments?
++-void
++-sbrk8000(char *s)
+++void sbrk8000(char *s)
++ {
++   sbrk(0x80000004);
++   volatile char *top = sbrk(0);
++-  *(top-1) = *(top-1) + 1;
+++  *(top - 1) = *(top - 1) + 1;
++ }
++
++-
++-
++ // regression test. test whether exec() leaks memory if one of the
++ // arguments is invalid. the test passes if the kernel doesn't panic.
++-void
++-badarg(char *s)
+++void badarg(char *s)
++ {
++-  for(int i = 0; i < 50000; i++){
+++  for (int i = 0; i < 50000; i++)
+++  {
++     char *argv[2];
++-    argv[0] = (char*)0xffffffff;
+++    argv[0] = (char *)0xffffffff;
++     argv[1] = 0;
++     exec("echo", argv);
++   }
++-
+++
++   exit(0);
++ }
++
++-struct test {
+++struct test
+++{
++   void (*f)(char *);
++   char *s;
++ } quicktests[] = {
++-  {copyin, "copyin"},
++-  {copyout, "copyout"},
++-  {copyinstr1, "copyinstr1"},
++-  {copyinstr2, "copyinstr2"},
++-  {copyinstr3, "copyinstr3"},
++-  {rwsbrk, "rwsbrk" },
++-  {truncate1, "truncate1"},
++-  {truncate2, "truncate2"},
++-  {truncate3, "truncate3"},
++-  {openiputtest, "openiput"},
++-  {exitiputtest, "exitiput"},
++-  {iputtest, "iput"},
++-  {opentest, "opentest"},
++-  {writetest, "writetest"},
++-  {writebig, "writebig"},
++-  {createtest, "createtest"},
++-  {dirtest, "dirtest"},
++-  {exectest, "exectest"},
++-  {pipe1, "pipe1"},
++-  {killstatus, "killstatus"},
++-  {preempt, "preempt"},
++-  {exitwait, "exitwait"},
++-  {reparent, "reparent" },
++-  {twochildren, "twochildren"},
++-  {forkfork, "forkfork"},
++-  {forkforkfork, "forkforkfork"},
++-  {reparent2, "reparent2"},
++-  {mem, "mem"},
++-  {sharedfd, "sharedfd"},
++-  {fourfiles, "fourfiles"},
++-  {createdelete, "createdelete"},
++-  {unlinkread, "unlinkread"},
++-  {linktest, "linktest"},
++-  {concreate, "concreate"},
++-  {linkunlink, "linkunlink"},
++-  {subdir, "subdir"},
++-  {bigwrite, "bigwrite"},
++-  {bigfile, "bigfile"},
++-  {fourteen, "fourteen"},
++-  {rmdot, "rmdot"},
++-  {dirfile, "dirfile"},
++-  {iref, "iref"},
++-  {forktest, "forktest"},
++-  {sbrkbasic, "sbrkbasic"},
++-  {sbrkmuch, "sbrkmuch"},
++-  {kernmem, "kernmem"},
++-  {MAXVAplus, "MAXVAplus"},
++-  {sbrkfail, "sbrkfail"},
++-  {sbrkarg, "sbrkarg"},
++-  {validatetest, "validatetest"},
++-  {bsstest, "bsstest"},
++-  {bigargtest, "bigargtest"},
++-  {argptest, "argptest"},
++-  {stacktest, "stacktest"},
++-  {nowrite, "nowrite"},
++-  {pgbug, "pgbug" },
++-  {sbrkbugs, "sbrkbugs" },
++-  {sbrklast, "sbrklast"},
++-  {sbrk8000, "sbrk8000"},
++-  {badarg, "badarg" },
++-
++-  { 0, 0},
+++    {copyin, "copyin"},
+++    {copyout, "copyout"},
+++    {copyinstr1, "copyinstr1"},
+++    {copyinstr2, "copyinstr2"},
+++    {copyinstr3, "copyinstr3"},
+++    {rwsbrk, "rwsbrk"},
+++    {truncate1, "truncate1"},
+++    {truncate2, "truncate2"},
+++    {truncate3, "truncate3"},
+++    {openiputtest, "openiput"},
+++    {exitiputtest, "exitiput"},
+++    {iputtest, "iput"},
+++    {opentest, "opentest"},
+++    {writetest, "writetest"},
+++    {writebig, "writebig"},
+++    {createtest, "createtest"},
+++    {dirtest, "dirtest"},
+++    {exectest, "exectest"},
+++    {pipe1, "pipe1"},
+++    {killstatus, "killstatus"},
+++    {preempt, "preempt"},
+++    {exitwait, "exitwait"},
+++    {reparent, "reparent"},
+++    {twochildren, "twochildren"},
+++    {forkfork, "forkfork"},
+++    {forkforkfork, "forkforkfork"},
+++    {reparent2, "reparent2"},
+++    {mem, "mem"},
+++    {sharedfd, "sharedfd"},
+++    {fourfiles, "fourfiles"},
+++    {createdelete, "createdelete"},
+++    {unlinkread, "unlinkread"},
+++    {linktest, "linktest"},
+++    {concreate, "concreate"},
+++    {linkunlink, "linkunlink"},
+++    {subdir, "subdir"},
+++    {bigwrite, "bigwrite"},
+++    {bigfile, "bigfile"},
+++    {fourteen, "fourteen"},
+++    {rmdot, "rmdot"},
+++    {dirfile, "dirfile"},
+++    {iref, "iref"},
+++    {forktest, "forktest"},
+++    {sbrkbasic, "sbrkbasic"},
+++    {sbrkmuch, "sbrkmuch"},
+++    {kernmem, "kernmem"},
+++    {MAXVAplus, "MAXVAplus"},
+++    {sbrkfail, "sbrkfail"},
+++    {sbrkarg, "sbrkarg"},
+++    {validatetest, "validatetest"},
+++    {bsstest, "bsstest"},
+++    {bigargtest, "bigargtest"},
+++    {argptest, "argptest"},
+++    {stacktest, "stacktest"},
+++    {nowrite, "nowrite"},
+++    {pgbug, "pgbug"},
+++    {sbrkbugs, "sbrkbugs"},
+++    {sbrklast, "sbrklast"},
+++    {sbrk8000, "sbrk8000"},
+++    {badarg, "badarg"},
+++
+++    {0, 0},
++ };
++
++ //
++@@ -2659,40 +3036,47 @@ struct test {
++ //
++
++ // directory that uses indirect blocks
++-void
++-bigdir(char *s)
+++void bigdir(char *s)
++ {
++-  enum { N = 500 };
+++  enum
+++  {
+++    N = 500
+++  };
++   int i, fd;
++   char name[10];
++
++   unlink("bd");
++
++   fd = open("bd", O_CREATE);
++-  if(fd < 0){
+++  if (fd < 0)
+++  {
++     printf("%s: bigdir create failed\n", s);
++     exit(1);
++   }
++   close(fd);
++
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[0] = 'x';
++     name[1] = '0' + (i / 64);
++     name[2] = '0' + (i % 64);
++     name[3] = '\0';
++-    if(link("bd", name) != 0){
+++    if (link("bd", name) != 0)
+++    {
++       printf("%s: bigdir i=%d link(bd, %s) failed\n", s, i, name);
++       exit(1);
++     }
++   }
++
++   unlink("bd");
++-  for(i = 0; i < N; i++){
+++  for (i = 0; i < N; i++)
+++  {
++     name[0] = 'x';
++     name[1] = '0' + (i / 64);
++     name[2] = '0' + (i % 64);
++     name[3] = '\0';
++-    if(unlink(name) != 0){
+++    if (unlink(name) != 0)
+++    {
++       printf("%s: bigdir unlink failed", s);
++       exit(1);
++     }
++@@ -2701,36 +3085,42 @@ bigdir(char *s)
++
++ // concurrent writes to try to provoke deadlock in the virtio disk
++ // driver.
++-void
++-manywrites(char *s)
+++void manywrites(char *s)
++ {
++   int nchildren = 4;
++   int howmany = 30; // increase to look for deadlock
++-
++-  for(int ci = 0; ci < nchildren; ci++){
+++
+++  for (int ci = 0; ci < nchildren; ci++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++     }
++
++-    if(pid == 0){
+++    if (pid == 0)
+++    {
++       char name[3];
++       name[0] = 'b';
++       name[1] = 'a' + ci;
++       name[2] = '\0';
++       unlink(name);
++-
++-      for(int iters = 0; iters < howmany; iters++){
++-        for(int i = 0; i < ci+1; i++){
+++
+++      for (int iters = 0; iters < howmany; iters++)
+++      {
+++        for (int i = 0; i < ci + 1; i++)
+++        {
++           int fd = open(name, O_CREATE | O_RDWR);
++-          if(fd < 0){
+++          if (fd < 0)
+++          {
++             printf("%s: cannot create %s\n", s, name);
++             exit(1);
++           }
++           int sz = sizeof(buf);
++           int cc = write(fd, buf, sz);
++-          if(cc != sz){
+++          if (cc != sz)
+++          {
++             printf("%s: write(%d) ret %d\n", s, sz, cc);
++             exit(1);
++           }
++@@ -2744,10 +3134,11 @@ manywrites(char *s)
++     }
++   }
++
++-  for(int ci = 0; ci < nchildren; ci++){
+++  for (int ci = 0; ci < nchildren; ci++)
+++  {
++     int st = 0;
++     wait(&st);
++-    if(st != 0)
+++    if (st != 0)
++       exit(st);
++   }
++   exit(0);
++@@ -2758,29 +3149,32 @@ manywrites(char *s)
++ // file is deleted? if the kernel has this bug, it will panic: balloc:
++ // out of blocks. assumed_free may need to be raised to be more than
++ // the number of free blocks. this test takes a long time.
++-void
++-badwrite(char *s)
+++void badwrite(char *s)
++ {
++   int assumed_free = 600;
++-
+++
++   unlink("junk");
++-  for(int i = 0; i < assumed_free; i++){
++-    int fd = open("junk", O_CREATE|O_WRONLY);
++-    if(fd < 0){
+++  for (int i = 0; i < assumed_free; i++)
+++  {
+++    int fd = open("junk", O_CREATE | O_WRONLY);
+++    if (fd < 0)
+++    {
++       printf("open junk failed\n");
++       exit(1);
++     }
++-    write(fd, (char*)0xffffffffffL, 1);
+++    write(fd, (char *)0xffffffffffL, 1);
++     close(fd);
++     unlink("junk");
++   }
++
++-  int fd = open("junk", O_CREATE|O_WRONLY);
++-  if(fd < 0){
+++  int fd = open("junk", O_CREATE | O_WRONLY);
+++  if (fd < 0)
+++  {
++     printf("open junk failed\n");
++     exit(1);
++   }
++-  if(write(fd, "x", 1) != 1){
+++  if (write(fd, "x", 1) != 1)
+++  {
++     printf("write failed\n");
++     exit(1);
++   }
++@@ -2793,34 +3187,40 @@ badwrite(char *s)
++ // test the exec() code that cleans up if it runs out
++ // of memory. it's really a test that such a condition
++ // doesn't cause a panic.
++-void
++-execout(char *s)
+++void execout(char *s)
++ {
++-  for(int avail = 0; avail < 15; avail++){
+++  for (int avail = 0; avail < 15; avail++)
+++  {
++     int pid = fork();
++-    if(pid < 0){
+++    if (pid < 0)
+++    {
++       printf("fork failed\n");
++       exit(1);
++-    } else if(pid == 0){
+++    }
+++    else if (pid == 0)
+++    {
++       // allocate all of memory.
++-      while(1){
++-        uint64 a = (uint64) sbrk(4096);
++-        if(a == 0xffffffffffffffffLL)
+++      while (1)
+++      {
+++        uint64 a = (uint64)sbrk(4096);
+++        if (a == 0xffffffffffffffffLL)
++           break;
++-        *(char*)(a + 4096 - 1) = 1;
+++        *(char *)(a + 4096 - 1) = 1;
++       }
++
++       // free a few pages, in order to let exec() make some
++       // progress.
++-      for(int i = 0; i < avail; i++)
+++      for (int i = 0; i < avail; i++)
++         sbrk(-4096);
++-
+++
++       close(1);
++-      char *args[] = { "echo", "x", 0 };
+++      char *args[] = {"echo", "x", 0};
++       exec("echo", args);
++       exit(0);
++-    } else {
++-      wait((int*)0);
+++    }
+++    else
+++    {
+++      wait((int *)0);
++     }
++   }
++
++@@ -2828,15 +3228,15 @@ execout(char *s)
++ }
++
++ // can the kernel tolerate running out of disk space?
++-void
++-diskfull(char *s)
+++void diskfull(char *s)
++ {
++   int fi;
++   int done = 0;
++
++   unlink("diskfulldir");
++-
++-  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
+++
+++  for (fi = 0; done == 0 && '0' + fi < 0177; fi++)
+++  {
++     char name[32];
++     name[0] = 'b';
++     name[1] = 'i';
++@@ -2844,16 +3244,19 @@ diskfull(char *s)
++     name[3] = '0' + fi;
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
+++    {
++       // oops, ran out of inodes before running out of blocks.
++       printf("%s: could not create file %s\n", s, name);
++       done = 1;
++       break;
++     }
++-    for(int i = 0; i < MAXFILE; i++){
+++    for (int i = 0; i < MAXFILE; i++)
+++    {
++       char buf[BSIZE];
++-      if(write(fd, buf, BSIZE) != BSIZE){
+++      if (write(fd, buf, BSIZE) != BSIZE)
+++      {
++         done = 1;
++         close(fd);
++         break;
++@@ -2867,7 +3270,8 @@ diskfull(char *s)
++   // directory content. one of these file creations
++   // is expected to fail.
++   int nzz = 128;
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2875,19 +3279,20 @@ diskfull(char *s)
++     name[3] = '0' + (i % 32);
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0)
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
++       break;
++     close(fd);
++   }
++
++   // this mkdir() is expected to fail.
++-  if(mkdir("diskfulldir") == 0)
+++  if (mkdir("diskfulldir") == 0)
++     printf("%s: mkdir(diskfulldir) unexpectedly succeeded!\n", s);
++
++   unlink("diskfulldir");
++
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2897,7 +3302,8 @@ diskfull(char *s)
++     unlink(name);
++   }
++
++-  for(int i = 0; '0' + i < 0177; i++){
+++  for (int i = 0; '0' + i < 0177; i++)
+++  {
++     char name[32];
++     name[0] = 'b';
++     name[1] = 'i';
++@@ -2908,11 +3314,11 @@ diskfull(char *s)
++   }
++ }
++
++-void
++-outofinodes(char *s)
+++void outofinodes(char *s)
++ {
++-  int nzz = 32*32;
++-  for(int i = 0; i < nzz; i++){
+++  int nzz = 32 * 32;
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2920,15 +3326,17 @@ outofinodes(char *s)
++     name[3] = '0' + (i % 32);
++     name[4] = '\0';
++     unlink(name);
++-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
++-    if(fd < 0){
+++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
+++    if (fd < 0)
+++    {
++       // failure is eventually expected.
++       break;
++     }
++     close(fd);
++   }
++
++-  for(int i = 0; i < nzz; i++){
+++  for (int i = 0; i < nzz; i++)
+++  {
++     char name[32];
++     name[0] = 'z';
++     name[1] = 'z';
++@@ -2940,14 +3348,14 @@ outofinodes(char *s)
++ }
++
++ struct test slowtests[] = {
++-  {bigdir, "bigdir"},
++-  {manywrites, "manywrites"},
++-  {badwrite, "badwrite" },
++-  {execout, "execout"},
++-  {diskfull, "diskfull"},
++-  {outofinodes, "outofinodes"},
++-
++-  { 0, 0},
+++    {bigdir, "bigdir"},
+++    {manywrites, "manywrites"},
+++    {badwrite, "badwrite"},
+++    {execout, "execout"},
+++    {diskfull, "diskfull"},
+++    {outofinodes, "outofinodes"},
+++
+++    {0, 0},
++ };
++
++ //
++@@ -2956,22 +3364,26 @@ struct test slowtests[] = {
++
++ // run each test in its own process. run returns 1 if child's exit()
++ // indicates success.
++-int
++-run(void f(char *), char *s) {
+++int run(void f(char *), char *s)
+++{
++   int pid;
++   int xstatus;
++
++   printf("test %s: ", s);
++-  if((pid = fork()) < 0) {
+++  if ((pid = fork()) < 0)
+++  {
++     printf("runtest: fork error\n");
++     exit(1);
++   }
++-  if(pid == 0) {
+++  if (pid == 0)
+++  {
++     f(s);
++     exit(0);
++-  } else {
+++  }
+++  else
+++  {
++     wait(&xstatus);
++-    if(xstatus != 0)
+++    if (xstatus != 0)
++       printf("FAILED\n");
++     else
++       printf("OK\n");
++@@ -2979,12 +3391,16 @@ run(void f(char *), char *s) {
++   }
++ }
++
++-int
++-runtests(struct test *tests, char *justone, int continuous) {
++-  for (struct test *t = tests; t->s != 0; t++) {
++-    if((justone == 0) || strcmp(t->s, justone) == 0) {
++-      if(!run(t->f, t->s)){
++-        if(continuous != 2){
+++int runtests(struct test *tests, char *justone, int continuous)
+++{
+++  for (struct test *t = tests; t->s != 0; t++)
+++  {
+++    if ((justone == 0) || strcmp(t->s, justone) == 0)
+++    {
+++      if (!run(t->f, t->s))
+++      {
+++        if (continuous != 2)
+++        {
++           printf("SOME TESTS FAILED\n");
++           return 1;
++         }
++@@ -2994,36 +3410,39 @@ runtests(struct test *tests, char *justone, int continuous) {
++   return 0;
++ }
++
++-
++ //
++ // use sbrk() to count how many free physical memory pages there are.
++ // touches the pages to force allocation.
++ // because out of memory with lazy allocation results in the process
++ // taking a fault and being killed, fork and report back.
++ //
++-int
++-countfree()
+++int countfree()
++ {
++   int fds[2];
++
++-  if(pipe(fds) < 0){
+++  if (pipe(fds) < 0)
+++  {
++     printf("pipe() failed in countfree()\n");
++     exit(1);
++   }
++-
+++
++   int pid = fork();
++
++-  if(pid < 0){
+++  if (pid < 0)
+++  {
++     printf("fork failed in countfree()\n");
++     exit(1);
++   }
++
++-  if(pid == 0){
+++  if (pid == 0)
+++  {
++     close(fds[0]);
++-
++-    while(1){
++-      uint64 a = (uint64) sbrk(4096);
++-      if(a == 0xffffffffffffffff){
+++
+++    while (1)
+++    {
+++      uint64 a = (uint64)sbrk(4096);
+++      if (a == 0xffffffffffffffff)
+++      {
++         break;
++       }
++
++@@ -3031,7 +3450,8 @@ countfree()
++       *(char *)(a + 4096 - 1) = 1;
++
++       // report back one more page.
++-      if(write(fds[1], "x", 1) != 1){
+++      if (write(fds[1], "x", 1) != 1)
+++      {
++         printf("write() failed in countfree()\n");
++         exit(1);
++       }
++@@ -3043,74 +3463,93 @@ countfree()
++   close(fds[1]);
++
++   int n = 0;
++-  while(1){
+++  while (1)
+++  {
++     char c;
++     int cc = read(fds[0], &c, 1);
++-    if(cc < 0){
+++    if (cc < 0)
+++    {
++       printf("read() failed in countfree()\n");
++       exit(1);
++     }
++-    if(cc == 0)
+++    if (cc == 0)
++       break;
++     n += 1;
++   }
++
++   close(fds[0]);
++-  wait((int*)0);
++-
+++  wait((int *)0);
+++
++   return n;
++ }
++
++-int
++-drivetests(int quick, int continuous, char *justone) {
++-  do {
+++int drivetests(int quick, int continuous, char *justone)
+++{
+++  do
+++  {
++     printf("usertests starting\n");
++     int free0 = countfree();
++     int free1 = 0;
++-    if (runtests(quicktests, justone, continuous)) {
++-      if(continuous != 2) {
+++    if (runtests(quicktests, justone, continuous))
+++    {
+++      if (continuous != 2)
+++      {
++         return 1;
++       }
++     }
++-    if(!quick) {
+++    if (!quick)
+++    {
++       if (justone == 0)
++         printf("usertests slow tests starting\n");
++-      if (runtests(slowtests, justone, continuous)) {
++-        if(continuous != 2) {
+++      if (runtests(slowtests, justone, continuous))
+++      {
+++        if (continuous != 2)
+++        {
++           return 1;
++         }
++       }
++     }
++-    if((free1 = countfree()) < free0) {
+++    if ((free1 = countfree()) < free0)
+++    {
++       printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
++-      if(continuous != 2) {
+++      if (continuous != 2)
+++      {
++         return 1;
++       }
++     }
++-  } while(continuous);
+++  } while (continuous);
++   return 0;
++ }
++
++-int
++-main(int argc, char *argv[])
+++int main(int argc, char *argv[])
++ {
++   int continuous = 0;
++   int quick = 0;
++   char *justone = 0;
++
++-  if(argc == 2 && strcmp(argv[1], "-q") == 0){
+++  if (argc == 2 && strcmp(argv[1], "-q") == 0)
+++  {
++     quick = 1;
++-  } else if(argc == 2 && strcmp(argv[1], "-c") == 0){
+++  }
+++  else if (argc == 2 && strcmp(argv[1], "-c") == 0)
+++  {
++     continuous = 1;
++-  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
+++  }
+++  else if (argc == 2 && strcmp(argv[1], "-C") == 0)
+++  {
++     continuous = 2;
++-  } else if(argc == 2 && argv[1][0] != '-'){
+++  }
+++  else if (argc == 2 && argv[1][0] != '-')
+++  {
++     justone = argv[1];
++-  } else if(argc > 1){
+++  }
+++  else if (argc > 1)
+++  {
++     printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
++     exit(1);
++   }
++-  if (drivetests(quick, continuous, justone)) {
+++  if (drivetests(quick, continuous, justone))
+++  {
++     exit(1);
++   }
++   printf("ALL TESTS PASSED\n");
++diff --git a/offline_2/xv6-riscv-riscv/user/usys.pl b/offline_2/xv6-riscv-riscv/user/usys.pl
++index 01e426e..9d54e5b 100755
++--- a/offline_2/xv6-riscv-riscv/user/usys.pl
+++++ b/offline_2/xv6-riscv-riscv/user/usys.pl
++@@ -36,3 +36,4 @@ entry("getpid");
++ entry("sbrk");
++ entry("sleep");
++ entry("uptime");
+++entry("history");
+diff --git a/offline_2/xv6-riscv-riscv/user/history.c b/offline_2/xv6-riscv-riscv/user/history.c
+new file mode 100644
+index 0000000..54e980a
+--- /dev/null
++++ b/offline_2/xv6-riscv-riscv/user/history.c
+@@ -0,0 +1,47 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++#include "kernel/syscall.h"
++#include "kernel/syscall_stat.h"
++
++void print_history(int syscall_num)
++{
++    struct syscall_stat s_stat;
++
++    if (history(syscall_num, &s_stat) == 0)
++    {
++        printf("%d: syscall: %s, #: %d, time: %d\n",
++               syscall_num,
++               s_stat.syscall_name,
++               s_stat.count,
++               s_stat.accum_time);
++    }
++    else
++    {
++        printf("Error fetching history for syscall %d\n", syscall_num);
++    }
++}
++
++int main(int argc, char *argv[])
++{
++    if (argc < 2)
++    {
++        // No arguments, print all
++        for (int i = 1; i <= 24; i++)
++            print_history(i);
++    }
++    else
++    {
++        int syscall_num = atoi(argv[1]);
++        if (syscall_num > 0)
++        {
++            print_history(syscall_num);
++        }
++        else
++        {
++            printf("Invalid syscall number.\n");
++        }
++    }
++
++    exit(0);
++}
+\ No newline at end of file
+diff --git a/offline_2/xv6-riscv-riscv/user/user.h b/offline_2/xv6-riscv-riscv/user/user.h
+index f16fe27..1cb3ac8 100644
+--- a/offline_2/xv6-riscv-riscv/user/user.h
++++ b/offline_2/xv6-riscv-riscv/user/user.h
+@@ -1,5 +1,5 @@
+ struct stat;
+-
++struct syscall_stat;
+ // system calls
+ int fork(void);
+ int exit(int) __attribute__((noreturn));
+@@ -22,6 +22,7 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int history(int, struct syscall_stat*);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/offline_2/xv6-riscv-riscv/user/usertests.c b/offline_2/xv6-riscv-riscv/user/usertests.c
+index 28b53f9..4273164 100644
+--- a/offline_2/xv6-riscv-riscv/user/usertests.c
++++ b/offline_2/xv6-riscv-riscv/user/usertests.c
+@@ -17,7 +17,7 @@
+ // prints "OK".
+ //
+ 
+-#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
++#define BUFSZ ((MAXOPBLOCKS + 2) * BSIZE)
+ 
+ char buf[BUFSZ];
+ 
+@@ -29,42 +29,47 @@ char buf[BUFSZ];
+ 
+ // what if you pass ridiculous pointers to system calls
+ // that read user memory with copyin?
+-void
+-copyin(char *s)
++void copyin(char *s)
+ {
+-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+-                     0xffffffffffffffff };
++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++                    0xffffffffffffffff};
+ 
+-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++  {
+     uint64 addr = addrs[ai];
+-    
+-    int fd = open("copyin1", O_CREATE|O_WRONLY);
+-    if(fd < 0){
++
++    int fd = open("copyin1", O_CREATE | O_WRONLY);
++    if (fd < 0)
++    {
+       printf("open(copyin1) failed\n");
+       exit(1);
+     }
+-    int n = write(fd, (void*)addr, 8192);
+-    if(n >= 0){
+-      printf("write(fd, %p, 8192) returned %d, not -1\n", (void*)addr, n);
++    int n = write(fd, (void *)addr, 8192);
++    if (n >= 0)
++    {
++      printf("write(fd, %p, 8192) returned %d, not -1\n", (void *)addr, n);
+       exit(1);
+     }
+     close(fd);
+     unlink("copyin1");
+-    
+-    n = write(1, (char*)addr, 8192);
+-    if(n > 0){
+-      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++
++    n = write(1, (char *)addr, 8192);
++    if (n > 0)
++    {
++      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+       exit(1);
+     }
+-    
++
+     int fds[2];
+-    if(pipe(fds) < 0){
++    if (pipe(fds) < 0)
++    {
+       printf("pipe() failed\n");
+       exit(1);
+     }
+-    n = write(fds[1], (char*)addr, 8192);
+-    if(n > 0){
+-      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++    n = write(fds[1], (char *)addr, 8192);
++    if (n > 0)
++    {
++      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+       exit(1);
+     }
+     close(fds[0]);
+@@ -74,40 +79,45 @@ copyin(char *s)
+ 
+ // what if you pass ridiculous pointers to system calls
+ // that write user memory with copyout?
+-void
+-copyout(char *s)
++void copyout(char *s)
+ {
+-  uint64 addrs[] = { 0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+-                     0xffffffffffffffff };
++  uint64 addrs[] = {0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++                    0xffffffffffffffff};
+ 
+-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++  {
+     uint64 addr = addrs[ai];
+ 
+     int fd = open("README", 0);
+-    if(fd < 0){
++    if (fd < 0)
++    {
+       printf("open(README) failed\n");
+       exit(1);
+     }
+-    int n = read(fd, (void*)addr, 8192);
+-    if(n > 0){
+-      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++    int n = read(fd, (void *)addr, 8192);
++    if (n > 0)
++    {
++      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+       exit(1);
+     }
+     close(fd);
+ 
+     int fds[2];
+-    if(pipe(fds) < 0){
++    if (pipe(fds) < 0)
++    {
+       printf("pipe() failed\n");
+       exit(1);
+     }
+     n = write(fds[1], "x", 1);
+-    if(n != 1){
++    if (n != 1)
++    {
+       printf("pipe write failed\n");
+       exit(1);
+     }
+-    n = read(fds[0], (void*)addr, 8192);
+-    if(n > 0){
+-      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
++    n = read(fds[0], (void *)addr, 8192);
++    if (n > 0)
++    {
++      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void *)addr, n);
+       exit(1);
+     }
+     close(fds[0]);
+@@ -116,18 +126,19 @@ copyout(char *s)
+ }
+ 
+ // what if you pass ridiculous string pointers to system calls?
+-void
+-copyinstr1(char *s)
++void copyinstr1(char *s)
+ {
+-  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+-                     0xffffffffffffffff };
++  uint64 addrs[] = {0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++                    0xffffffffffffffff};
+ 
+-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++  {
+     uint64 addr = addrs[ai];
+ 
+-    int fd = open((char *)addr, O_CREATE|O_WRONLY);
+-    if(fd >= 0){
+-      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
++    int fd = open((char *)addr, O_CREATE | O_WRONLY);
++    if (fd >= 0)
++    {
++      printf("open(%p) returned %d, not -1\n", (void *)addr, fd);
+       exit(1);
+     }
+   }
+@@ -136,53 +147,59 @@ copyinstr1(char *s)
+ // what if a string system call argument is exactly the size
+ // of the kernel buffer it is copied into, so that the null
+ // would fall just beyond the end of the kernel buffer?
+-void
+-copyinstr2(char *s)
++void copyinstr2(char *s)
+ {
+-  char b[MAXPATH+1];
++  char b[MAXPATH + 1];
+ 
+-  for(int i = 0; i < MAXPATH; i++)
++  for (int i = 0; i < MAXPATH; i++)
+     b[i] = 'x';
+   b[MAXPATH] = '\0';
+-  
++
+   int ret = unlink(b);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("unlink(%s) returned %d, not -1\n", b, ret);
+     exit(1);
+   }
+ 
+   int fd = open(b, O_CREATE | O_WRONLY);
+-  if(fd != -1){
++  if (fd != -1)
++  {
+     printf("open(%s) returned %d, not -1\n", b, fd);
+     exit(1);
+   }
+ 
+   ret = link(b, b);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+     exit(1);
+   }
+ 
+-  char *args[] = { "xx", 0 };
++  char *args[] = {"xx", 0};
+   ret = exec(b, args);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("exec(%s) returned %d, not -1\n", b, fd);
+     exit(1);
+   }
+ 
+   int pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed\n");
+     exit(1);
+   }
+-  if(pid == 0){
+-    static char big[PGSIZE+1];
+-    for(int i = 0; i < PGSIZE; i++)
++  if (pid == 0)
++  {
++    static char big[PGSIZE + 1];
++    for (int i = 0; i < PGSIZE; i++)
+       big[i] = 'x';
+     big[PGSIZE] = '\0';
+-    char *args2[] = { big, big, big, 0 };
++    char *args2[] = {big, big, big, 0};
+     ret = exec("echo", args2);
+-    if(ret != -1){
++    if (ret != -1)
++    {
+       printf("exec(echo, BIG) returned %d, not -1\n", fd);
+       exit(1);
+     }
+@@ -191,51 +208,57 @@ copyinstr2(char *s)
+ 
+   int st = 0;
+   wait(&st);
+-  if(st != 747){
++  if (st != 747)
++  {
+     printf("exec(echo, BIG) succeeded, should have failed\n");
+     exit(1);
+   }
+ }
+ 
+ // what if a string argument crosses over the end of last user page?
+-void
+-copyinstr3(char *s)
++void copyinstr3(char *s)
+ {
+   sbrk(8192);
+-  uint64 top = (uint64) sbrk(0);
+-  if((top % PGSIZE) != 0){
++  uint64 top = (uint64)sbrk(0);
++  if ((top % PGSIZE) != 0)
++  {
+     sbrk(PGSIZE - (top % PGSIZE));
+   }
+-  top = (uint64) sbrk(0);
+-  if(top % PGSIZE){
++  top = (uint64)sbrk(0);
++  if (top % PGSIZE)
++  {
+     printf("oops\n");
+     exit(1);
+   }
+ 
+-  char *b = (char *) (top - 1);
++  char *b = (char *)(top - 1);
+   *b = 'x';
+ 
+   int ret = unlink(b);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("unlink(%s) returned %d, not -1\n", b, ret);
+     exit(1);
+   }
+ 
+   int fd = open(b, O_CREATE | O_WRONLY);
+-  if(fd != -1){
++  if (fd != -1)
++  {
+     printf("open(%s) returned %d, not -1\n", b, fd);
+     exit(1);
+   }
+ 
+   ret = link(b, b);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+     exit(1);
+   }
+ 
+-  char *args[] = { "xx", 0 };
++  char *args[] = {"xx", 0};
+   ret = exec(b, args);
+-  if(ret != -1){
++  if (ret != -1)
++  {
+     printf("exec(%s) returned %d, not -1\n", b, fd);
+     exit(1);
+   }
+@@ -243,96 +266,105 @@ copyinstr3(char *s)
+ 
+ // See if the kernel refuses to read/write user memory that the
+ // application doesn't have anymore, because it returned it.
+-void
+-rwsbrk()
++void rwsbrk(char *)
+ {
+   int fd, n;
+-  
+-  uint64 a = (uint64) sbrk(8192);
+ 
+-  if(a == 0xffffffffffffffffLL) {
++  uint64 a = (uint64)sbrk(8192);
++
++  if (a == 0xffffffffffffffffLL)
++  {
+     printf("sbrk(rwsbrk) failed\n");
+     exit(1);
+   }
+-  
+-  if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
++
++  if ((uint64)sbrk(-8192) == 0xffffffffffffffffLL)
++  {
+     printf("sbrk(rwsbrk) shrink failed\n");
+     exit(1);
+   }
+ 
+-  fd = open("rwsbrk", O_CREATE|O_WRONLY);
+-  if(fd < 0){
++  fd = open("rwsbrk", O_CREATE | O_WRONLY);
++  if (fd < 0)
++  {
+     printf("open(rwsbrk) failed\n");
+     exit(1);
+   }
+-  n = write(fd, (void*)(a+4096), 1024);
+-  if(n >= 0){
+-    printf("write(fd, %p, 1024) returned %d, not -1\n", (void*)a+4096, n);
++  n = write(fd, (void *)(a + 4096), 1024);
++  if (n >= 0)
++  {
++    printf("write(fd, %p, 1024) returned %d, not -1\n", (void *)a + 4096, n);
+     exit(1);
+   }
+   close(fd);
+   unlink("rwsbrk");
+ 
+   fd = open("README", O_RDONLY);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("open(rwsbrk) failed\n");
+     exit(1);
+   }
+-  n = read(fd, (void*)(a+4096), 10);
+-  if(n >= 0){
+-    printf("read(fd, %p, 10) returned %d, not -1\n", (void*)a+4096, n);
++  n = read(fd, (void *)(a + 4096), 10);
++  if (n >= 0)
++  {
++    printf("read(fd, %p, 10) returned %d, not -1\n", (void *)a + 4096, n);
+     exit(1);
+   }
+   close(fd);
+-  
++
+   exit(0);
+ }
+ 
+ // test O_TRUNC.
+-void
+-truncate1(char *s)
++void truncate1(char *s)
+ {
+   char buf[32];
+-  
++
+   unlink("truncfile");
+-  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
++  int fd1 = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
+   write(fd1, "abcd", 4);
+   close(fd1);
+ 
+   int fd2 = open("truncfile", O_RDONLY);
+   int n = read(fd2, buf, sizeof(buf));
+-  if(n != 4){
++  if (n != 4)
++  {
+     printf("%s: read %d bytes, wanted 4\n", s, n);
+     exit(1);
+   }
+ 
+-  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
++  fd1 = open("truncfile", O_WRONLY | O_TRUNC);
+ 
+   int fd3 = open("truncfile", O_RDONLY);
+   n = read(fd3, buf, sizeof(buf));
+-  if(n != 0){
++  if (n != 0)
++  {
+     printf("aaa fd3=%d\n", fd3);
+     printf("%s: read %d bytes, wanted 0\n", s, n);
+     exit(1);
+   }
+ 
+   n = read(fd2, buf, sizeof(buf));
+-  if(n != 0){
++  if (n != 0)
++  {
+     printf("bbb fd2=%d\n", fd2);
+     printf("%s: read %d bytes, wanted 0\n", s, n);
+     exit(1);
+   }
+-  
++
+   write(fd1, "abcdef", 6);
+ 
+   n = read(fd3, buf, sizeof(buf));
+-  if(n != 6){
++  if (n != 6)
++  {
+     printf("%s: read %d bytes, wanted 6\n", s, n);
+     exit(1);
+   }
+ 
+   n = read(fd2, buf, sizeof(buf));
+-  if(n != 2){
++  if (n != 2)
++  {
+     printf("%s: read %d bytes, wanted 2\n", s, n);
+     exit(1);
+   }
+@@ -348,18 +380,18 @@ truncate1(char *s)
+ // this causes a write at an offset beyond the end of the file.
+ // such writes fail on xv6 (unlike POSIX) but at least
+ // they don't crash.
+-void
+-truncate2(char *s)
++void truncate2(char *s)
+ {
+   unlink("truncfile");
+ 
+-  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
++  int fd1 = open("truncfile", O_CREATE | O_TRUNC | O_WRONLY);
+   write(fd1, "abcd", 4);
+ 
+-  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
++  int fd2 = open("truncfile", O_TRUNC | O_WRONLY);
+ 
+   int n = write(fd1, "x", 1);
+-  if(n != -1){
++  if (n != -1)
++  {
+     printf("%s: write returned %d, expected -1\n", s, n);
+     exit(1);
+   }
+@@ -369,29 +401,33 @@ truncate2(char *s)
+   close(fd2);
+ }
+ 
+-void
+-truncate3(char *s)
++void truncate3(char *s)
+ {
+   int pid, xstatus;
+ 
+-  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
+-  
++  close(open("truncfile", O_CREATE | O_TRUNC | O_WRONLY));
++
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+ 
+-  if(pid == 0){
+-    for(int i = 0; i < 100; i++){
++  if (pid == 0)
++  {
++    for (int i = 0; i < 100; i++)
++    {
+       char buf[32];
+       int fd = open("truncfile", O_WRONLY);
+-      if(fd < 0){
++      if (fd < 0)
++      {
+         printf("%s: open failed\n", s);
+         exit(1);
+       }
+       int n = write(fd, "1234567890", 10);
+-      if(n != 10){
++      if (n != 10)
++      {
+         printf("%s: write got %d, expected 10\n", s, n);
+         exit(1);
+       }
+@@ -403,14 +439,17 @@ truncate3(char *s)
+     exit(0);
+   }
+ 
+-  for(int i = 0; i < 150; i++){
+-    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+-    if(fd < 0){
++  for (int i = 0; i < 150; i++)
++  {
++    int fd = open("truncfile", O_CREATE | O_WRONLY | O_TRUNC);
++    if (fd < 0)
++    {
+       printf("%s: open failed\n", s);
+       exit(1);
+     }
+     int n = write(fd, "xxx", 3);
+-    if(n != 3){
++    if (n != 3)
++    {
+       printf("%s: write got %d, expected 3\n", s, n);
+       exit(1);
+     }
+@@ -421,51 +460,57 @@ truncate3(char *s)
+   unlink("truncfile");
+   exit(xstatus);
+ }
+-  
+ 
+ // does chdir() call iput(p->cwd) in a transaction?
+-void
+-iputtest(char *s)
++void iputtest(char *s)
+ {
+-  if(mkdir("iputdir") < 0){
++  if (mkdir("iputdir") < 0)
++  {
+     printf("%s: mkdir failed\n", s);
+     exit(1);
+   }
+-  if(chdir("iputdir") < 0){
++  if (chdir("iputdir") < 0)
++  {
+     printf("%s: chdir iputdir failed\n", s);
+     exit(1);
+   }
+-  if(unlink("../iputdir") < 0){
++  if (unlink("../iputdir") < 0)
++  {
+     printf("%s: unlink ../iputdir failed\n", s);
+     exit(1);
+   }
+-  if(chdir("/") < 0){
++  if (chdir("/") < 0)
++  {
+     printf("%s: chdir / failed\n", s);
+     exit(1);
+   }
+ }
+ 
+ // does exit() call iput(p->cwd) in a transaction?
+-void
+-exitiputtest(char *s)
++void exitiputtest(char *s)
+ {
+   int pid, xstatus;
+ 
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+-  if(pid == 0){
+-    if(mkdir("iputdir") < 0){
++  if (pid == 0)
++  {
++    if (mkdir("iputdir") < 0)
++    {
+       printf("%s: mkdir failed\n", s);
+       exit(1);
+     }
+-    if(chdir("iputdir") < 0){
++    if (chdir("iputdir") < 0)
++    {
+       printf("%s: child chdir failed\n", s);
+       exit(1);
+     }
+-    if(unlink("../iputdir") < 0){
++    if (unlink("../iputdir") < 0)
++    {
+       printf("%s: unlink ../iputdir failed\n", s);
+       exit(1);
+     }
+@@ -486,30 +531,34 @@ exitiputtest(char *s)
+ //      for(i = 0; i < 10000; i++)
+ //        yield();
+ //    }
+-void
+-openiputtest(char *s)
++void openiputtest(char *s)
+ {
+   int pid, xstatus;
+ 
+-  if(mkdir("oidir") < 0){
++  if (mkdir("oidir") < 0)
++  {
+     printf("%s: mkdir oidir failed\n", s);
+     exit(1);
+   }
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     int fd = open("oidir", O_RDWR);
+-    if(fd >= 0){
++    if (fd >= 0)
++    {
+       printf("%s: open directory for write succeeded\n", s);
+       exit(1);
+     }
+     exit(0);
+   }
+   sleep(1);
+-  if(unlink("oidir") != 0){
++  if (unlink("oidir") != 0)
++  {
+     printf("%s: unlink failed\n", s);
+     exit(1);
+   }
+@@ -519,79 +568,92 @@ openiputtest(char *s)
+ 
+ // simple file system tests
+ 
+-void
+-opentest(char *s)
++void opentest(char *s)
+ {
+   int fd;
+ 
+   fd = open("echo", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open echo failed!\n", s);
+     exit(1);
+   }
+   close(fd);
+   fd = open("doesnotexist", 0);
+-  if(fd >= 0){
++  if (fd >= 0)
++  {
+     printf("%s: open doesnotexist succeeded!\n", s);
+     exit(1);
+   }
+ }
+ 
+-void
+-writetest(char *s)
++void writetest(char *s)
+ {
+   int fd;
+   int i;
+-  enum { N=100, SZ=10 };
+-  
+-  fd = open("small", O_CREATE|O_RDWR);
+-  if(fd < 0){
++  enum
++  {
++    N = 100,
++    SZ = 10
++  };
++
++  fd = open("small", O_CREATE | O_RDWR);
++  if (fd < 0)
++  {
+     printf("%s: error: creat small failed!\n", s);
+     exit(1);
+   }
+-  for(i = 0; i < N; i++){
+-    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
++  for (i = 0; i < N; i++)
++  {
++    if (write(fd, "aaaaaaaaaa", SZ) != SZ)
++    {
+       printf("%s: error: write aa %d new file failed\n", s, i);
+       exit(1);
+     }
+-    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
++    if (write(fd, "bbbbbbbbbb", SZ) != SZ)
++    {
+       printf("%s: error: write bb %d new file failed\n", s, i);
+       exit(1);
+     }
+   }
+   close(fd);
+   fd = open("small", O_RDONLY);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: error: open small failed!\n", s);
+     exit(1);
+   }
+-  i = read(fd, buf, N*SZ*2);
+-  if(i != N*SZ*2){
++  i = read(fd, buf, N * SZ * 2);
++  if (i != N * SZ * 2)
++  {
+     printf("%s: read failed\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(unlink("small") < 0){
++  if (unlink("small") < 0)
++  {
+     printf("%s: unlink small failed\n", s);
+     exit(1);
+   }
+ }
+ 
+-void
+-writebig(char *s)
++void writebig(char *s)
+ {
+   int i, fd, n;
+ 
+-  fd = open("big", O_CREATE|O_RDWR);
+-  if(fd < 0){
++  fd = open("big", O_CREATE | O_RDWR);
++  if (fd < 0)
++  {
+     printf("%s: error: creat big failed!\n", s);
+     exit(1);
+   }
+ 
+-  for(i = 0; i < MAXFILE; i++){
+-    ((int*)buf)[0] = i;
+-    if(write(fd, buf, BSIZE) != BSIZE){
++  for (i = 0; i < MAXFILE; i++)
++  {
++    ((int *)buf)[0] = i;
++    if (write(fd, buf, BSIZE) != BSIZE)
++    {
+       printf("%s: error: write big file failed i=%d\n", s, i);
+       exit(1);
+     }
+@@ -600,56 +662,68 @@ writebig(char *s)
+   close(fd);
+ 
+   fd = open("big", O_RDONLY);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: error: open big failed!\n", s);
+     exit(1);
+   }
+ 
+   n = 0;
+-  for(;;){
++  for (;;)
++  {
+     i = read(fd, buf, BSIZE);
+-    if(i == 0){
+-      if(n != MAXFILE){
++    if (i == 0)
++    {
++      if (n != MAXFILE)
++      {
+         printf("%s: read only %d blocks from big", s, n);
+         exit(1);
+       }
+       break;
+-    } else if(i != BSIZE){
++    }
++    else if (i != BSIZE)
++    {
+       printf("%s: read failed %d\n", s, i);
+       exit(1);
+     }
+-    if(((int*)buf)[0] != n){
++    if (((int *)buf)[0] != n)
++    {
+       printf("%s: read content of block %d is %d\n", s,
+-             n, ((int*)buf)[0]);
++             n, ((int *)buf)[0]);
+       exit(1);
+     }
+     n++;
+   }
+   close(fd);
+-  if(unlink("big") < 0){
++  if (unlink("big") < 0)
++  {
+     printf("%s: unlink big failed\n", s);
+     exit(1);
+   }
+ }
+ 
+ // many creates, followed by unlink test
+-void
+-createtest(char *s)
++void createtest(char *s)
+ {
+   int i, fd;
+-  enum { N=52 };
++  enum
++  {
++    N = 52
++  };
+ 
+   char name[3];
+   name[0] = 'a';
+   name[2] = '\0';
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     name[1] = '0' + i;
+-    fd = open(name, O_CREATE|O_RDWR);
++    fd = open(name, O_CREATE | O_RDWR);
+     close(fd);
+   }
+   name[0] = 'a';
+   name[2] = '\0';
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     name[1] = '0' + i;
+     unlink(name);
+   }
+@@ -657,152 +731,180 @@ createtest(char *s)
+ 
+ void dirtest(char *s)
+ {
+-  if(mkdir("dir0") < 0){
++  if (mkdir("dir0") < 0)
++  {
+     printf("%s: mkdir failed\n", s);
+     exit(1);
+   }
+ 
+-  if(chdir("dir0") < 0){
++  if (chdir("dir0") < 0)
++  {
+     printf("%s: chdir dir0 failed\n", s);
+     exit(1);
+   }
+ 
+-  if(chdir("..") < 0){
++  if (chdir("..") < 0)
++  {
+     printf("%s: chdir .. failed\n", s);
+     exit(1);
+   }
+ 
+-  if(unlink("dir0") < 0){
++  if (unlink("dir0") < 0)
++  {
+     printf("%s: unlink dir0 failed\n", s);
+     exit(1);
+   }
+ }
+ 
+-void
+-exectest(char *s)
++void exectest(char *s)
+ {
+   int fd, xstatus, pid;
+-  char *echoargv[] = { "echo", "OK", 0 };
++  char *echoargv[] = {"echo", "OK", 0};
+   char buf[3];
+ 
+   unlink("echo-ok");
+   pid = fork();
+-  if(pid < 0) {
+-     printf("%s: fork failed\n", s);
+-     exit(1);
++  if (pid < 0)
++  {
++    printf("%s: fork failed\n", s);
++    exit(1);
+   }
+-  if(pid == 0) {
++  if (pid == 0)
++  {
+     close(1);
+-    fd = open("echo-ok", O_CREATE|O_WRONLY);
+-    if(fd < 0) {
++    fd = open("echo-ok", O_CREATE | O_WRONLY);
++    if (fd < 0)
++    {
+       printf("%s: create failed\n", s);
+       exit(1);
+     }
+-    if(fd != 1) {
++    if (fd != 1)
++    {
+       printf("%s: wrong fd\n", s);
+       exit(1);
+     }
+-    if(exec("echo", echoargv) < 0){
++    if (exec("echo", echoargv) < 0)
++    {
+       printf("%s: exec echo failed\n", s);
+       exit(1);
+     }
+     // won't get to here
+   }
+-  if (wait(&xstatus) != pid) {
++  if (wait(&xstatus) != pid)
++  {
+     printf("%s: wait failed!\n", s);
+   }
+-  if(xstatus != 0)
++  if (xstatus != 0)
+     exit(xstatus);
+ 
+   fd = open("echo-ok", O_RDONLY);
+-  if(fd < 0) {
++  if (fd < 0)
++  {
+     printf("%s: open failed\n", s);
+     exit(1);
+   }
+-  if (read(fd, buf, 2) != 2) {
++  if (read(fd, buf, 2) != 2)
++  {
+     printf("%s: read failed\n", s);
+     exit(1);
+   }
+   unlink("echo-ok");
+-  if(buf[0] == 'O' && buf[1] == 'K')
++  if (buf[0] == 'O' && buf[1] == 'K')
+     exit(0);
+-  else {
++  else
++  {
+     printf("%s: wrong output\n", s);
+     exit(1);
+   }
+-
+ }
+ 
+ // simple fork and pipe read/write
+ 
+-void
+-pipe1(char *s)
++void pipe1(char *s)
+ {
+   int fds[2], pid, xstatus;
+   int seq, i, n, cc, total;
+-  enum { N=5, SZ=1033 };
+-  
+-  if(pipe(fds) != 0){
++  enum
++  {
++    N = 5,
++    SZ = 1033
++  };
++
++  if (pipe(fds) != 0)
++  {
+     printf("%s: pipe() failed\n", s);
+     exit(1);
+   }
+   pid = fork();
+   seq = 0;
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     close(fds[0]);
+-    for(n = 0; n < N; n++){
+-      for(i = 0; i < SZ; i++)
++    for (n = 0; n < N; n++)
++    {
++      for (i = 0; i < SZ; i++)
+         buf[i] = seq++;
+-      if(write(fds[1], buf, SZ) != SZ){
++      if (write(fds[1], buf, SZ) != SZ)
++      {
+         printf("%s: pipe1 oops 1\n", s);
+         exit(1);
+       }
+     }
+     exit(0);
+-  } else if(pid > 0){
++  }
++  else if (pid > 0)
++  {
+     close(fds[1]);
+     total = 0;
+     cc = 1;
+-    while((n = read(fds[0], buf, cc)) > 0){
+-      for(i = 0; i < n; i++){
+-        if((buf[i] & 0xff) != (seq++ & 0xff)){
++    while ((n = read(fds[0], buf, cc)) > 0)
++    {
++      for (i = 0; i < n; i++)
++      {
++        if ((buf[i] & 0xff) != (seq++ & 0xff))
++        {
+           printf("%s: pipe1 oops 2\n", s);
+           return;
+         }
+       }
+       total += n;
+       cc = cc * 2;
+-      if(cc > sizeof(buf))
++      if (cc > sizeof(buf))
+         cc = sizeof(buf);
+     }
+-    if(total != N * SZ){
++    if (total != N * SZ)
++    {
+       printf("%s: pipe1 oops 3 total %d\n", s, total);
+       exit(1);
+     }
+     close(fds[0]);
+     wait(&xstatus);
+     exit(xstatus);
+-  } else {
++  }
++  else
++  {
+     printf("%s: fork() failed\n", s);
+     exit(1);
+   }
+ }
+ 
+-
+ // test if child is killed (status = -1)
+-void
+-killstatus(char *s)
++void killstatus(char *s)
+ {
+   int xst;
+-  
+-  for(int i = 0; i < 100; i++){
++
++  for (int i = 0; i < 100; i++)
++  {
+     int pid1 = fork();
+-    if(pid1 < 0){
++    if (pid1 < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid1 == 0){
+-      while(1) {
++    if (pid1 == 0)
++    {
++      while (1)
++      {
+         getpid();
+       }
+       exit(0);
+@@ -810,56 +912,61 @@ killstatus(char *s)
+     sleep(1);
+     kill(pid1);
+     wait(&xst);
+-    if(xst != -1) {
+-       printf("%s: status should be -1\n", s);
+-       exit(1);
++    if (xst != -1)
++    {
++      printf("%s: status should be -1\n", s);
++      exit(1);
+     }
+   }
+   exit(0);
+ }
+ 
+ // meant to be run w/ at most two CPUs
+-void
+-preempt(char *s)
++void preempt(char *s)
+ {
+   int pid1, pid2, pid3;
+   int pfds[2];
+ 
+   pid1 = fork();
+-  if(pid1 < 0) {
++  if (pid1 < 0)
++  {
+     printf("%s: fork failed", s);
+     exit(1);
+   }
+-  if(pid1 == 0)
+-    for(;;)
++  if (pid1 == 0)
++    for (;;)
+       ;
+ 
+   pid2 = fork();
+-  if(pid2 < 0) {
++  if (pid2 < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+-  if(pid2 == 0)
+-    for(;;)
++  if (pid2 == 0)
++    for (;;)
+       ;
+ 
+   pipe(pfds);
+   pid3 = fork();
+-  if(pid3 < 0) {
+-     printf("%s: fork failed\n", s);
+-     exit(1);
++  if (pid3 < 0)
++  {
++    printf("%s: fork failed\n", s);
++    exit(1);
+   }
+-  if(pid3 == 0){
++  if (pid3 == 0)
++  {
+     close(pfds[0]);
+-    if(write(pfds[1], "x", 1) != 1)
++    if (write(pfds[1], "x", 1) != 1)
+       printf("%s: preempt write error", s);
+     close(pfds[1]);
+-    for(;;)
++    for (;;)
+       ;
+   }
+ 
+   close(pfds[1]);
+-  if(read(pfds[0], buf, sizeof(buf)) != 1){
++  if (read(pfds[0], buf, sizeof(buf)) != 1)
++  {
+     printf("%s: preempt read error", s);
+     return;
+   }
+@@ -875,28 +982,34 @@ preempt(char *s)
+ }
+ 
+ // try to find any races between exit and wait
+-void
+-exitwait(char *s)
++void exitwait(char *s)
+ {
+   int i, pid;
+ 
+-  for(i = 0; i < 100; i++){
++  for (i = 0; i < 100; i++)
++  {
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid){
++    if (pid)
++    {
+       int xstate;
+-      if(wait(&xstate) != pid){
++      if (wait(&xstate) != pid)
++      {
+         printf("%s: wait wrong pid\n", s);
+         exit(1);
+       }
+-      if(i != xstate) {
++      if (i != xstate)
++      {
+         printf("%s: wait wrong exit status\n", s);
+         exit(1);
+       }
+-    } else {
++    }
++    else
++    {
+       exit(i);
+     }
+   }
+@@ -905,24 +1018,30 @@ exitwait(char *s)
+ // try to find races in the reparenting
+ // code that handles a parent exiting
+ // when it still has live children.
+-void
+-reparent(char *s)
++void reparent(char *s)
+ {
+   int master_pid = getpid();
+-  for(int i = 0; i < 200; i++){
++  for (int i = 0; i < 200; i++)
++  {
+     int pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid){
+-      if(wait(0) != pid){
++    if (pid)
++    {
++      if (wait(0) != pid)
++      {
+         printf("%s: wait wrong pid\n", s);
+         exit(1);
+       }
+-    } else {
++    }
++    else
++    {
+       int pid2 = fork();
+-      if(pid2 < 0){
++      if (pid2 < 0)
++      {
+         kill(master_pid);
+         exit(1);
+       }
+@@ -933,26 +1052,34 @@ reparent(char *s)
+ }
+ 
+ // what if two children exit() at the same time?
+-void
+-twochildren(char *s)
++void twochildren(char *s)
+ {
+-  for(int i = 0; i < 1000; i++){
++  for (int i = 0; i < 1000; i++)
++  {
+     int pid1 = fork();
+-    if(pid1 < 0){
++    if (pid1 < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid1 == 0){
++    if (pid1 == 0)
++    {
+       exit(0);
+-    } else {
++    }
++    else
++    {
+       int pid2 = fork();
+-      if(pid2 < 0){
++      if (pid2 < 0)
++      {
+         printf("%s: fork failed\n", s);
+         exit(1);
+       }
+-      if(pid2 == 0){
++      if (pid2 == 0)
++      {
+         exit(0);
+-      } else {
++      }
++      else
++      {
+         wait(0);
+         wait(0);
+       }
+@@ -961,24 +1088,32 @@ twochildren(char *s)
+ }
+ 
+ // concurrent forks to try to expose locking bugs.
+-void
+-forkfork(char *s)
++void forkfork(char *s)
+ {
+-  enum { N=2 };
+-  
+-  for(int i = 0; i < N; i++){
++  enum
++  {
++    N = 2
++  };
++
++  for (int i = 0; i < N; i++)
++  {
+     int pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed", s);
+       exit(1);
+     }
+-    if(pid == 0){
+-      for(int j = 0; j < 200; j++){
++    if (pid == 0)
++    {
++      for (int j = 0; j < 200; j++)
++      {
+         int pid1 = fork();
+-        if(pid1 < 0){
++        if (pid1 < 0)
++        {
+           exit(1);
+         }
+-        if(pid1 == 0){
++        if (pid1 == 0)
++        {
+           exit(0);
+         }
+         wait(0);
+@@ -988,33 +1123,39 @@ forkfork(char *s)
+   }
+ 
+   int xstatus;
+-  for(int i = 0; i < N; i++){
++  for (int i = 0; i < N; i++)
++  {
+     wait(&xstatus);
+-    if(xstatus != 0) {
++    if (xstatus != 0)
++    {
+       printf("%s: fork in child failed", s);
+       exit(1);
+     }
+   }
+ }
+ 
+-void
+-forkforkfork(char *s)
++void forkforkfork(char *s)
+ {
+   unlink("stopforking");
+ 
+   int pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed", s);
+     exit(1);
+   }
+-  if(pid == 0){
+-    while(1){
++  if (pid == 0)
++  {
++    while (1)
++    {
+       int fd = open("stopforking", 0);
+-      if(fd >= 0){
++      if (fd >= 0)
++      {
+         exit(0);
+       }
+-      if(fork() < 0){
+-        close(open("stopforking", O_CREATE|O_RDWR));
++      if (fork() < 0)
++      {
++        close(open("stopforking", O_CREATE | O_RDWR));
+       }
+     }
+ 
+@@ -1022,7 +1163,7 @@ forkforkfork(char *s)
+   }
+ 
+   sleep(20); // two seconds
+-  close(open("stopforking", O_CREATE|O_RDWR));
++  close(open("stopforking", O_CREATE | O_RDWR));
+   wait(0);
+   sleep(10); // one second
+ }
+@@ -1032,16 +1173,18 @@ forkforkfork(char *s)
+ // deadlocks against init's wait()? also used to trigger a "panic:
+ // release" due to exit() releasing a different p->parent->lock than
+ // it acquired.
+-void
+-reparent2(char *s)
++void reparent2(char *s)
+ {
+-  for(int i = 0; i < 800; i++){
++  for (int i = 0; i < 800; i++)
++  {
+     int pid1 = fork();
+-    if(pid1 < 0){
++    if (pid1 < 0)
++    {
+       printf("fork failed\n");
+       exit(1);
+     }
+-    if(pid1 == 0){
++    if (pid1 == 0)
++    {
+       fork();
+       fork();
+       exit(0);
+@@ -1053,34 +1196,40 @@ reparent2(char *s)
+ }
+ 
+ // allocate all mem, free it, and allocate again
+-void
+-mem(char *s)
++void mem(char *s)
+ {
+   void *m1, *m2;
+   int pid;
+ 
+-  if((pid = fork()) == 0){
++  if ((pid = fork()) == 0)
++  {
+     m1 = 0;
+-    while((m2 = malloc(10001)) != 0){
+-      *(char**)m2 = m1;
++    while ((m2 = malloc(10001)) != 0)
++    {
++      *(char **)m2 = m1;
+       m1 = m2;
+     }
+-    while(m1){
+-      m2 = *(char**)m1;
++    while (m1)
++    {
++      m2 = *(char **)m1;
+       free(m1);
+       m1 = m2;
+     }
+-    m1 = malloc(1024*20);
+-    if(m1 == 0){
++    m1 = malloc(1024 * 20);
++    if (m1 == 0)
++    {
+       printf("%s: couldn't allocate mem?!!\n", s);
+       exit(1);
+     }
+     free(m1);
+     exit(0);
+-  } else {
++  }
++  else
++  {
+     int xstatus;
+     wait(&xstatus);
+-    if(xstatus == -1){
++    if (xstatus == -1)
++    {
+       // probably page fault, so might be lazy lab,
+       // so OK.
+       exit(0);
+@@ -1093,56 +1242,71 @@ mem(char *s)
+ 
+ // two processes write to the same file descriptor
+ // is the offset shared? does inode locking work?
+-void
+-sharedfd(char *s)
++void sharedfd(char *s)
+ {
+   int fd, pid, i, n, nc, np;
+-  enum { N = 1000, SZ=10};
++  enum
++  {
++    N = 1000,
++    SZ = 10
++  };
+   char buf[SZ];
+ 
+   unlink("sharedfd");
+-  fd = open("sharedfd", O_CREATE|O_RDWR);
+-  if(fd < 0){
++  fd = open("sharedfd", O_CREATE | O_RDWR);
++  if (fd < 0)
++  {
+     printf("%s: cannot open sharedfd for writing", s);
+     exit(1);
+   }
+   pid = fork();
+-  memset(buf, pid==0?'c':'p', sizeof(buf));
+-  for(i = 0; i < N; i++){
+-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
++  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
++  for (i = 0; i < N; i++)
++  {
++    if (write(fd, buf, sizeof(buf)) != sizeof(buf))
++    {
+       printf("%s: write sharedfd failed\n", s);
+       exit(1);
+     }
+   }
+-  if(pid == 0) {
++  if (pid == 0)
++  {
+     exit(0);
+-  } else {
++  }
++  else
++  {
+     int xstatus;
+     wait(&xstatus);
+-    if(xstatus != 0)
++    if (xstatus != 0)
+       exit(xstatus);
+   }
+-  
++
+   close(fd);
+   fd = open("sharedfd", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: cannot open sharedfd for reading\n", s);
+     exit(1);
+   }
+   nc = np = 0;
+-  while((n = read(fd, buf, sizeof(buf))) > 0){
+-    for(i = 0; i < sizeof(buf); i++){
+-      if(buf[i] == 'c')
++  while ((n = read(fd, buf, sizeof(buf))) > 0)
++  {
++    for (i = 0; i < sizeof(buf); i++)
++    {
++      if (buf[i] == 'c')
+         nc++;
+-      if(buf[i] == 'p')
++      if (buf[i] == 'p')
+         np++;
+     }
+   }
+   close(fd);
+   unlink("sharedfd");
+-  if(nc == N*SZ && np == N*SZ){
++  if (nc == N * SZ && np == N * SZ)
++  {
+     exit(0);
+-  } else {
++  }
++  else
++  {
+     printf("%s: nc/np test fails\n", s);
+     exit(1);
+   }
+@@ -1150,34 +1314,44 @@ sharedfd(char *s)
+ 
+ // four processes write different files at the same
+ // time, to test block allocation.
+-void
+-fourfiles(char *s)
++void fourfiles(char *s)
+ {
+   int fd, pid, i, j, n, total, pi;
+-  char *names[] = { "f0", "f1", "f2", "f3" };
++  char *names[] = {"f0", "f1", "f2", "f3"};
+   char *fname;
+-  enum { N=12, NCHILD=4, SZ=500 };
+-  
+-  for(pi = 0; pi < NCHILD; pi++){
++  enum
++  {
++    N = 12,
++    NCHILD = 4,
++    SZ = 500
++  };
++
++  for (pi = 0; pi < NCHILD; pi++)
++  {
+     fname = names[pi];
+     unlink(fname);
+ 
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+ 
+-    if(pid == 0){
++    if (pid == 0)
++    {
+       fd = open(fname, O_CREATE | O_RDWR);
+-      if(fd < 0){
++      if (fd < 0)
++      {
+         printf("%s: create failed\n", s);
+         exit(1);
+       }
+ 
+-      memset(buf, '0'+pi, SZ);
+-      for(i = 0; i < N; i++){
+-        if((n = write(fd, buf, SZ)) != SZ){
++      memset(buf, '0' + pi, SZ);
++      for (i = 0; i < N; i++)
++      {
++        if ((n = write(fd, buf, SZ)) != SZ)
++        {
+           printf("write failed %d\n", n);
+           exit(1);
+         }
+@@ -1187,19 +1361,24 @@ fourfiles(char *s)
+   }
+ 
+   int xstatus;
+-  for(pi = 0; pi < NCHILD; pi++){
++  for (pi = 0; pi < NCHILD; pi++)
++  {
+     wait(&xstatus);
+-    if(xstatus != 0)
++    if (xstatus != 0)
+       exit(xstatus);
+   }
+ 
+-  for(i = 0; i < NCHILD; i++){
++  for (i = 0; i < NCHILD; i++)
++  {
+     fname = names[i];
+     fd = open(fname, 0);
+     total = 0;
+-    while((n = read(fd, buf, sizeof(buf))) > 0){
+-      for(j = 0; j < n; j++){
+-        if(buf[j] != '0'+i){
++    while ((n = read(fd, buf, sizeof(buf))) > 0)
++    {
++      for (j = 0; j < n; j++)
++      {
++        if (buf[j] != '0' + i)
++        {
+           printf("%s: wrong char\n", s);
+           exit(1);
+         }
+@@ -1207,7 +1386,8 @@ fourfiles(char *s)
+       total += n;
+     }
+     close(fd);
+-    if(total != N*SZ){
++    if (total != N * SZ)
++    {
+       printf("wrong length %d\n", total);
+       exit(1);
+     }
+@@ -1216,34 +1396,44 @@ fourfiles(char *s)
+ }
+ 
+ // four processes create and delete different files in same directory
+-void
+-createdelete(char *s)
++void createdelete(char *s)
+ {
+-  enum { N = 20, NCHILD=4 };
++  enum
++  {
++    N = 20,
++    NCHILD = 4
++  };
+   int pid, i, fd, pi;
+   char name[32];
+ 
+-  for(pi = 0; pi < NCHILD; pi++){
++  for (pi = 0; pi < NCHILD; pi++)
++  {
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+ 
+-    if(pid == 0){
++    if (pid == 0)
++    {
+       name[0] = 'p' + pi;
+       name[2] = '\0';
+-      for(i = 0; i < N; i++){
++      for (i = 0; i < N; i++)
++      {
+         name[1] = '0' + i;
+         fd = open(name, O_CREATE | O_RDWR);
+-        if(fd < 0){
++        if (fd < 0)
++        {
+           printf("%s: create failed\n", s);
+           exit(1);
+         }
+         close(fd);
+-        if(i > 0 && (i % 2 ) == 0){
++        if (i > 0 && (i % 2) == 0)
++        {
+           name[1] = '0' + (i / 2);
+-          if(unlink(name) < 0){
++          if (unlink(name) < 0)
++          {
+             printf("%s: unlink failed\n", s);
+             exit(1);
+           }
+@@ -1254,32 +1444,40 @@ createdelete(char *s)
+   }
+ 
+   int xstatus;
+-  for(pi = 0; pi < NCHILD; pi++){
++  for (pi = 0; pi < NCHILD; pi++)
++  {
+     wait(&xstatus);
+-    if(xstatus != 0)
++    if (xstatus != 0)
+       exit(1);
+   }
+ 
+   name[0] = name[1] = name[2] = 0;
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < NCHILD; pi++){
++  for (i = 0; i < N; i++)
++  {
++    for (pi = 0; pi < NCHILD; pi++)
++    {
+       name[0] = 'p' + pi;
+       name[1] = '0' + i;
+       fd = open(name, 0);
+-      if((i == 0 || i >= N/2) && fd < 0){
++      if ((i == 0 || i >= N / 2) && fd < 0)
++      {
+         printf("%s: oops createdelete %s didn't exist\n", s, name);
+         exit(1);
+-      } else if((i >= 1 && i < N/2) && fd >= 0){
++      }
++      else if ((i >= 1 && i < N / 2) && fd >= 0)
++      {
+         printf("%s: oops createdelete %s did exist\n", s, name);
+         exit(1);
+       }
+-      if(fd >= 0)
++      if (fd >= 0)
+         close(fd);
+     }
+   }
+ 
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < NCHILD; pi++){
++  for (i = 0; i < N; i++)
++  {
++    for (pi = 0; pi < NCHILD; pi++)
++    {
+       name[0] = 'p' + pi;
+       name[1] = '0' + i;
+       unlink(name);
+@@ -1288,14 +1486,17 @@ createdelete(char *s)
+ }
+ 
+ // can I unlink a file and still read it?
+-void
+-unlinkread(char *s)
++void unlinkread(char *s)
+ {
+-  enum { SZ = 5 };
++  enum
++  {
++    SZ = 5
++  };
+   int fd, fd1;
+ 
+   fd = open("unlinkread", O_CREATE | O_RDWR);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: create unlinkread failed\n", s);
+     exit(1);
+   }
+@@ -1303,11 +1504,13 @@ unlinkread(char *s)
+   close(fd);
+ 
+   fd = open("unlinkread", O_RDWR);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open unlinkread failed\n", s);
+     exit(1);
+   }
+-  if(unlink("unlinkread") != 0){
++  if (unlink("unlinkread") != 0)
++  {
+     printf("%s: unlink unlinkread failed\n", s);
+     exit(1);
+   }
+@@ -1316,15 +1519,18 @@ unlinkread(char *s)
+   write(fd1, "yyy", 3);
+   close(fd1);
+ 
+-  if(read(fd, buf, sizeof(buf)) != SZ){
++  if (read(fd, buf, sizeof(buf)) != SZ)
++  {
+     printf("%s: unlinkread read failed", s);
+     exit(1);
+   }
+-  if(buf[0] != 'h'){
++  if (buf[0] != 'h')
++  {
+     printf("%s: unlinkread wrong data\n", s);
+     exit(1);
+   }
+-  if(write(fd, buf, 10) != 10){
++  if (write(fd, buf, 10) != 10)
++  {
+     printf("%s: unlinkread write failed\n", s);
+     exit(1);
+   }
+@@ -1332,102 +1538,126 @@ unlinkread(char *s)
+   unlink("unlinkread");
+ }
+ 
+-void
+-linktest(char *s)
++void linktest(char *s)
+ {
+-  enum { SZ = 5 };
++  enum
++  {
++    SZ = 5
++  };
+   int fd;
+ 
+   unlink("lf1");
+   unlink("lf2");
+ 
+-  fd = open("lf1", O_CREATE|O_RDWR);
+-  if(fd < 0){
++  fd = open("lf1", O_CREATE | O_RDWR);
++  if (fd < 0)
++  {
+     printf("%s: create lf1 failed\n", s);
+     exit(1);
+   }
+-  if(write(fd, "hello", SZ) != SZ){
++  if (write(fd, "hello", SZ) != SZ)
++  {
+     printf("%s: write lf1 failed\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(link("lf1", "lf2") < 0){
++  if (link("lf1", "lf2") < 0)
++  {
+     printf("%s: link lf1 lf2 failed\n", s);
+     exit(1);
+   }
+   unlink("lf1");
+ 
+-  if(open("lf1", 0) >= 0){
++  if (open("lf1", 0) >= 0)
++  {
+     printf("%s: unlinked lf1 but it is still there!\n", s);
+     exit(1);
+   }
+ 
+   fd = open("lf2", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open lf2 failed\n", s);
+     exit(1);
+   }
+-  if(read(fd, buf, sizeof(buf)) != SZ){
++  if (read(fd, buf, sizeof(buf)) != SZ)
++  {
+     printf("%s: read lf2 failed\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(link("lf2", "lf2") >= 0){
++  if (link("lf2", "lf2") >= 0)
++  {
+     printf("%s: link lf2 lf2 succeeded! oops\n", s);
+     exit(1);
+   }
+ 
+   unlink("lf2");
+-  if(link("lf2", "lf1") >= 0){
++  if (link("lf2", "lf1") >= 0)
++  {
+     printf("%s: link non-existent succeeded! oops\n", s);
+     exit(1);
+   }
+ 
+-  if(link(".", "lf1") >= 0){
++  if (link(".", "lf1") >= 0)
++  {
+     printf("%s: link . lf1 succeeded! oops\n", s);
+     exit(1);
+   }
+ }
+ 
+ // test concurrent create/link/unlink of the same file
+-void
+-concreate(char *s)
++void concreate(char *s)
+ {
+-  enum { N = 40 };
++  enum
++  {
++    N = 40
++  };
+   char file[3];
+   int i, pid, n, fd;
+   char fa[N];
+-  struct {
++  struct
++  {
+     ushort inum;
+     char name[DIRSIZ];
+   } de;
+ 
+   file[0] = 'C';
+   file[2] = '\0';
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     file[1] = '0' + i;
+     unlink(file);
+     pid = fork();
+-    if(pid && (i % 3) == 1){
++    if (pid && (i % 3) == 1)
++    {
+       link("C0", file);
+-    } else if(pid == 0 && (i % 5) == 1){
++    }
++    else if (pid == 0 && (i % 5) == 1)
++    {
+       link("C0", file);
+-    } else {
++    }
++    else
++    {
+       fd = open(file, O_CREATE | O_RDWR);
+-      if(fd < 0){
++      if (fd < 0)
++      {
+         printf("concreate create %s failed\n", file);
+         exit(1);
+       }
+       close(fd);
+     }
+-    if(pid == 0) {
++    if (pid == 0)
++    {
+       exit(0);
+-    } else {
++    }
++    else
++    {
+       int xstatus;
+       wait(&xstatus);
+-      if(xstatus != 0)
++      if (xstatus != 0)
+         exit(1);
+     }
+   }
+@@ -1435,16 +1665,20 @@ concreate(char *s)
+   memset(fa, 0, sizeof(fa));
+   fd = open(".", 0);
+   n = 0;
+-  while(read(fd, &de, sizeof(de)) > 0){
+-    if(de.inum == 0)
++  while (read(fd, &de, sizeof(de)) > 0)
++  {
++    if (de.inum == 0)
+       continue;
+-    if(de.name[0] == 'C' && de.name[2] == '\0'){
++    if (de.name[0] == 'C' && de.name[2] == '\0')
++    {
+       i = de.name[1] - '0';
+-      if(i < 0 || i >= sizeof(fa)){
++      if (i < 0 || i >= sizeof(fa))
++      {
+         printf("%s: concreate weird file %s\n", s, de.name);
+         exit(1);
+       }
+-      if(fa[i]){
++      if (fa[i])
++      {
+         printf("%s: concreate duplicate file %s\n", s, de.name);
+         exit(1);
+       }
+@@ -1454,27 +1688,33 @@ concreate(char *s)
+   }
+   close(fd);
+ 
+-  if(n != N){
++  if (n != N)
++  {
+     printf("%s: concreate not enough files in directory listing\n", s);
+     exit(1);
+   }
+ 
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     file[1] = '0' + i;
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(((i % 3) == 0 && pid == 0) ||
+-       ((i % 3) == 1 && pid != 0)){
++    if (((i % 3) == 0 && pid == 0) ||
++        ((i % 3) == 1 && pid != 0))
++    {
+       close(open(file, 0));
+       close(open(file, 0));
+       close(open(file, 0));
+       close(open(file, 0));
+       close(open(file, 0));
+       close(open(file, 0));
+-    } else {
++    }
++    else
++    {
+       unlink(file);
+       unlink(file);
+       unlink(file);
+@@ -1482,7 +1722,7 @@ concreate(char *s)
+       unlink(file);
+       unlink(file);
+     }
+-    if(pid == 0)
++    if (pid == 0)
+       exit(0);
+     else
+       wait(0);
+@@ -1491,68 +1731,77 @@ concreate(char *s)
+ 
+ // another concurrent link/unlink/create test,
+ // to look for deadlocks.
+-void
+-linkunlink(char *s)
++void linkunlink(char *s)
+ {
+   int pid, i;
+ 
+   unlink("x");
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+ 
+   unsigned int x = (pid ? 1 : 97);
+-  for(i = 0; i < 100; i++){
++  for (i = 0; i < 100; i++)
++  {
+     x = x * 1103515245 + 12345;
+-    if((x % 3) == 0){
++    if ((x % 3) == 0)
++    {
+       close(open("x", O_RDWR | O_CREATE));
+-    } else if((x % 3) == 1){
++    }
++    else if ((x % 3) == 1)
++    {
+       link("cat", "x");
+-    } else {
++    }
++    else
++    {
+       unlink("x");
+     }
+   }
+ 
+-  if(pid)
++  if (pid)
+     wait(0);
+   else
+     exit(0);
+ }
+ 
+-
+-void
+-subdir(char *s)
++void subdir(char *s)
+ {
+   int fd, cc;
+ 
+   unlink("ff");
+-  if(mkdir("dd") != 0){
++  if (mkdir("dd") != 0)
++  {
+     printf("%s: mkdir dd failed\n", s);
+     exit(1);
+   }
+ 
+   fd = open("dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: create dd/ff failed\n", s);
+     exit(1);
+   }
+   write(fd, "ff", 2);
+   close(fd);
+ 
+-  if(unlink("dd") >= 0){
++  if (unlink("dd") >= 0)
++  {
+     printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
+     exit(1);
+   }
+ 
+-  if(mkdir("/dd/dd") != 0){
++  if (mkdir("/dd/dd") != 0)
++  {
+     printf("%s: subdir mkdir dd/dd failed\n", s);
+     exit(1);
+   }
+ 
+   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: create dd/dd/ff failed\n", s);
+     exit(1);
+   }
+@@ -1560,164 +1809,199 @@ subdir(char *s)
+   close(fd);
+ 
+   fd = open("dd/dd/../ff", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open dd/dd/../ff failed\n", s);
+     exit(1);
+   }
+   cc = read(fd, buf, sizeof(buf));
+-  if(cc != 2 || buf[0] != 'f'){
++  if (cc != 2 || buf[0] != 'f')
++  {
+     printf("%s: dd/dd/../ff wrong content\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++  if (link("dd/dd/ff", "dd/dd/ffff") != 0)
++  {
+     printf("%s: link dd/dd/ff dd/dd/ffff failed\n", s);
+     exit(1);
+   }
+ 
+-  if(unlink("dd/dd/ff") != 0){
++  if (unlink("dd/dd/ff") != 0)
++  {
+     printf("%s: unlink dd/dd/ff failed\n", s);
+     exit(1);
+   }
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++  if (open("dd/dd/ff", O_RDONLY) >= 0)
++  {
+     printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
+     exit(1);
+   }
+ 
+-  if(chdir("dd") != 0){
++  if (chdir("dd") != 0)
++  {
+     printf("%s: chdir dd failed\n", s);
+     exit(1);
+   }
+-  if(chdir("dd/../../dd") != 0){
++  if (chdir("dd/../../dd") != 0)
++  {
+     printf("%s: chdir dd/../../dd failed\n", s);
+     exit(1);
+   }
+-  if(chdir("dd/../../../dd") != 0){
++  if (chdir("dd/../../../dd") != 0)
++  {
+     printf("%s: chdir dd/../../../dd failed\n", s);
+     exit(1);
+   }
+-  if(chdir("./..") != 0){
++  if (chdir("./..") != 0)
++  {
+     printf("%s: chdir ./.. failed\n", s);
+     exit(1);
+   }
+ 
+   fd = open("dd/dd/ffff", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open dd/dd/ffff failed\n", s);
+     exit(1);
+   }
+-  if(read(fd, buf, sizeof(buf)) != 2){
++  if (read(fd, buf, sizeof(buf)) != 2)
++  {
+     printf("%s: read dd/dd/ffff wrong len\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++  if (open("dd/dd/ff", O_RDONLY) >= 0)
++  {
+     printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
+     exit(1);
+   }
+ 
+-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0)
++  {
+     printf("%s: create dd/ff/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0)
++  {
+     printf("%s: create dd/xx/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(open("dd", O_CREATE) >= 0){
++  if (open("dd", O_CREATE) >= 0)
++  {
+     printf("%s: create dd succeeded!\n", s);
+     exit(1);
+   }
+-  if(open("dd", O_RDWR) >= 0){
++  if (open("dd", O_RDWR) >= 0)
++  {
+     printf("%s: open dd rdwr succeeded!\n", s);
+     exit(1);
+   }
+-  if(open("dd", O_WRONLY) >= 0){
++  if (open("dd", O_WRONLY) >= 0)
++  {
+     printf("%s: open dd wronly succeeded!\n", s);
+     exit(1);
+   }
+-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
++  if (link("dd/ff/ff", "dd/dd/xx") == 0)
++  {
+     printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
++  if (link("dd/xx/ff", "dd/dd/xx") == 0)
++  {
+     printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(link("dd/ff", "dd/dd/ffff") == 0){
++  if (link("dd/ff", "dd/dd/ffff") == 0)
++  {
+     printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
+     exit(1);
+   }
+-  if(mkdir("dd/ff/ff") == 0){
++  if (mkdir("dd/ff/ff") == 0)
++  {
+     printf("%s: mkdir dd/ff/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(mkdir("dd/xx/ff") == 0){
++  if (mkdir("dd/xx/ff") == 0)
++  {
+     printf("%s: mkdir dd/xx/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(mkdir("dd/dd/ffff") == 0){
++  if (mkdir("dd/dd/ffff") == 0)
++  {
+     printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
+     exit(1);
+   }
+-  if(unlink("dd/xx/ff") == 0){
++  if (unlink("dd/xx/ff") == 0)
++  {
+     printf("%s: unlink dd/xx/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(unlink("dd/ff/ff") == 0){
++  if (unlink("dd/ff/ff") == 0)
++  {
+     printf("%s: unlink dd/ff/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(chdir("dd/ff") == 0){
++  if (chdir("dd/ff") == 0)
++  {
+     printf("%s: chdir dd/ff succeeded!\n", s);
+     exit(1);
+   }
+-  if(chdir("dd/xx") == 0){
++  if (chdir("dd/xx") == 0)
++  {
+     printf("%s: chdir dd/xx succeeded!\n", s);
+     exit(1);
+   }
+ 
+-  if(unlink("dd/dd/ffff") != 0){
++  if (unlink("dd/dd/ffff") != 0)
++  {
+     printf("%s: unlink dd/dd/ff failed\n", s);
+     exit(1);
+   }
+-  if(unlink("dd/ff") != 0){
++  if (unlink("dd/ff") != 0)
++  {
+     printf("%s: unlink dd/ff failed\n", s);
+     exit(1);
+   }
+-  if(unlink("dd") == 0){
++  if (unlink("dd") == 0)
++  {
+     printf("%s: unlink non-empty dd succeeded!\n", s);
+     exit(1);
+   }
+-  if(unlink("dd/dd") < 0){
++  if (unlink("dd/dd") < 0)
++  {
+     printf("%s: unlink dd/dd failed\n", s);
+     exit(1);
+   }
+-  if(unlink("dd") < 0){
++  if (unlink("dd") < 0)
++  {
+     printf("%s: unlink dd failed\n", s);
+     exit(1);
+   }
+ }
+ 
+ // test writes that are larger than the log.
+-void
+-bigwrite(char *s)
++void bigwrite(char *s)
+ {
+   int fd, sz;
+ 
+   unlink("bigwrite");
+-  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
++  for (sz = 499; sz < (MAXOPBLOCKS + 2) * BSIZE; sz += 471)
++  {
+     fd = open("bigwrite", O_CREATE | O_RDWR);
+-    if(fd < 0){
++    if (fd < 0)
++    {
+       printf("%s: cannot create bigwrite\n", s);
+       exit(1);
+     }
+     int i;
+-    for(i = 0; i < 2; i++){
++    for (i = 0; i < 2; i++)
++    {
+       int cc = write(fd, buf, sz);
+-      if(cc != sz){
++      if (cc != sz)
++      {
+         printf("%s: write(%d) ret %d\n", s, sz, cc);
+         exit(1);
+       }
+@@ -1727,22 +2011,27 @@ bigwrite(char *s)
+   }
+ }
+ 
+-
+-void
+-bigfile(char *s)
++void bigfile(char *s)
+ {
+-  enum { N = 20, SZ=600 };
++  enum
++  {
++    N = 20,
++    SZ = 600
++  };
+   int fd, i, total, cc;
+ 
+   unlink("bigfile.dat");
+   fd = open("bigfile.dat", O_CREATE | O_RDWR);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: cannot create bigfile", s);
+     exit(1);
+   }
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     memset(buf, i, SZ);
+-    if(write(fd, buf, SZ) != SZ){
++    if (write(fd, buf, SZ) != SZ)
++    {
+       printf("%s: write bigfile failed\n", s);
+       exit(1);
+     }
+@@ -1750,70 +2039,81 @@ bigfile(char *s)
+   close(fd);
+ 
+   fd = open("bigfile.dat", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: cannot open bigfile\n", s);
+     exit(1);
+   }
+   total = 0;
+-  for(i = 0; ; i++){
+-    cc = read(fd, buf, SZ/2);
+-    if(cc < 0){
++  for (i = 0;; i++)
++  {
++    cc = read(fd, buf, SZ / 2);
++    if (cc < 0)
++    {
+       printf("%s: read bigfile failed\n", s);
+       exit(1);
+     }
+-    if(cc == 0)
++    if (cc == 0)
+       break;
+-    if(cc != SZ/2){
++    if (cc != SZ / 2)
++    {
+       printf("%s: short read bigfile\n", s);
+       exit(1);
+     }
+-    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
++    if (buf[0] != i / 2 || buf[SZ / 2 - 1] != i / 2)
++    {
+       printf("%s: read bigfile wrong data\n", s);
+       exit(1);
+     }
+     total += cc;
+   }
+   close(fd);
+-  if(total != N*SZ){
++  if (total != N * SZ)
++  {
+     printf("%s: read bigfile wrong total\n", s);
+     exit(1);
+   }
+   unlink("bigfile.dat");
+ }
+ 
+-void
+-fourteen(char *s)
++void fourteen(char *s)
+ {
+   int fd;
+ 
+   // DIRSIZ is 14.
+ 
+-  if(mkdir("12345678901234") != 0){
++  if (mkdir("12345678901234") != 0)
++  {
+     printf("%s: mkdir 12345678901234 failed\n", s);
+     exit(1);
+   }
+-  if(mkdir("12345678901234/123456789012345") != 0){
++  if (mkdir("12345678901234/123456789012345") != 0)
++  {
+     printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
+     exit(1);
+   }
+   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
+     exit(1);
+   }
+   close(fd);
+   fd = open("12345678901234/12345678901234/12345678901234", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  if(mkdir("12345678901234/12345678901234") == 0){
++  if (mkdir("12345678901234/12345678901234") == 0)
++  {
+     printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
+     exit(1);
+   }
+-  if(mkdir("123456789012345/12345678901234") == 0){
++  if (mkdir("123456789012345/12345678901234") == 0)
++  {
+     printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
+     exit(1);
+   }
+@@ -1827,92 +2127,108 @@ fourteen(char *s)
+   unlink("12345678901234");
+ }
+ 
+-void
+-rmdot(char *s)
++void rmdot(char *s)
+ {
+-  if(mkdir("dots") != 0){
++  if (mkdir("dots") != 0)
++  {
+     printf("%s: mkdir dots failed\n", s);
+     exit(1);
+   }
+-  if(chdir("dots") != 0){
++  if (chdir("dots") != 0)
++  {
+     printf("%s: chdir dots failed\n", s);
+     exit(1);
+   }
+-  if(unlink(".") == 0){
++  if (unlink(".") == 0)
++  {
+     printf("%s: rm . worked!\n", s);
+     exit(1);
+   }
+-  if(unlink("..") == 0){
++  if (unlink("..") == 0)
++  {
+     printf("%s: rm .. worked!\n", s);
+     exit(1);
+   }
+-  if(chdir("/") != 0){
++  if (chdir("/") != 0)
++  {
+     printf("%s: chdir / failed\n", s);
+     exit(1);
+   }
+-  if(unlink("dots/.") == 0){
++  if (unlink("dots/.") == 0)
++  {
+     printf("%s: unlink dots/. worked!\n", s);
+     exit(1);
+   }
+-  if(unlink("dots/..") == 0){
++  if (unlink("dots/..") == 0)
++  {
+     printf("%s: unlink dots/.. worked!\n", s);
+     exit(1);
+   }
+-  if(unlink("dots") != 0){
++  if (unlink("dots") != 0)
++  {
+     printf("%s: unlink dots failed!\n", s);
+     exit(1);
+   }
+ }
+ 
+-void
+-dirfile(char *s)
++void dirfile(char *s)
+ {
+   int fd;
+ 
+   fd = open("dirfile", O_CREATE);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: create dirfile failed\n", s);
+     exit(1);
+   }
+   close(fd);
+-  if(chdir("dirfile") == 0){
++  if (chdir("dirfile") == 0)
++  {
+     printf("%s: chdir dirfile succeeded!\n", s);
+     exit(1);
+   }
+   fd = open("dirfile/xx", 0);
+-  if(fd >= 0){
++  if (fd >= 0)
++  {
+     printf("%s: create dirfile/xx succeeded!\n", s);
+     exit(1);
+   }
+   fd = open("dirfile/xx", O_CREATE);
+-  if(fd >= 0){
++  if (fd >= 0)
++  {
+     printf("%s: create dirfile/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(mkdir("dirfile/xx") == 0){
++  if (mkdir("dirfile/xx") == 0)
++  {
+     printf("%s: mkdir dirfile/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(unlink("dirfile/xx") == 0){
++  if (unlink("dirfile/xx") == 0)
++  {
+     printf("%s: unlink dirfile/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(link("README", "dirfile/xx") == 0){
++  if (link("README", "dirfile/xx") == 0)
++  {
+     printf("%s: link to dirfile/xx succeeded!\n", s);
+     exit(1);
+   }
+-  if(unlink("dirfile") != 0){
++  if (unlink("dirfile") != 0)
++  {
+     printf("%s: unlink dirfile failed!\n", s);
+     exit(1);
+   }
+ 
+   fd = open(".", O_RDWR);
+-  if(fd >= 0){
++  if (fd >= 0)
++  {
+     printf("%s: open . for writing succeeded!\n", s);
+     exit(1);
+   }
+   fd = open(".", 0);
+-  if(write(fd, "x", 1) > 0){
++  if (write(fd, "x", 1) > 0)
++  {
+     printf("%s: write . succeeded!\n", s);
+     exit(1);
+   }
+@@ -1921,17 +2237,19 @@ dirfile(char *s)
+ 
+ // test that iput() is called at the end of _namei().
+ // also tests empty file names.
+-void
+-iref(char *s)
++void iref(char *s)
+ {
+   int i, fd;
+ 
+-  for(i = 0; i < NINODE + 1; i++){
+-    if(mkdir("irefd") != 0){
++  for (i = 0; i < NINODE + 1; i++)
++  {
++    if (mkdir("irefd") != 0)
++    {
+       printf("%s: mkdir irefd failed\n", s);
+       exit(1);
+     }
+-    if(chdir("irefd") != 0){
++    if (chdir("irefd") != 0)
++    {
+       printf("%s: chdir irefd failed\n", s);
+       exit(1);
+     }
+@@ -1939,16 +2257,17 @@ iref(char *s)
+     mkdir("");
+     link("README", "");
+     fd = open("", O_CREATE);
+-    if(fd >= 0)
++    if (fd >= 0)
+       close(fd);
+     fd = open("xx", O_CREATE);
+-    if(fd >= 0)
++    if (fd >= 0)
+       close(fd);
+     unlink("xx");
+   }
+ 
+   // clean up
+-  for(i = 0; i < NINODE + 1; i++){
++  for (i = 0; i < NINODE + 1; i++)
++  {
+     chdir("..");
+     unlink("irefd");
+   }
+@@ -1959,67 +2278,81 @@ iref(char *s)
+ // test that fork fails gracefully
+ // the forktest binary also does this, but it runs out of proc entries first.
+ // inside the bigger usertests binary, we run out of memory first.
+-void
+-forktest(char *s)
++void forktest(char *s)
+ {
+-  enum{ N = 1000 };
++  enum
++  {
++    N = 1000
++  };
+   int n, pid;
+ 
+-  for(n=0; n<N; n++){
++  for (n = 0; n < N; n++)
++  {
+     pid = fork();
+-    if(pid < 0)
++    if (pid < 0)
+       break;
+-    if(pid == 0)
++    if (pid == 0)
+       exit(0);
+   }
+ 
+-  if (n == 0) {
++  if (n == 0)
++  {
+     printf("%s: no fork at all!\n", s);
+     exit(1);
+   }
+ 
+-  if(n == N){
++  if (n == N)
++  {
+     printf("%s: fork claimed to work 1000 times!\n", s);
+     exit(1);
+   }
+ 
+-  for(; n > 0; n--){
+-    if(wait(0) < 0){
++  for (; n > 0; n--)
++  {
++    if (wait(0) < 0)
++    {
+       printf("%s: wait stopped early\n", s);
+       exit(1);
+     }
+   }
+ 
+-  if(wait(0) != -1){
++  if (wait(0) != -1)
++  {
+     printf("%s: wait got too many\n", s);
+     exit(1);
+   }
+ }
+ 
+-void
+-sbrkbasic(char *s)
++void sbrkbasic(char *s)
+ {
+-  enum { TOOMUCH=1024*1024*1024};
++  enum
++  {
++    TOOMUCH = 1024 * 1024 * 1024
++  };
+   int i, pid, xstatus;
+   char *c, *a, *b;
+ 
+   // does sbrk() return the expected failure value?
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed in sbrkbasic\n");
+     exit(1);
+   }
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     a = sbrk(TOOMUCH);
+-    if(a == (char*)0xffffffffffffffffL){
++    if (a == (char *)0xffffffffffffffffL)
++    {
+       // it's OK if this fails.
+       exit(0);
+     }
+-    
+-    for(b = a; b < a+TOOMUCH; b += 4096){
++
++    for (b = a; b < a + TOOMUCH; b += 4096)
++    {
+       *b = 99;
+     }
+-    
++
+     // we should not get here! either sbrk(TOOMUCH)
+     // should have failed, or (with lazy allocation)
+     // a pagefault should have killed this process.
+@@ -2027,16 +2360,19 @@ sbrkbasic(char *s)
+   }
+ 
+   wait(&xstatus);
+-  if(xstatus == 1){
++  if (xstatus == 1)
++  {
+     printf("%s: too much memory allocated!\n", s);
+     exit(1);
+   }
+ 
+   // can one sbrk() less than a page?
+   a = sbrk(0);
+-  for(i = 0; i < 5000; i++){
++  for (i = 0; i < 5000; i++)
++  {
+     b = sbrk(1);
+-    if(b != a){
++    if (b != a)
++    {
+       printf("%s: sbrk test failed %d %p %p\n", s, i, a, b);
+       exit(1);
+     }
+@@ -2044,26 +2380,30 @@ sbrkbasic(char *s)
+     a = b + 1;
+   }
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: sbrk test fork failed\n", s);
+     exit(1);
+   }
+   c = sbrk(1);
+   c = sbrk(1);
+-  if(c != a + 1){
++  if (c != a + 1)
++  {
+     printf("%s: sbrk test failed post-fork\n", s);
+     exit(1);
+   }
+-  if(pid == 0)
++  if (pid == 0)
+     exit(0);
+   wait(&xstatus);
+   exit(xstatus);
+ }
+ 
+-void
+-sbrkmuch(char *s)
++void sbrkmuch(char *s)
+ {
+-  enum { BIG=100*1024*1024 };
++  enum
++  {
++    BIG = 100 * 1024 * 1024
++  };
+   char *c, *oldbrk, *a, *lastaddr, *p;
+   uint64 amt;
+ 
+@@ -2073,28 +2413,31 @@ sbrkmuch(char *s)
+   a = sbrk(0);
+   amt = BIG - (uint64)a;
+   p = sbrk(amt);
+-  if (p != a) {
++  if (p != a)
++  {
+     printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
+     exit(1);
+   }
+ 
+   // touch each page to make sure it exists.
+   char *eee = sbrk(0);
+-  for(char *pp = a; pp < eee; pp += 4096)
++  for (char *pp = a; pp < eee; pp += 4096)
+     *pp = 1;
+ 
+-  lastaddr = (char*) (BIG-1);
++  lastaddr = (char *)(BIG - 1);
+   *lastaddr = 99;
+ 
+   // can one de-allocate?
+   a = sbrk(0);
+   c = sbrk(-PGSIZE);
+-  if(c == (char*)0xffffffffffffffffL){
++  if (c == (char *)0xffffffffffffffffL)
++  {
+     printf("%s: sbrk could not deallocate\n", s);
+     exit(1);
+   }
+   c = sbrk(0);
+-  if(c != a - PGSIZE){
++  if (c != a - PGSIZE)
++  {
+     printf("%s: sbrk deallocation produced wrong address, a %p c %p\n", s, a, c);
+     exit(1);
+   }
+@@ -2102,11 +2445,13 @@ sbrkmuch(char *s)
+   // can one re-allocate that page?
+   a = sbrk(0);
+   c = sbrk(PGSIZE);
+-  if(c != a || sbrk(0) != a + PGSIZE){
++  if (c != a || sbrk(0) != a + PGSIZE)
++  {
+     printf("%s: sbrk re-allocation failed, a %p c %p\n", s, a, c);
+     exit(1);
+   }
+-  if(*lastaddr == 99){
++  if (*lastaddr == 99)
++  {
+     // should be zero
+     printf("%s: sbrk de-allocation didn't really deallocate\n", s);
+     exit(1);
+@@ -2114,118 +2459,134 @@ sbrkmuch(char *s)
+ 
+   a = sbrk(0);
+   c = sbrk(-(sbrk(0) - oldbrk));
+-  if(c != a){
++  if (c != a)
++  {
+     printf("%s: sbrk downsize failed, a %p c %p\n", s, a, c);
+     exit(1);
+   }
+ }
+ 
+ // can we read the kernel's memory?
+-void
+-kernmem(char *s)
++void kernmem(char *s)
+ {
+   char *a;
+   int pid;
+ 
+-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
++  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000)
++  {
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid == 0){
++    if (pid == 0)
++    {
+       printf("%s: oops could read %p = %x\n", s, a, *a);
+       exit(1);
+     }
+     int xstatus;
+     wait(&xstatus);
+-    if(xstatus != -1)  // did kernel kill child?
++    if (xstatus != -1) // did kernel kill child?
+       exit(1);
+   }
+ }
+ 
+ // user code should not be able to write to addresses above MAXVA.
+-void
+-MAXVAplus(char *s)
++void MAXVAplus(char *s)
+ {
+   volatile uint64 a = MAXVA;
+-  for( ; a != 0; a <<= 1){
++  for (; a != 0; a <<= 1)
++  {
+     int pid;
+     pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+-    if(pid == 0){
+-      *(char*)a = 99;
+-      printf("%s: oops wrote %p\n", s, (void*)a);
++    if (pid == 0)
++    {
++      *(char *)a = 99;
++      printf("%s: oops wrote %p\n", s, (void *)a);
+       exit(1);
+     }
+     int xstatus;
+     wait(&xstatus);
+-    if(xstatus != -1)  // did kernel kill child?
++    if (xstatus != -1) // did kernel kill child?
+       exit(1);
+   }
+ }
+ 
+ // if we run the system out of memory, does it clean up the last
+ // failed allocation?
+-void
+-sbrkfail(char *s)
++void sbrkfail(char *s)
+ {
+-  enum { BIG=100*1024*1024 };
++  enum
++  {
++    BIG = 100 * 1024 * 1024
++  };
+   int i, xstatus;
+   int fds[2];
+   char scratch;
+   char *c, *a;
+   int pids[10];
+   int pid;
+- 
+-  if(pipe(fds) != 0){
++
++  if (pipe(fds) != 0)
++  {
+     printf("%s: pipe() failed\n", s);
+     exit(1);
+   }
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if((pids[i] = fork()) == 0){
++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
++  {
++    if ((pids[i] = fork()) == 0)
++    {
+       // allocate a lot of memory
+       sbrk(BIG - (uint64)sbrk(0));
+       write(fds[1], "x", 1);
+       // sit around until killed
+-      for(;;) sleep(1000);
++      for (;;)
++        sleep(1000);
+     }
+-    if(pids[i] != -1)
++    if (pids[i] != -1)
+       read(fds[0], &scratch, 1);
+   }
+ 
+   // if those failed allocations freed up the pages they did allocate,
+   // we'll be able to allocate here
+   c = sbrk(PGSIZE);
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if(pids[i] == -1)
++  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
++  {
++    if (pids[i] == -1)
+       continue;
+     kill(pids[i]);
+     wait(0);
+   }
+-  if(c == (char*)0xffffffffffffffffL){
++  if (c == (char *)0xffffffffffffffffL)
++  {
+     printf("%s: failed sbrk leaked memory\n", s);
+     exit(1);
+   }
+ 
+-  // test running fork with the above allocated page 
++  // test running fork with the above allocated page
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     // allocate a lot of memory.
+     // this should produce a page fault,
+     // and thus not complete.
+     a = sbrk(0);
+-    sbrk(10*BIG);
++    sbrk(10 * BIG);
+     int n = 0;
+-    for (i = 0; i < 10*BIG; i += PGSIZE) {
+-      n += *(a+i);
++    for (i = 0; i < 10 * BIG; i += PGSIZE)
++    {
++      n += *(a + i);
+     }
+     // print n so the compiler doesn't optimize away
+     // the for loop.
+@@ -2233,26 +2594,26 @@ sbrkfail(char *s)
+     exit(1);
+   }
+   wait(&xstatus);
+-  if(xstatus != -1 && xstatus != 2)
++  if (xstatus != -1 && xstatus != 2)
+     exit(1);
+ }
+ 
+-  
+ // test reads/writes from/to allocated memory
+-void
+-sbrkarg(char *s)
++void sbrkarg(char *s)
+ {
+   char *a;
+   int fd, n;
+ 
+   a = sbrk(PGSIZE);
+-  fd = open("sbrk", O_CREATE|O_WRONLY);
++  fd = open("sbrk", O_CREATE | O_WRONLY);
+   unlink("sbrk");
+-  if(fd < 0)  {
++  if (fd < 0)
++  {
+     printf("%s: open sbrk failed\n", s);
+     exit(1);
+   }
+-  if ((n = write(fd, a, PGSIZE)) < 0) {
++  if ((n = write(fd, a, PGSIZE)) < 0)
++  {
+     printf("%s: write sbrk failed\n", s);
+     exit(1);
+   }
+@@ -2260,22 +2621,24 @@ sbrkarg(char *s)
+ 
+   // test writes to allocated memory
+   a = sbrk(PGSIZE);
+-  if(pipe((int *) a) != 0){
++  if (pipe((int *)a) != 0)
++  {
+     printf("%s: pipe() failed\n", s);
+     exit(1);
+-  } 
++  }
+ }
+ 
+-void
+-validatetest(char *s)
++void validatetest(char *s)
+ {
+   int hi;
+   uint64 p;
+ 
+-  hi = 1100*1024;
+-  for(p = 0; p <= (uint)hi; p += PGSIZE){
++  hi = 1100 * 1024;
++  for (p = 0; p <= (uint)hi; p += PGSIZE)
++  {
+     // try to crash the kernel by passing in a bad string pointer
+-    if(link("nosuchfile", (char*)p) != -1){
++    if (link("nosuchfile", (char *)p) != -1)
++    {
+       printf("%s: link should not succeed\n", s);
+       exit(1);
+     }
+@@ -2284,13 +2647,14 @@ validatetest(char *s)
+ 
+ // does uninitialized data start out zero?
+ char uninit[10000];
+-void
+-bsstest(char *s)
++void bsstest(char *s)
+ {
+   int i;
+ 
+-  for(i = 0; i < sizeof(uninit); i++){
+-    if(uninit[i] != '\0'){
++  for (i = 0; i < sizeof(uninit); i++)
++  {
++    if (uninit[i] != '\0')
++    {
+       printf("%s: bss test failed\n", s);
+       exit(1);
+     }
+@@ -2300,38 +2664,41 @@ bsstest(char *s)
+ // does exec return an error if the arguments
+ // are larger than a page? or does it write
+ // below the stack and wreck the instructions/data?
+-void
+-bigargtest(char *s)
++void bigargtest(char *s)
+ {
+   int pid, fd, xstatus;
+ 
+   unlink("bigarg-ok");
+   pid = fork();
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     static char *args[MAXARG];
+     int i;
+     char big[400];
+     memset(big, ' ', sizeof(big));
+-    big[sizeof(big)-1] = '\0';
+-    for(i = 0; i < MAXARG-1; i++)
++    big[sizeof(big) - 1] = '\0';
++    for (i = 0; i < MAXARG - 1; i++)
+       args[i] = big;
+-    args[MAXARG-1] = 0;
++    args[MAXARG - 1] = 0;
+     // this exec() should fail (and return) because the
+     // arguments are too large.
+     exec("echo", args);
+     fd = open("bigarg-ok", O_CREATE);
+     close(fd);
+     exit(0);
+-  } else if(pid < 0){
++  }
++  else if (pid < 0)
++  {
+     printf("%s: bigargtest: fork failed\n", s);
+     exit(1);
+   }
+-  
++
+   wait(&xstatus);
+-  if(xstatus != 0)
++  if (xstatus != 0)
+     exit(xstatus);
+   fd = open("bigarg-ok", 0);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: bigarg test failed!\n", s);
+     exit(1);
+   }
+@@ -2340,15 +2707,15 @@ bigargtest(char *s)
+ 
+ // what happens when the file system runs out of blocks?
+ // answer: balloc panics, so this test is not useful.
+-void
+-fsfull()
++void fsfull()
+ {
+   int nfiles;
+   int fsblocks = 0;
+ 
+   printf("fsfull test\n");
+ 
+-  for(nfiles = 0; ; nfiles++){
++  for (nfiles = 0;; nfiles++)
++  {
+     char name[64];
+     name[0] = 'f';
+     name[1] = '0' + nfiles / 1000;
+@@ -2357,26 +2724,29 @@ fsfull()
+     name[4] = '0' + (nfiles % 10);
+     name[5] = '\0';
+     printf("writing %s\n", name);
+-    int fd = open(name, O_CREATE|O_RDWR);
+-    if(fd < 0){
++    int fd = open(name, O_CREATE | O_RDWR);
++    if (fd < 0)
++    {
+       printf("open %s failed\n", name);
+       break;
+     }
+     int total = 0;
+-    while(1){
++    while (1)
++    {
+       int cc = write(fd, buf, BSIZE);
+-      if(cc < BSIZE)
++      if (cc < BSIZE)
+         break;
+       total += cc;
+       fsblocks++;
+     }
+     printf("wrote %d bytes\n", total);
+     close(fd);
+-    if(total == 0)
++    if (total == 0)
+       break;
+   }
+ 
+-  while(nfiles >= 0){
++  while (nfiles >= 0)
++  {
+     char name[64];
+     name[0] = 'f';
+     name[1] = '0' + nfiles / 1000;
+@@ -2395,7 +2765,8 @@ void argptest(char *s)
+ {
+   int fd;
+   fd = open("init", O_RDONLY);
+-  if (fd < 0) {
++  if (fd < 0)
++  {
+     printf("%s: open failed\n", s);
+     exit(1);
+   }
+@@ -2405,25 +2776,27 @@ void argptest(char *s)
+ 
+ // check that there's an invalid page beneath
+ // the user stack, to catch stack overflow.
+-void
+-stacktest(char *s)
++void stacktest(char *s)
+ {
+   int pid;
+   int xstatus;
+-  
++
+   pid = fork();
+-  if(pid == 0) {
+-    char *sp = (char *) r_sp();
+-    sp -= USERSTACK*PGSIZE;
++  if (pid == 0)
++  {
++    char *sp = (char *)r_sp();
++    sp -= USERSTACK * PGSIZE;
+     // the *sp should cause a trap.
+     printf("%s: stacktest: read below stack %d\n", s, *sp);
+     exit(1);
+-  } else if(pid < 0){
++  }
++  else if (pid < 0)
++  {
+     printf("%s: fork failed\n", s);
+     exit(1);
+   }
+   wait(&xstatus);
+-  if(xstatus == -1)  // kernel killed child?
++  if (xstatus == -1) // kernel killed child?
+     exit(0);
+   else
+     exit(xstatus);
+@@ -2431,27 +2804,31 @@ stacktest(char *s)
+ 
+ // check that writes to a few forbidden addresses
+ // cause a fault, e.g. process's text and TRAMPOLINE.
+-void
+-nowrite(char *s)
++void nowrite(char *s)
+ {
+   int pid;
+   int xstatus;
+-  uint64 addrs[] = { 0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+-                     0xffffffffffffffff };
+-  
+-  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
++  uint64 addrs[] = {0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
++                    0xffffffffffffffff};
++
++  for (int ai = 0; ai < sizeof(addrs) / sizeof(addrs[0]); ai++)
++  {
+     pid = fork();
+-    if(pid == 0) {
+-      volatile int *addr = (int *) addrs[ai];
++    if (pid == 0)
++    {
++      volatile int *addr = (int *)addrs[ai];
+       *addr = 10;
+       printf("%s: write to %p did not fail!\n", s, addr);
+       exit(0);
+-    } else if(pid < 0){
++    }
++    else if (pid < 0)
++    {
+       printf("%s: fork failed\n", s);
+       exit(1);
+     }
+     wait(&xstatus);
+-    if(xstatus == 0){
++    if (xstatus == 0)
++    {
+       // kernel did not kill child!
+       exit(1);
+     }
+@@ -2462,9 +2839,8 @@ nowrite(char *s)
+ // regression test. copyin(), copyout(), and copyinstr() used to cast
+ // the virtual page address to uint, which (with certain wild system
+ // call arguments) resulted in a kernel page faults.
+-void *big = (void*) 0xeaeb0b5b00002f5e;
+-void
+-pgbug(char *s)
++void *big = (void *)0xeaeb0b5b00002f5e;
++void pgbug(char *s)
+ {
+   char *argv[1];
+   argv[0] = 0;
+@@ -2477,16 +2853,17 @@ pgbug(char *s)
+ // regression test. does the kernel panic if a process sbrk()s its
+ // size to be less than a page, or zero, or reduces the break by an
+ // amount too small to cause a page to be freed?
+-void
+-sbrkbugs(char *s)
++void sbrkbugs(char *s)
+ {
+   int pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed\n");
+     exit(1);
+   }
+-  if(pid == 0){
+-    int sz = (uint64) sbrk(0);
++  if (pid == 0)
++  {
++    int sz = (uint64)sbrk(0);
+     // free all user memory; there used to be a bug that
+     // would not adjust p->sz correctly in this case,
+     // causing exit() to panic.
+@@ -2497,12 +2874,14 @@ sbrkbugs(char *s)
+   wait(0);
+ 
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed\n");
+     exit(1);
+   }
+-  if(pid == 0){
+-    int sz = (uint64) sbrk(0);
++  if (pid == 0)
++  {
++    int sz = (uint64)sbrk(0);
+     // set the break to somewhere in the very first
+     // page; there used to be a bug that would incorrectly
+     // free the first page.
+@@ -2512,13 +2891,15 @@ sbrkbugs(char *s)
+   wait(0);
+ 
+   pid = fork();
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed\n");
+     exit(1);
+   }
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     // set the break in the middle of a page.
+-    sbrk((10*4096 + 2048) - (uint64)sbrk(0));
++    sbrk((10 * 4096 + 2048) - (uint64)sbrk(0));
+ 
+     // reduce the break a bit, but not enough to
+     // cause a page to be freed. this used to cause
+@@ -2535,123 +2916,119 @@ sbrkbugs(char *s)
+ // if process size was somewhat more than a page boundary, and then
+ // shrunk to be somewhat less than that page boundary, can the kernel
+ // still copyin() from addresses in the last page?
+-void
+-sbrklast(char *s)
++void sbrklast(char *s)
+ {
+-  uint64 top = (uint64) sbrk(0);
+-  if((top % 4096) != 0)
++  uint64 top = (uint64)sbrk(0);
++  if ((top % 4096) != 0)
+     sbrk(4096 - (top % 4096));
+   sbrk(4096);
+   sbrk(10);
+   sbrk(-20);
+-  top = (uint64) sbrk(0);
+-  char *p = (char *) (top - 64);
++  top = (uint64)sbrk(0);
++  char *p = (char *)(top - 64);
+   p[0] = 'x';
+   p[1] = '\0';
+-  int fd = open(p, O_RDWR|O_CREATE);
++  int fd = open(p, O_RDWR | O_CREATE);
+   write(fd, p, 1);
+   close(fd);
+   fd = open(p, O_RDWR);
+   p[0] = '\0';
+   read(fd, p, 1);
+-  if(p[0] != 'x')
++  if (p[0] != 'x')
+     exit(1);
+ }
+ 
+-
+ // does sbrk handle signed int32 wrap-around with
+ // negative arguments?
+-void
+-sbrk8000(char *s)
++void sbrk8000(char *s)
+ {
+   sbrk(0x80000004);
+   volatile char *top = sbrk(0);
+-  *(top-1) = *(top-1) + 1;
++  *(top - 1) = *(top - 1) + 1;
+ }
+ 
+-
+-
+ // regression test. test whether exec() leaks memory if one of the
+ // arguments is invalid. the test passes if the kernel doesn't panic.
+-void
+-badarg(char *s)
++void badarg(char *s)
+ {
+-  for(int i = 0; i < 50000; i++){
++  for (int i = 0; i < 50000; i++)
++  {
+     char *argv[2];
+-    argv[0] = (char*)0xffffffff;
++    argv[0] = (char *)0xffffffff;
+     argv[1] = 0;
+     exec("echo", argv);
+   }
+-  
++
+   exit(0);
+ }
+ 
+-struct test {
++struct test
++{
+   void (*f)(char *);
+   char *s;
+ } quicktests[] = {
+-  {copyin, "copyin"},
+-  {copyout, "copyout"},
+-  {copyinstr1, "copyinstr1"},
+-  {copyinstr2, "copyinstr2"},
+-  {copyinstr3, "copyinstr3"},
+-  {rwsbrk, "rwsbrk" },
+-  {truncate1, "truncate1"},
+-  {truncate2, "truncate2"},
+-  {truncate3, "truncate3"},
+-  {openiputtest, "openiput"},
+-  {exitiputtest, "exitiput"},
+-  {iputtest, "iput"},
+-  {opentest, "opentest"},
+-  {writetest, "writetest"},
+-  {writebig, "writebig"},
+-  {createtest, "createtest"},
+-  {dirtest, "dirtest"},
+-  {exectest, "exectest"},
+-  {pipe1, "pipe1"},
+-  {killstatus, "killstatus"},
+-  {preempt, "preempt"},
+-  {exitwait, "exitwait"},
+-  {reparent, "reparent" },
+-  {twochildren, "twochildren"},
+-  {forkfork, "forkfork"},
+-  {forkforkfork, "forkforkfork"},
+-  {reparent2, "reparent2"},
+-  {mem, "mem"},
+-  {sharedfd, "sharedfd"},
+-  {fourfiles, "fourfiles"},
+-  {createdelete, "createdelete"},
+-  {unlinkread, "unlinkread"},
+-  {linktest, "linktest"},
+-  {concreate, "concreate"},
+-  {linkunlink, "linkunlink"},
+-  {subdir, "subdir"},
+-  {bigwrite, "bigwrite"},
+-  {bigfile, "bigfile"},
+-  {fourteen, "fourteen"},
+-  {rmdot, "rmdot"},
+-  {dirfile, "dirfile"},
+-  {iref, "iref"},
+-  {forktest, "forktest"},
+-  {sbrkbasic, "sbrkbasic"},
+-  {sbrkmuch, "sbrkmuch"},
+-  {kernmem, "kernmem"},
+-  {MAXVAplus, "MAXVAplus"},
+-  {sbrkfail, "sbrkfail"},
+-  {sbrkarg, "sbrkarg"},
+-  {validatetest, "validatetest"},
+-  {bsstest, "bsstest"},
+-  {bigargtest, "bigargtest"},
+-  {argptest, "argptest"},
+-  {stacktest, "stacktest"},
+-  {nowrite, "nowrite"},
+-  {pgbug, "pgbug" },
+-  {sbrkbugs, "sbrkbugs" },
+-  {sbrklast, "sbrklast"},
+-  {sbrk8000, "sbrk8000"},
+-  {badarg, "badarg" },
+-
+-  { 0, 0},
++    {copyin, "copyin"},
++    {copyout, "copyout"},
++    {copyinstr1, "copyinstr1"},
++    {copyinstr2, "copyinstr2"},
++    {copyinstr3, "copyinstr3"},
++    {rwsbrk, "rwsbrk"},
++    {truncate1, "truncate1"},
++    {truncate2, "truncate2"},
++    {truncate3, "truncate3"},
++    {openiputtest, "openiput"},
++    {exitiputtest, "exitiput"},
++    {iputtest, "iput"},
++    {opentest, "opentest"},
++    {writetest, "writetest"},
++    {writebig, "writebig"},
++    {createtest, "createtest"},
++    {dirtest, "dirtest"},
++    {exectest, "exectest"},
++    {pipe1, "pipe1"},
++    {killstatus, "killstatus"},
++    {preempt, "preempt"},
++    {exitwait, "exitwait"},
++    {reparent, "reparent"},
++    {twochildren, "twochildren"},
++    {forkfork, "forkfork"},
++    {forkforkfork, "forkforkfork"},
++    {reparent2, "reparent2"},
++    {mem, "mem"},
++    {sharedfd, "sharedfd"},
++    {fourfiles, "fourfiles"},
++    {createdelete, "createdelete"},
++    {unlinkread, "unlinkread"},
++    {linktest, "linktest"},
++    {concreate, "concreate"},
++    {linkunlink, "linkunlink"},
++    {subdir, "subdir"},
++    {bigwrite, "bigwrite"},
++    {bigfile, "bigfile"},
++    {fourteen, "fourteen"},
++    {rmdot, "rmdot"},
++    {dirfile, "dirfile"},
++    {iref, "iref"},
++    {forktest, "forktest"},
++    {sbrkbasic, "sbrkbasic"},
++    {sbrkmuch, "sbrkmuch"},
++    {kernmem, "kernmem"},
++    {MAXVAplus, "MAXVAplus"},
++    {sbrkfail, "sbrkfail"},
++    {sbrkarg, "sbrkarg"},
++    {validatetest, "validatetest"},
++    {bsstest, "bsstest"},
++    {bigargtest, "bigargtest"},
++    {argptest, "argptest"},
++    {stacktest, "stacktest"},
++    {nowrite, "nowrite"},
++    {pgbug, "pgbug"},
++    {sbrkbugs, "sbrkbugs"},
++    {sbrklast, "sbrklast"},
++    {sbrk8000, "sbrk8000"},
++    {badarg, "badarg"},
++
++    {0, 0},
+ };
+ 
+ //
+@@ -2659,40 +3036,47 @@ struct test {
+ //
+ 
+ // directory that uses indirect blocks
+-void
+-bigdir(char *s)
++void bigdir(char *s)
+ {
+-  enum { N = 500 };
++  enum
++  {
++    N = 500
++  };
+   int i, fd;
+   char name[10];
+ 
+   unlink("bd");
+ 
+   fd = open("bd", O_CREATE);
+-  if(fd < 0){
++  if (fd < 0)
++  {
+     printf("%s: bigdir create failed\n", s);
+     exit(1);
+   }
+   close(fd);
+ 
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     name[0] = 'x';
+     name[1] = '0' + (i / 64);
+     name[2] = '0' + (i % 64);
+     name[3] = '\0';
+-    if(link("bd", name) != 0){
++    if (link("bd", name) != 0)
++    {
+       printf("%s: bigdir i=%d link(bd, %s) failed\n", s, i, name);
+       exit(1);
+     }
+   }
+ 
+   unlink("bd");
+-  for(i = 0; i < N; i++){
++  for (i = 0; i < N; i++)
++  {
+     name[0] = 'x';
+     name[1] = '0' + (i / 64);
+     name[2] = '0' + (i % 64);
+     name[3] = '\0';
+-    if(unlink(name) != 0){
++    if (unlink(name) != 0)
++    {
+       printf("%s: bigdir unlink failed", s);
+       exit(1);
+     }
+@@ -2701,36 +3085,42 @@ bigdir(char *s)
+ 
+ // concurrent writes to try to provoke deadlock in the virtio disk
+ // driver.
+-void
+-manywrites(char *s)
++void manywrites(char *s)
+ {
+   int nchildren = 4;
+   int howmany = 30; // increase to look for deadlock
+-  
+-  for(int ci = 0; ci < nchildren; ci++){
++
++  for (int ci = 0; ci < nchildren; ci++)
++  {
+     int pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("fork failed\n");
+       exit(1);
+     }
+ 
+-    if(pid == 0){
++    if (pid == 0)
++    {
+       char name[3];
+       name[0] = 'b';
+       name[1] = 'a' + ci;
+       name[2] = '\0';
+       unlink(name);
+-      
+-      for(int iters = 0; iters < howmany; iters++){
+-        for(int i = 0; i < ci+1; i++){
++
++      for (int iters = 0; iters < howmany; iters++)
++      {
++        for (int i = 0; i < ci + 1; i++)
++        {
+           int fd = open(name, O_CREATE | O_RDWR);
+-          if(fd < 0){
++          if (fd < 0)
++          {
+             printf("%s: cannot create %s\n", s, name);
+             exit(1);
+           }
+           int sz = sizeof(buf);
+           int cc = write(fd, buf, sz);
+-          if(cc != sz){
++          if (cc != sz)
++          {
+             printf("%s: write(%d) ret %d\n", s, sz, cc);
+             exit(1);
+           }
+@@ -2744,10 +3134,11 @@ manywrites(char *s)
+     }
+   }
+ 
+-  for(int ci = 0; ci < nchildren; ci++){
++  for (int ci = 0; ci < nchildren; ci++)
++  {
+     int st = 0;
+     wait(&st);
+-    if(st != 0)
++    if (st != 0)
+       exit(st);
+   }
+   exit(0);
+@@ -2758,29 +3149,32 @@ manywrites(char *s)
+ // file is deleted? if the kernel has this bug, it will panic: balloc:
+ // out of blocks. assumed_free may need to be raised to be more than
+ // the number of free blocks. this test takes a long time.
+-void
+-badwrite(char *s)
++void badwrite(char *s)
+ {
+   int assumed_free = 600;
+-  
++
+   unlink("junk");
+-  for(int i = 0; i < assumed_free; i++){
+-    int fd = open("junk", O_CREATE|O_WRONLY);
+-    if(fd < 0){
++  for (int i = 0; i < assumed_free; i++)
++  {
++    int fd = open("junk", O_CREATE | O_WRONLY);
++    if (fd < 0)
++    {
+       printf("open junk failed\n");
+       exit(1);
+     }
+-    write(fd, (char*)0xffffffffffL, 1);
++    write(fd, (char *)0xffffffffffL, 1);
+     close(fd);
+     unlink("junk");
+   }
+ 
+-  int fd = open("junk", O_CREATE|O_WRONLY);
+-  if(fd < 0){
++  int fd = open("junk", O_CREATE | O_WRONLY);
++  if (fd < 0)
++  {
+     printf("open junk failed\n");
+     exit(1);
+   }
+-  if(write(fd, "x", 1) != 1){
++  if (write(fd, "x", 1) != 1)
++  {
+     printf("write failed\n");
+     exit(1);
+   }
+@@ -2793,34 +3187,40 @@ badwrite(char *s)
+ // test the exec() code that cleans up if it runs out
+ // of memory. it's really a test that such a condition
+ // doesn't cause a panic.
+-void
+-execout(char *s)
++void execout(char *s)
+ {
+-  for(int avail = 0; avail < 15; avail++){
++  for (int avail = 0; avail < 15; avail++)
++  {
+     int pid = fork();
+-    if(pid < 0){
++    if (pid < 0)
++    {
+       printf("fork failed\n");
+       exit(1);
+-    } else if(pid == 0){
++    }
++    else if (pid == 0)
++    {
+       // allocate all of memory.
+-      while(1){
+-        uint64 a = (uint64) sbrk(4096);
+-        if(a == 0xffffffffffffffffLL)
++      while (1)
++      {
++        uint64 a = (uint64)sbrk(4096);
++        if (a == 0xffffffffffffffffLL)
+           break;
+-        *(char*)(a + 4096 - 1) = 1;
++        *(char *)(a + 4096 - 1) = 1;
+       }
+ 
+       // free a few pages, in order to let exec() make some
+       // progress.
+-      for(int i = 0; i < avail; i++)
++      for (int i = 0; i < avail; i++)
+         sbrk(-4096);
+-      
++
+       close(1);
+-      char *args[] = { "echo", "x", 0 };
++      char *args[] = {"echo", "x", 0};
+       exec("echo", args);
+       exit(0);
+-    } else {
+-      wait((int*)0);
++    }
++    else
++    {
++      wait((int *)0);
+     }
+   }
+ 
+@@ -2828,15 +3228,15 @@ execout(char *s)
+ }
+ 
+ // can the kernel tolerate running out of disk space?
+-void
+-diskfull(char *s)
++void diskfull(char *s)
+ {
+   int fi;
+   int done = 0;
+ 
+   unlink("diskfulldir");
+-  
+-  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
++
++  for (fi = 0; done == 0 && '0' + fi < 0177; fi++)
++  {
+     char name[32];
+     name[0] = 'b';
+     name[1] = 'i';
+@@ -2844,16 +3244,19 @@ diskfull(char *s)
+     name[3] = '0' + fi;
+     name[4] = '\0';
+     unlink(name);
+-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+-    if(fd < 0){
++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++    if (fd < 0)
++    {
+       // oops, ran out of inodes before running out of blocks.
+       printf("%s: could not create file %s\n", s, name);
+       done = 1;
+       break;
+     }
+-    for(int i = 0; i < MAXFILE; i++){
++    for (int i = 0; i < MAXFILE; i++)
++    {
+       char buf[BSIZE];
+-      if(write(fd, buf, BSIZE) != BSIZE){
++      if (write(fd, buf, BSIZE) != BSIZE)
++      {
+         done = 1;
+         close(fd);
+         break;
+@@ -2867,7 +3270,8 @@ diskfull(char *s)
+   // directory content. one of these file creations
+   // is expected to fail.
+   int nzz = 128;
+-  for(int i = 0; i < nzz; i++){
++  for (int i = 0; i < nzz; i++)
++  {
+     char name[32];
+     name[0] = 'z';
+     name[1] = 'z';
+@@ -2875,19 +3279,20 @@ diskfull(char *s)
+     name[3] = '0' + (i % 32);
+     name[4] = '\0';
+     unlink(name);
+-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+-    if(fd < 0)
++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++    if (fd < 0)
+       break;
+     close(fd);
+   }
+ 
+   // this mkdir() is expected to fail.
+-  if(mkdir("diskfulldir") == 0)
++  if (mkdir("diskfulldir") == 0)
+     printf("%s: mkdir(diskfulldir) unexpectedly succeeded!\n", s);
+ 
+   unlink("diskfulldir");
+ 
+-  for(int i = 0; i < nzz; i++){
++  for (int i = 0; i < nzz; i++)
++  {
+     char name[32];
+     name[0] = 'z';
+     name[1] = 'z';
+@@ -2897,7 +3302,8 @@ diskfull(char *s)
+     unlink(name);
+   }
+ 
+-  for(int i = 0; '0' + i < 0177; i++){
++  for (int i = 0; '0' + i < 0177; i++)
++  {
+     char name[32];
+     name[0] = 'b';
+     name[1] = 'i';
+@@ -2908,11 +3314,11 @@ diskfull(char *s)
+   }
+ }
+ 
+-void
+-outofinodes(char *s)
++void outofinodes(char *s)
+ {
+-  int nzz = 32*32;
+-  for(int i = 0; i < nzz; i++){
++  int nzz = 32 * 32;
++  for (int i = 0; i < nzz; i++)
++  {
+     char name[32];
+     name[0] = 'z';
+     name[1] = 'z';
+@@ -2920,15 +3326,17 @@ outofinodes(char *s)
+     name[3] = '0' + (i % 32);
+     name[4] = '\0';
+     unlink(name);
+-    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+-    if(fd < 0){
++    int fd = open(name, O_CREATE | O_RDWR | O_TRUNC);
++    if (fd < 0)
++    {
+       // failure is eventually expected.
+       break;
+     }
+     close(fd);
+   }
+ 
+-  for(int i = 0; i < nzz; i++){
++  for (int i = 0; i < nzz; i++)
++  {
+     char name[32];
+     name[0] = 'z';
+     name[1] = 'z';
+@@ -2940,14 +3348,14 @@ outofinodes(char *s)
+ }
+ 
+ struct test slowtests[] = {
+-  {bigdir, "bigdir"},
+-  {manywrites, "manywrites"},
+-  {badwrite, "badwrite" },
+-  {execout, "execout"},
+-  {diskfull, "diskfull"},
+-  {outofinodes, "outofinodes"},
+-    
+-  { 0, 0},
++    {bigdir, "bigdir"},
++    {manywrites, "manywrites"},
++    {badwrite, "badwrite"},
++    {execout, "execout"},
++    {diskfull, "diskfull"},
++    {outofinodes, "outofinodes"},
++
++    {0, 0},
+ };
+ 
+ //
+@@ -2956,22 +3364,26 @@ struct test slowtests[] = {
+ 
+ // run each test in its own process. run returns 1 if child's exit()
+ // indicates success.
+-int
+-run(void f(char *), char *s) {
++int run(void f(char *), char *s)
++{
+   int pid;
+   int xstatus;
+ 
+   printf("test %s: ", s);
+-  if((pid = fork()) < 0) {
++  if ((pid = fork()) < 0)
++  {
+     printf("runtest: fork error\n");
+     exit(1);
+   }
+-  if(pid == 0) {
++  if (pid == 0)
++  {
+     f(s);
+     exit(0);
+-  } else {
++  }
++  else
++  {
+     wait(&xstatus);
+-    if(xstatus != 0) 
++    if (xstatus != 0)
+       printf("FAILED\n");
+     else
+       printf("OK\n");
+@@ -2979,12 +3391,16 @@ run(void f(char *), char *s) {
+   }
+ }
+ 
+-int
+-runtests(struct test *tests, char *justone, int continuous) {
+-  for (struct test *t = tests; t->s != 0; t++) {
+-    if((justone == 0) || strcmp(t->s, justone) == 0) {
+-      if(!run(t->f, t->s)){
+-        if(continuous != 2){
++int runtests(struct test *tests, char *justone, int continuous)
++{
++  for (struct test *t = tests; t->s != 0; t++)
++  {
++    if ((justone == 0) || strcmp(t->s, justone) == 0)
++    {
++      if (!run(t->f, t->s))
++      {
++        if (continuous != 2)
++        {
+           printf("SOME TESTS FAILED\n");
+           return 1;
+         }
+@@ -2994,36 +3410,39 @@ runtests(struct test *tests, char *justone, int continuous) {
+   return 0;
+ }
+ 
+-
+ //
+ // use sbrk() to count how many free physical memory pages there are.
+ // touches the pages to force allocation.
+ // because out of memory with lazy allocation results in the process
+ // taking a fault and being killed, fork and report back.
+ //
+-int
+-countfree()
++int countfree()
+ {
+   int fds[2];
+ 
+-  if(pipe(fds) < 0){
++  if (pipe(fds) < 0)
++  {
+     printf("pipe() failed in countfree()\n");
+     exit(1);
+   }
+-  
++
+   int pid = fork();
+ 
+-  if(pid < 0){
++  if (pid < 0)
++  {
+     printf("fork failed in countfree()\n");
+     exit(1);
+   }
+ 
+-  if(pid == 0){
++  if (pid == 0)
++  {
+     close(fds[0]);
+-    
+-    while(1){
+-      uint64 a = (uint64) sbrk(4096);
+-      if(a == 0xffffffffffffffff){
++
++    while (1)
++    {
++      uint64 a = (uint64)sbrk(4096);
++      if (a == 0xffffffffffffffff)
++      {
+         break;
+       }
+ 
+@@ -3031,7 +3450,8 @@ countfree()
+       *(char *)(a + 4096 - 1) = 1;
+ 
+       // report back one more page.
+-      if(write(fds[1], "x", 1) != 1){
++      if (write(fds[1], "x", 1) != 1)
++      {
+         printf("write() failed in countfree()\n");
+         exit(1);
+       }
+@@ -3043,74 +3463,93 @@ countfree()
+   close(fds[1]);
+ 
+   int n = 0;
+-  while(1){
++  while (1)
++  {
+     char c;
+     int cc = read(fds[0], &c, 1);
+-    if(cc < 0){
++    if (cc < 0)
++    {
+       printf("read() failed in countfree()\n");
+       exit(1);
+     }
+-    if(cc == 0)
++    if (cc == 0)
+       break;
+     n += 1;
+   }
+ 
+   close(fds[0]);
+-  wait((int*)0);
+-  
++  wait((int *)0);
++
+   return n;
+ }
+ 
+-int
+-drivetests(int quick, int continuous, char *justone) {
+-  do {
++int drivetests(int quick, int continuous, char *justone)
++{
++  do
++  {
+     printf("usertests starting\n");
+     int free0 = countfree();
+     int free1 = 0;
+-    if (runtests(quicktests, justone, continuous)) {
+-      if(continuous != 2) {
++    if (runtests(quicktests, justone, continuous))
++    {
++      if (continuous != 2)
++      {
+         return 1;
+       }
+     }
+-    if(!quick) {
++    if (!quick)
++    {
+       if (justone == 0)
+         printf("usertests slow tests starting\n");
+-      if (runtests(slowtests, justone, continuous)) {
+-        if(continuous != 2) {
++      if (runtests(slowtests, justone, continuous))
++      {
++        if (continuous != 2)
++        {
+           return 1;
+         }
+       }
+     }
+-    if((free1 = countfree()) < free0) {
++    if ((free1 = countfree()) < free0)
++    {
+       printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
+-      if(continuous != 2) {
++      if (continuous != 2)
++      {
+         return 1;
+       }
+     }
+-  } while(continuous);
++  } while (continuous);
+   return 0;
+ }
+ 
+-int
+-main(int argc, char *argv[])
++int main(int argc, char *argv[])
+ {
+   int continuous = 0;
+   int quick = 0;
+   char *justone = 0;
+ 
+-  if(argc == 2 && strcmp(argv[1], "-q") == 0){
++  if (argc == 2 && strcmp(argv[1], "-q") == 0)
++  {
+     quick = 1;
+-  } else if(argc == 2 && strcmp(argv[1], "-c") == 0){
++  }
++  else if (argc == 2 && strcmp(argv[1], "-c") == 0)
++  {
+     continuous = 1;
+-  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
++  }
++  else if (argc == 2 && strcmp(argv[1], "-C") == 0)
++  {
+     continuous = 2;
+-  } else if(argc == 2 && argv[1][0] != '-'){
++  }
++  else if (argc == 2 && argv[1][0] != '-')
++  {
+     justone = argv[1];
+-  } else if(argc > 1){
++  }
++  else if (argc > 1)
++  {
+     printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
+     exit(1);
+   }
+-  if (drivetests(quick, continuous, justone)) {
++  if (drivetests(quick, continuous, justone))
++  {
+     exit(1);
+   }
+   printf("ALL TESTS PASSED\n");
+diff --git a/offline_2/xv6-riscv-riscv/user/usys.pl b/offline_2/xv6-riscv-riscv/user/usys.pl
+index 01e426e..9d54e5b 100755
+--- a/offline_2/xv6-riscv-riscv/user/usys.pl
++++ b/offline_2/xv6-riscv-riscv/user/usys.pl
+@@ -36,3 +36,4 @@ entry("getpid");
+ entry("sbrk");
+ entry("sleep");
+ entry("uptime");
++entry("history");
diff --git a/offline_2/xv6-riscv-riscv/user/dummyproc.c b/offline_2/xv6-riscv-riscv/user/dummyproc.c
new file mode 100644
index 0000000..e5e7e6f
--- /dev/null
+++ b/offline_2/xv6-riscv-riscv/user/dummyproc.c
@@ -0,0 +1,55 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+#define CHILDREN 4
+#define LOOP_COUNT 10000
+#define SLEEP_INTERVAL 10
+#define SLEEP_TIME 1
+
+int main(int argc, char *argv[])
+{
+    if (argc < 2)
+    {
+        fprintf(2, "Usage: %s <ticket_number>\n", argv[0]);
+        exit(1);
+    }
+
+    int tickets = atoi(argv[1]);
+
+    if (settickets(tickets) < 0)
+    {
+        fprintf(2, "Error: settickets(%d) failed\n", tickets);
+        exit(1);
+    }
+
+    for (int i = 0; i < CHILDREN; i++)
+    {
+        if (fork() == 0)
+        {
+            volatile int counter = 0;
+            for (int j = 0; j < LOOP_COUNT; j++)
+            {
+                counter++;
+                if (j % SLEEP_INTERVAL == 0)
+                    sleep(SLEEP_TIME);
+            }
+            exit(0);
+        }
+    }
+
+    volatile int counter = 0;
+    for (int j = 0; j < LOOP_COUNT; j++)
+    {
+        counter++;
+        if (j % SLEEP_INTERVAL == 0)
+            sleep(SLEEP_TIME);
+    }
+
+    for (int i = 0; i < CHILDREN; i++)
+    {
+        wait(0);
+    }
+
+    exit(0);
+}
diff --git a/offline_2/xv6-riscv-riscv/user/testprocinfo.c b/offline_2/xv6-riscv-riscv/user/testprocinfo.c
new file mode 100644
index 0000000..b6d1568
--- /dev/null
+++ b/offline_2/xv6-riscv-riscv/user/testprocinfo.c
@@ -0,0 +1,25 @@
+#include "kernel/types.h"
+#include "kernel/pstat.h"
+#include "user/user.h"
+
+int main(void)
+{
+    struct pstat ps;
+    if (getpinfo(&ps) < 0)
+    {
+        printf("getpinfo failed\n");
+        exit(1);
+    }
+    printf("PID\t|\tInUse\t|\tQueue\t|\tOrigTickets\t|\tCurrTickets\t|\tTimeSlices\n");
+    for (int i = 0; i < NPROC; i++)
+    {
+        if (ps.pid[i])
+        {
+            printf("%d\t|\t%d\t|\t%d\t|\t%d\t\t|\t%d\t\t|\t%d\n",
+                   ps.pid[i], ps.inuse[i], ps.inQ[i],
+                   ps.tickets_original[i], ps.tickets_current[i],
+                   ps.time_slices[i]);
+        }
+    }
+    exit(0);
+}
\ No newline at end of file
diff --git a/offline_2/xv6-riscv-riscv/user/user.h b/offline_2/xv6-riscv-riscv/user/user.h
index 1cb3ac8..588d282 100644
--- a/offline_2/xv6-riscv-riscv/user/user.h
+++ b/offline_2/xv6-riscv-riscv/user/user.h
@@ -1,5 +1,6 @@
 struct stat;
 struct syscall_stat;
+struct pstat;
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -23,6 +24,8 @@ char* sbrk(int);
 int sleep(int);
 int uptime(void);
 int history(int, struct syscall_stat*);
+int settickets(int);
+int getpinfo(struct pstat*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/offline_2/xv6-riscv-riscv/user/usys.pl b/offline_2/xv6-riscv-riscv/user/usys.pl
index 9d54e5b..11a6776 100755
--- a/offline_2/xv6-riscv-riscv/user/usys.pl
+++ b/offline_2/xv6-riscv-riscv/user/usys.pl
@@ -37,3 +37,5 @@ entry("sbrk");
 entry("sleep");
 entry("uptime");
 entry("history");
+entry("settickets");
+entry("getpinfo");
